/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/js/app.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {}; // cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n  throw new Error('setTimeout has not been defined');\n}\n\nfunction defaultClearTimeout() {\n  throw new Error('clearTimeout has not been defined');\n}\n\n(function () {\n  try {\n    if (typeof setTimeout === 'function') {\n      cachedSetTimeout = setTimeout;\n    } else {\n      cachedSetTimeout = defaultSetTimout;\n    }\n  } catch (e) {\n    cachedSetTimeout = defaultSetTimout;\n  }\n\n  try {\n    if (typeof clearTimeout === 'function') {\n      cachedClearTimeout = clearTimeout;\n    } else {\n      cachedClearTimeout = defaultClearTimeout;\n    }\n  } catch (e) {\n    cachedClearTimeout = defaultClearTimeout;\n  }\n})();\n\nfunction runTimeout(fun) {\n  if (cachedSetTimeout === setTimeout) {\n    //normal enviroments in sane situations\n    return setTimeout(fun, 0);\n  } // if setTimeout wasn't available but was latter defined\n\n\n  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n    cachedSetTimeout = setTimeout;\n    return setTimeout(fun, 0);\n  }\n\n  try {\n    // when when somebody has screwed with setTimeout but no I.E. maddness\n    return cachedSetTimeout(fun, 0);\n  } catch (e) {\n    try {\n      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n      return cachedSetTimeout.call(null, fun, 0);\n    } catch (e) {\n      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n      return cachedSetTimeout.call(this, fun, 0);\n    }\n  }\n}\n\nfunction runClearTimeout(marker) {\n  if (cachedClearTimeout === clearTimeout) {\n    //normal enviroments in sane situations\n    return clearTimeout(marker);\n  } // if clearTimeout wasn't available but was latter defined\n\n\n  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n    cachedClearTimeout = clearTimeout;\n    return clearTimeout(marker);\n  }\n\n  try {\n    // when when somebody has screwed with setTimeout but no I.E. maddness\n    return cachedClearTimeout(marker);\n  } catch (e) {\n    try {\n      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n      return cachedClearTimeout.call(null, marker);\n    } catch (e) {\n      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n      // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n      return cachedClearTimeout.call(this, marker);\n    }\n  }\n}\n\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n  if (!draining || !currentQueue) {\n    return;\n  }\n\n  draining = false;\n\n  if (currentQueue.length) {\n    queue = currentQueue.concat(queue);\n  } else {\n    queueIndex = -1;\n  }\n\n  if (queue.length) {\n    drainQueue();\n  }\n}\n\nfunction drainQueue() {\n  if (draining) {\n    return;\n  }\n\n  var timeout = runTimeout(cleanUpNextTick);\n  draining = true;\n  var len = queue.length;\n\n  while (len) {\n    currentQueue = queue;\n    queue = [];\n\n    while (++queueIndex < len) {\n      if (currentQueue) {\n        currentQueue[queueIndex].run();\n      }\n    }\n\n    queueIndex = -1;\n    len = queue.length;\n  }\n\n  currentQueue = null;\n  draining = false;\n  runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n  var args = new Array(arguments.length - 1);\n\n  if (arguments.length > 1) {\n    for (var i = 1; i < arguments.length; i++) {\n      args[i - 1] = arguments[i];\n    }\n  }\n\n  queue.push(new Item(fun, args));\n\n  if (queue.length === 1 && !draining) {\n    runTimeout(drainQueue);\n  }\n}; // v8 likes predictible objects\n\n\nfunction Item(fun, array) {\n  this.fun = fun;\n  this.array = array;\n}\n\nItem.prototype.run = function () {\n  this.fun.apply(null, this.array);\n};\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\n\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) {\n  return [];\n};\n\nprocess.binding = function (name) {\n  throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () {\n  return '/';\n};\n\nprocess.chdir = function (dir) {\n  throw new Error('process.chdir is not supported');\n};\n\nprocess.umask = function () {\n  return 0;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzP2YyOGMiXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJjYWNoZWRTZXRUaW1lb3V0IiwiY2FjaGVkQ2xlYXJUaW1lb3V0IiwiZGVmYXVsdFNldFRpbW91dCIsIkVycm9yIiwiZGVmYXVsdENsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJlIiwiY2xlYXJUaW1lb3V0IiwicnVuVGltZW91dCIsImZ1biIsImNhbGwiLCJydW5DbGVhclRpbWVvdXQiLCJtYXJrZXIiLCJxdWV1ZSIsImRyYWluaW5nIiwiY3VycmVudFF1ZXVlIiwicXVldWVJbmRleCIsImNsZWFuVXBOZXh0VGljayIsImxlbmd0aCIsImNvbmNhdCIsImRyYWluUXVldWUiLCJ0aW1lb3V0IiwibGVuIiwicnVuIiwibmV4dFRpY2siLCJhcmdzIiwiQXJyYXkiLCJhcmd1bWVudHMiLCJpIiwicHVzaCIsIkl0ZW0iLCJhcnJheSIsInByb3RvdHlwZSIsImFwcGx5IiwidGl0bGUiLCJicm93c2VyIiwiZW52IiwiYXJndiIsInZlcnNpb24iLCJ2ZXJzaW9ucyIsIm5vb3AiLCJvbiIsImFkZExpc3RlbmVyIiwib25jZSIsIm9mZiIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiZW1pdCIsInByZXBlbmRMaXN0ZW5lciIsInByZXBlbmRPbmNlTGlzdGVuZXIiLCJsaXN0ZW5lcnMiLCJuYW1lIiwiYmluZGluZyIsImN3ZCIsImNoZGlyIiwiZGlyIiwidW1hc2siXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsSUFBSUEsT0FBTyxHQUFHQyxNQUFNLENBQUNDLE9BQVAsR0FBaUIsRUFBL0IsQyxDQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUlDLGdCQUFKO0FBQ0EsSUFBSUMsa0JBQUo7O0FBRUEsU0FBU0MsZ0JBQVQsR0FBNEI7QUFDeEIsUUFBTSxJQUFJQyxLQUFKLENBQVUs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LEdBQVIsR0FBY0osSUFBZDtBQUNBM0MsT0FBTyxDQUFDZ0QsY0FBUixHQUF5QkwsSUFBekI7QUFDQTNDLE9BQU8sQ0FBQ2lELGtCQUFSLEdBQTZCTixJQUE3QjtBQUNBM0MsT0FBTyxDQUFDa0QsSUFBUixHQUFlUCxJQUFmO0FBQ0EzQyxPQUFPLENBQUNtRCxlQUFSLEdBQTBCUixJQUExQjtBQUNBM0MsT0FBTyxDQUFDb0QsbUJBQVIsR0FBOEJULElBQTlCOztBQUVBM0MsT0FBTyxDQUFDcUQsU0FBUixHQUFvQixVQUFVQyxJQUFWLEVBQWdCO0FBQUUsU0FBTyxFQUFQO0FBQVcsQ0FBakQ7O0FBRUF0RCxPQUFPLENBQUN1RCxPQUFSLEdBQWtCLFVBQVVELElBQVYsRUFBZ0I7QUFDOUIsUUFBTSxJQUFJaEQsS0FBSixDQUFVLGtDQUFWLENBQU47QUFDSCxDQUZEOztBQUlBTixPQUFPLENBQUN3RCxHQUFSLEdBQWMsWUFBWTtBQUFFLFNBQU8sR0FBUDtBQUFZLENBQXhDOztBQUNBeEQsT0FBTyxDQUFDeUQsS0FBUixHQUFnQixVQUFVQyxHQUFWLEVBQWU7QUFDM0IsUUFBTSxJQUFJcEQsS0FBSixDQUFVLGdDQUFWLENBQU47QUFDSCxDQUZEOztBQUdBTixPQUFPLENBQUMyRCxLQUFSLEdBQWdCLFlBQVc7QUFBRSxTQUFPLENBQVA7QUFBVyxDQUF4QyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/process/browser.js\n");

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n  \"use strict\";\n\n  if (global.setImmediate) {\n    return;\n  }\n\n  var nextHandle = 1; // Spec says greater than zero\n\n  var tasksByHandle = {};\n  var currentlyRunningATask = false;\n  var doc = global.document;\n  var registerImmediate;\n\n  function setImmediate(callback) {\n    // Callback can either be a function or a string\n    if (typeof callback !== \"function\") {\n      callback = new Function(\"\" + callback);\n    } // Copy function arguments\n\n\n    var args = new Array(arguments.length - 1);\n\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i + 1];\n    } // Store and register the task\n\n\n    var task = {\n      callback: callback,\n      args: args\n    };\n    tasksByHandle[nextHandle] = task;\n    registerImmediate(nextHandle);\n    return nextHandle++;\n  }\n\n  function clearImmediate(handle) {\n    delete tasksByHandle[handle];\n  }\n\n  function run(task) {\n    var callback = task.callback;\n    var args = task.args;\n\n    switch (args.length) {\n      case 0:\n        callback();\n        break;\n\n      case 1:\n        callback(args[0]);\n        break;\n\n      case 2:\n        callback(args[0], args[1]);\n        break;\n\n      case 3:\n        callback(args[0], args[1], args[2]);\n        break;\n\n      default:\n        callback.apply(undefined, args);\n        break;\n    }\n  }\n\n  function runIfPresent(handle) {\n    // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n    // So if we're currently running a task, we'll need to delay this invocation.\n    if (currentlyRunningATask) {\n      // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n      // \"too much recursion\" error.\n      setTimeout(runIfPresent, 0, handle);\n    } else {\n      var task = tasksByHandle[handle];\n\n      if (task) {\n        currentlyRunningATask = true;\n\n        try {\n          run(task);\n        } finally {\n          clearImmediate(handle);\n          currentlyRunningATask = false;\n        }\n      }\n    }\n  }\n\n  function installNextTickImplementation() {\n    registerImmediate = function registerImmediate(handle) {\n      process.nextTick(function () {\n        runIfPresent(handle);\n      });\n    };\n  }\n\n  function canUsePostMessage() {\n    // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n    // where `global.postMessage` means something completely different and can't be used for this purpose.\n    if (global.postMessage && !global.importScripts) {\n      var postMessageIsAsynchronous = true;\n      var oldOnMessage = global.onmessage;\n\n      global.onmessage = function () {\n        postMessageIsAsynchronous = false;\n      };\n\n      global.postMessage(\"\", \"*\");\n      global.onmessage = oldOnMessage;\n      return postMessageIsAsynchronous;\n    }\n  }\n\n  function installPostMessageImplementation() {\n    // Installs an event handler on `global` for the `message` event: see\n    // * https://developer.mozilla.org/en/DOM/window.postMessage\n    // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n    var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n\n    var onGlobalMessage = function onGlobalMessage(event) {\n      if (event.source === global && typeof event.data === \"string\" && event.data.indexOf(messagePrefix) === 0) {\n        runIfPresent(+event.data.slice(messagePrefix.length));\n      }\n    };\n\n    if (global.addEventListener) {\n      global.addEventListener(\"message\", onGlobalMessage, false);\n    } else {\n      global.attachEvent(\"onmessage\", onGlobalMessage);\n    }\n\n    registerImmediate = function registerImmediate(handle) {\n      global.postMessage(messagePrefix + handle, \"*\");\n    };\n  }\n\n  function installMessageChannelImplementation() {\n    var channel = new MessageChannel();\n\n    channel.port1.onmessage = function (event) {\n      var handle = event.data;\n      runIfPresent(handle);\n    };\n\n    registerImmediate = function registerImmediate(handle) {\n      channel.port2.postMessage(handle);\n    };\n  }\n\n  function installReadyStateChangeImplementation() {\n    var html = doc.documentElement;\n\n    registerImmediate = function registerImmediate(handle) {\n      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n      var script = doc.createElement(\"script\");\n\n      script.onreadystatechange = function () {\n        runIfPresent(handle);\n        script.onreadystatechange = null;\n        html.removeChild(script);\n        script = null;\n      };\n\n      html.appendChild(script);\n    };\n  }\n\n  function installSetTimeoutImplementation() {\n    registerImmediate = function registerImmediate(handle) {\n      setTimeout(runIfPresent, 0, handle);\n    };\n  } // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n\n\n  var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n  attachTo = attachTo && attachTo.setTimeout ? attachTo : global; // Don't get fooled by e.g. browserify environments.\n\n  if ({}.toString.call(global.process) === \"[object process]\") {\n    // For Node.js before 0.9\n    installNextTickImplementation();\n  } else if (canUsePostMessage()) {\n    // For non-IE10 modern browsers\n    installPostMessageImplementation();\n  } else if (global.MessageChannel) {\n    // For web workers, where supported\n    installMessageChannelImplementation();\n  } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n    // For IE 6–8\n    installReadyStateChangeImplementation();\n  } else {\n    // For older browsers\n    installSetTimeoutImplementation();\n  }\n\n  attachTo.setImmediate = setImmediate;\n  attachTo.clearImmediate = clearImmediate;\n})(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self);\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcz82MDE3Il0sIm5hbWVzIjpbImdsb2JhbCIsInVuZGVmaW5lZCIsInNldEltbWVkaWF0ZSIsIm5leHRIYW5kbGUiLCJ0YXNrc0J5SGFuZGxlIiwiY3VycmVudGx5UnVubmluZ0FUYXNrIiwiZG9jIiwiZG9jdW1lbnQiLCJyZWdpc3RlckltbWVkaWF0ZSIsImNhbGxiYWNrIiwiRnVuY3Rpb24iLCJhcmdzIiwiQXJyYXkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJpIiwidGFzayIsImNsZWFySW1tZWRpYXRlIiwiaGFuZGxlIiwicnVuIiwiYXBwbHkiLCJydW5JZlByZXNlbnQiLCJzZXRUaW1lb3V0IiwiaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24iLCJwcm9jZXNzIiwibmV4dFRpY2siLCJjYW5Vc2VQb3N0TWVzc2FnZSIsInBvc3RNZXNzYWdlIiwiaW1wb3J0U2NyaXB0cyIsInBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMiLCJvbGRPbk1lc3NhZ2UiLCJvbm1lc3NhZ2UiLCJpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbiIsIm1lc3NhZ2VQcmVmaXgiLCJNYXRoIiwicmFuZG9tIiwib25HbG9iYWxNZXNzYWdlIiwiZXZlbnQiLCJzb3VyY2UiLCJkYXRhIiwiaW5kZXhPZiIsInNsaWNlIiwiYWRkRXZlbnRMaXN0ZW5lciIsImF0dGFjaEV2ZW50IiwiaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24iLCJjaGFubmVsIiwiTWVzc2FnZUNoYW5uZWwiLCJwb3J0MSIsInBvcnQyIiwiaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbiIsImh0bWwiLCJkb2N1bWVudEVsZW1lbnQiLCJzY3JpcHQiLCJjcmVhdGVFbGVtZW50Iiwib25yZWFkeXN0YXRlY2hhbmdlIiwicmVtb3ZlQ2hpbGQiLCJhcHBlbmRDaGlsZCIsImluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24iLCJhdHRhY2hUbyIsIk9iamVjdCIsImdldFByb3RvdHlwZU9mIiwidG9TdHJpbmciLCJjYWxsIiwic2VsZiJdLCJtYXBwaW5ncyI6IkFBQUMsa0VBQVVBLE1BQVYsRUFBa0JDLFNBQWxCLEVBQTZCO0FBQzFCOztBQUVBLE1BQUlELE1BQU0sQ0FBQ0UsWUFBWCxFQUF5QjtBQUNyQjtBQUNIOztBQUVELE1BQUlDLFVBQVUsR0FBRyxDQUFqQixDQVAwQixDQU9OOztBQUNwQixNQUFJQyxhQUFhLEdBQUcsRUFBcEI7QUFDQSxNQUFJQyxxQkFBcUIsR0FBRyxLQUE1QjtBQUNBLE1BQUlDLEdBQUcsR0FBR04sTUFBTSxDQUFDTyxRQUFqQjtBQUNBLE1BQUlDLGlCQUFKOztBQUVBLFdBQVNOLFlBQVQsQ0FBc0JPLFFBQXRCLEVBQWdDO0FBQzlCO0FBQ0EsUUFBSSxPQUFPQSxRQUFQLEtBQW9CLFVBQXhCLEVBQW9DO0FBQ2xDQSxjQUFRLEdBQUcsSUFBSUMsUUFBSixDQUFhLEtBQUtELFFBQWxCLENBQVg7QUFDRCxLQUo2QixDQUs5Qjs7O0FBQ0EsUUFBSUUsSUFBSSxHQUFHLElBQUlDLEtBQUosQ0FBVUMsU0FBUyxDQUFDQyxNQUFWLEdBQW1CLENBQTdCLENBQVg7O0FBQ0EsU0FBSyxJQUFJQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHSixJQUFJLENBQUNHLE1BQXpCLEVBQWlDQyxDQUFDLEVBQWxDLEVBQXNDO0FBQ2xDSixVQUFJLENBQUNJLENBQUQsQ0FBSixHQUFVRixTQUFTLENBQUNFLENBQUMsR0FBRyxDQUFMLENBQW5CO0FBQ0gsS0FUNkIsQ0FVOUI7OztBQUNBLFFBQUlDLElBQUksR0FBRztBQUFFUCxjQUFRLEVBQUVBLFFBQVo7QUFBc0JFLFVBQUksRUFBRUE7QUFBNUIsS0FBWDtBQUNBUCxpQkFBYSxDQUFDRCxVQUFELENBQWIsR0FBNEJhLElBQTVCO0FBQ0FSLHFCQUFpQixDQUFDTCxVQUFELENBQWpCO0FBQ0EsV0FBT0EsVUFB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QUExQjtBQUNILENBekxBLEVBeUxDLE9BQU84QyxJQUFQLEtBQWdCLFdBQWhCLEdBQThCLE9BQU8vRCxNQUFQLEtBQWtCLFdBQWxCLEdBQWdDLElBQWhDLEdBQXVDQSxNQUFyRSxHQUE4RStELElBekwvRSxDQUFELEMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEhhbmRsZSA9IDE7IC8vIFNwZWMgc2F5cyBncmVhdGVyIHRoYW4gemVyb1xuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHJlZ2lzdGVySW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4gICAgICAvLyBDYWxsYmFjayBjYW4gZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IG5ldyBGdW5jdGlvbihcIlwiICsgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgLy8gQ29weSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdO1xuICAgICAgfVxuICAgICAgLy8gU3RvcmUgYW5kIHJlZ2lzdGVyIHRoZSB0YXNrXG4gICAgICB2YXIgdGFzayA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBhcmdzOiBhcmdzIH07XG4gICAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gdGFzaztcbiAgICAgIHJlZ2lzdGVySW1tZWRpYXRlKG5leHRIYW5kbGUpO1xuICAgICAgcmV0dXJuIG5leHRIYW5kbGUrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcbiAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW4odGFzaykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0YXNrLmNhbGxiYWNrO1xuICAgICAgICB2YXIgYXJncyA9IHRhc2suYXJncztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFwiV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuXCJcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgICAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bih0YXNrKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkgeyBydW5JZlByZXNlbnQoaGFuZGxlKTsgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XG4gICAgICAgIC8vIFRoZSB0ZXN0IGFnYWluc3QgYGltcG9ydFNjcmlwdHNgIHByZXZlbnRzIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSBiZWluZyBpbnN0YWxsZWQgaW5zaWRlIGEgd2ViIHdvcmtlcixcbiAgICAgICAgLy8gd2hlcmUgYGdsb2JhbC5wb3N0TWVzc2FnZWAgbWVhbnMgc29tZXRoaW5nIGNvbXBsZXRlbHkgZGlmZmVyZW50IGFuZCBjYW4ndCBiZSB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkT25NZXNzYWdlID0gZ2xvYmFsLm9ubWVzc2FnZTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAgICAgLy8gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vd2luZG93LnBvc3RNZXNzYWdlXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcblxuICAgICAgICB2YXIgbWVzc2FnZVByZWZpeCA9IFwic2V0SW1tZWRpYXRlJFwiICsgTWF0aC5yYW5kb20oKSArIFwiJFwiO1xuICAgICAgICB2YXIgb25HbG9iYWxNZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBldmVudC5kYXRhID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgXCIqXCIpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHN1cHBvcnRlZCwgd2Ugc2hvdWxkIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlIG9mIGdsb2JhbCwgc2luY2UgdGhhdCBpcyB3aGVyZSBzZXRUaW1lb3V0IGV0IGFsLiBsaXZlLlxuICAgIHZhciBhdHRhY2hUbyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsKTtcbiAgICBhdHRhY2hUbyA9IGF0dGFjaFRvICYmIGF0dGFjaFRvLnNldFRpbWVvdXQgPyBhdHRhY2hUbyA6IGdsb2JhbDtcblxuICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgZS5nLiBicm93c2VyaWZ5IGVudmlyb25tZW50cy5cbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiKSB7XG4gICAgICAgIC8vIEZvciBOb2RlLmpzIGJlZm9yZSAwLjlcbiAgICAgICAgaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoY2FuVXNlUG9zdE1lc3NhZ2UoKSkge1xuICAgICAgICAvLyBGb3Igbm9uLUlFMTAgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChkb2MgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgICAgICAvLyBGb3IgSUUgNuKAkzhcbiAgICAgICAgaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKTtcbiAgICB9XG5cbiAgICBhdHRhY2hUby5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgYXR0YWNoVG8uY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcbn0odHlwZW9mIHNlbGYgPT09IFwidW5kZWZpbmVkXCIgPyB0eXBlb2YgZ2xvYmFsID09PSBcInVuZGVmaW5lZFwiID8gdGhpcyA6IGdsb2JhbCA6IHNlbGYpKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/setimmediate/setImmediate.js\n");

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var scope = typeof global !== \"undefined\" && global || typeof self !== \"undefined\" && self || window;\nvar apply = Function.prototype.apply; // DOM APIs, for completeness\n\nexports.setTimeout = function () {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\n\nexports.setInterval = function () {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\n\nexports.clearTimeout = exports.clearInterval = function (timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\n\nTimeout.prototype.unref = Timeout.prototype.ref = function () {};\n\nTimeout.prototype.close = function () {\n  this._clearFn.call(scope, this._id);\n}; // Does not start the time, just sets up the members needed.\n\n\nexports.enroll = function (item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function (item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function (item) {\n  clearTimeout(item._idleTimeoutId);\n  var msecs = item._idleTimeout;\n\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout) item._onTimeout();\n    }, msecs);\n  }\n}; // setimmediate attaches itself to the global object\n\n\n__webpack_require__(/*! setimmediate */ \"./node_modules/setimmediate/setImmediate.js\"); // On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\n\n\nexports.setImmediate = typeof self !== \"undefined\" && self.setImmediate || typeof global !== \"undefined\" && global.setImmediate || this && this.setImmediate;\nexports.clearImmediate = typeof self !== \"undefined\" && self.clearImmediate || typeof global !== \"undefined\" && global.clearImmediate || this && this.clearImmediate;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcz81MTE4Il0sIm5hbWVzIjpbInNjb3BlIiwiZ2xvYmFsIiwic2VsZiIsIndpbmRvdyIsImFwcGx5IiwiRnVuY3Rpb24iLCJwcm90b3R5cGUiLCJleHBvcnRzIiwic2V0VGltZW91dCIsIlRpbWVvdXQiLCJjYWxsIiwiYXJndW1lbnRzIiwiY2xlYXJUaW1lb3V0Iiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwidGltZW91dCIsImNsb3NlIiwiaWQiLCJjbGVhckZuIiwiX2lkIiwiX2NsZWFyRm4iLCJ1bnJlZiIsInJlZiIsImVucm9sbCIsIml0ZW0iLCJtc2VjcyIsIl9pZGxlVGltZW91dElkIiwiX2lkbGVUaW1lb3V0IiwidW5lbnJvbGwiLCJfdW5yZWZBY3RpdmUiLCJhY3RpdmUiLCJvblRpbWVvdXQiLCJfb25UaW1lb3V0IiwicmVxdWlyZSIsInNldEltbWVkaWF0ZSIsImNsZWFySW1tZWRpYXRlIl0sIm1hcHBpbmdzIjoiQUFBQSxrREFBSUEsS0FBSyxHQUFJLE9BQU9DLE1BQVAsS0FBa0IsV0FBbEIsSUFBaUNBLE1BQWxDLElBQ0MsT0FBT0MsSUFBUCxLQUFnQixXQUFoQixJQUErQkEsSUFEaEMsSUFFQUMsTUFGWjtBQUdBLElBQUlDLEtBQUssR0FBR0MsUUFBUSxDQUFDQyxTQUFULENBQW1CRixLQUEvQixDLENBRUE7O0FBRUFHLE9BQU8sQ0FBQ0MsVUFBUixHQUFxQixZQUFXO0FBQzlCLFNBQU8sSUFBSUMsT0FBSixDQUFZTCxLQUFLLENBQUNNLElBQU4sQ0FBV0YsVUFBWCxFQUF1QlIsS0FBdkIsRUFBOEJXLFNBQTlCLENBQVosRUFBc0RDLFlBQXRELENBQVA7QUFDRCxDQUZEOztBQUdBTCxPQUFPLENBQUNNLFdBQVIsR0FBc0IsWUFBVztBQUMvQixTQUFPLElBQUlKLE9BQUosQ0FBWUwsS0FBSyxDQUFDTSxJQUFOLENBQVdHLFdBQVgsRUFBd0JiLEtBQXhCLEVBQStCVyxTQUEvQixDQUFaLEVBQXVERyxhQUF2RCxDQUFQO0FBQ0QsQ0FGRDs7QUFHQVAsT0FBTyxDQUFDSyxZQUFSLEdBQ0FMLE9BQU8sQ0FBQ08sYUFBUixHQUF3QixVQUFTQyxPQUFULEVBQWtCO0FBQ3hDLE1BQUlBLE9BQUosRUFBYTtBQUNYQSxXQUFPLENBQUNDLEtBQVI7QUFDRDtBQUNGLENBTEQ7O0FBT0EsU0FBU1AsT0FBVCxDQUFpQlEsRUFBakIsRUFBcUJDLE9BQXJCLEVBQThCO0FBQzVCLE9BQUtDLEdBQUwsR0FBV0YsRUFBWDtBQUNBLE9BQUtHLFFBQUwsR0FBZ0JGLE9BQWhCO0FBQ0Q7O0FBQ0RULE9BQU8sQ0FBQ0gsU0FBUixDQUFrQmUsS0FBbEIsR0FBMEJaLE9BQU8sQ0FBQ0gsU0FBUixDQUFrQmdCLEdBQWxCLEdBQXdCLFlBQVcsQ0FBRSxDQUEvRDs7QUFDQWIsT0FBTyxDQUFDSCxTQUFSLENBQWtCVSxLQUFsQixHQUEwQixZQUFXO0FBQ25DLE9BQUtJLFFBQUwsQ0FBY1YsSUFBZCxDQUFtQlYsS0FBbkIsRUFBMEIsS0FBS21CLEdBQS9CO0FBQ0QsQ0FGRCxDLENBSUE7OztBQUNBWixPQUFPLENBQUNnQixNQUFSLEdBQWlCLFVBQVNDLElBQVQsRUFBZUMsS0FBZixFQUFzQjtBQUNyQ2IsY0FBWSxDQUFDWSxJQUFJLENBQUNFLGNBQU4sQ0FBWjtBQUNBRixNQUFJLENBQUNHLFlBQUwsR0FBb0JGLEtBQXBCO0FBQ0QsQ0FIRDs7QUFLQWxCLE9BQU8sQ0FBQ3FCLFFBQVIsR0FBbUIsVUFBU0osSUFBVCxFQUFlO0FBQ2hDWixjQUFZLENBQUNZLElBQUksQ0FBQ0UsY0FBTixDQUFaO0FBQ0FGLE1BQUksQ0FBQ0csWUFBTCxHQUFvQixDQUFDLENBQXJCO0FBQ0QsQ0FIRDs7QUFLQXBCLE9BQU8sQ0FBQ3NCLFlBQVIsR0FBdUJ0QixPQUFPLENBQUN1QixNQUFSLEdBQWlCLFVBQVNOLElBQVQsRUFBZTtBQUNyRFosY0FBWSxDQUFDWSxJQUFJLENBQUNFLGNBQU4sQ0FBWjtBQUVBLE1BQUlELEtBQUssR0FBR0QsSUFBSSxDQUFDRyxZQUFqQjs7QUFDQSxNQUFJRixLQUFLLElBQUksQ0FBYixFQUFnQjtBQUNkRCxRQUFJLENBQUNFLGNBQUwsR0FBc0JsQixVQUFVLENBQUMsU0FBU3VCLFNBQVQsR0FBcUI7QUFDcEQsVUFBSVAsSUFBSSxDQUFDUSxVQUFULEVBQ0VSLElBQUksQ0FBQ1EsVUFBTDtBQUNILEtBSCtCLEVBRzdCUCxLQUg2QixDQUFoQztBQUlEO0FBQ0YsQ0FWRCxDLENBWUE7OztBQUNBUSxtQkFBTyxDQUFDLGlFQUFELENBQVAsQyxDQUNBO0FBQ0E7QUFDQTs7O0FBQ0ExQixPQUFPLENBQUMyQixZQUFSLEdBQXdCLE9BQU9oQyxJQUFQLEtBQWdCLFdBQWhCLElBQStCQSxJQUFJLENBQUNnQyxZQUFyQyxJQUNDLE9BQU9qQyxNQUFQLEtBQWtCLFdBQWxCLElBQWlDQSxNQUFNLENBQUNpQyxZQUR6QyxJQUVDLFFBQVEsS0FBS0EsWUFGckM7QUFHQTNCLE9BQU8sQ0FBQzRCLGNBQVIsR0FBMEIsT0FBT2pDLElBQVAsS0FBZ0IsV0FBaEIsSUFBK0JBLElBQUksQ0FBQ2lDLGNBQXJDLElBQ0MsT0FBT2xDLE1BQVAsS0FBa0IsV0FBbEIsSUFBaUNBLE1BQU0sQ0FBQ2tDLGNBRHpDLElBRUMsUUFBUSxLQUFLQSxjQUZ2QyxDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3RpbWVycy1icm93c2VyaWZ5L21haW4uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgc2NvcGUgPSAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwpIHx8XG4gICAgICAgICAgICAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZikgfHxcbiAgICAgICAgICAgIHdpbmRvdztcbnZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHNjb3BlLCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHNjb3BlLCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7XG4gIGlmICh0aW1lb3V0KSB7XG4gICAgdGltZW91dC5jbG9zZSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHNjb3BlLCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gc2V0aW1tZWRpYXRlIGF0dGFjaGVzIGl0c2VsZiB0byB0aGUgZ2xvYmFsIG9iamVjdFxucmVxdWlyZShcInNldGltbWVkaWF0ZVwiKTtcbi8vIE9uIHNvbWUgZXhvdGljIGVudmlyb25tZW50cywgaXQncyBub3QgY2xlYXIgd2hpY2ggb2JqZWN0IGBzZXRpbW1lZGlhdGVgIHdhc1xuLy8gYWJsZSB0byBpbnN0YWxsIG9udG8uICBTZWFyY2ggZWFjaCBwb3NzaWJpbGl0eSBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGVcbi8vIGBzZXRpbW1lZGlhdGVgIGxpYnJhcnkuXG5leHBvcnRzLnNldEltbWVkaWF0ZSA9ICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLnNldEltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLnNldEltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5zZXRJbW1lZGlhdGUpO1xuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9ICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLmNsZWFySW1tZWRpYXRlKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/timers-browserify/main.js\n");

/***/ }),

/***/ "./node_modules/vue/dist/vue.js":
/*!**************************************!*\
  !*** ./node_modules/vue/dist/vue.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, setImmediate) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*!\n * Vue.js v2.6.10\n * (c) 2014-2019 Evan You\n * Released under the MIT License.\n */\n(function (global, factory) {\n  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (undefined);\n})(this, function () {\n  'use strict';\n  /*  */\n\n  var emptyObject = Object.freeze({}); // These helpers produce better VM code in JS engines due to their\n  // explicitness and function inlining.\n\n  function isUndef(v) {\n    return v === undefined || v === null;\n  }\n\n  function isDef(v) {\n    return v !== undefined && v !== null;\n  }\n\n  function isTrue(v) {\n    return v === true;\n  }\n\n  function isFalse(v) {\n    return v === false;\n  }\n  /**\n   * Check if value is primitive.\n   */\n\n\n  function isPrimitive(value) {\n    return typeof value === 'string' || typeof value === 'number' || // $flow-disable-line\n    _typeof(value) === 'symbol' || typeof value === 'boolean';\n  }\n  /**\n   * Quick object check - this is primarily used to tell\n   * Objects from primitive values when we know the value\n   * is a JSON-compliant type.\n   */\n\n\n  function isObject(obj) {\n    return obj !== null && _typeof(obj) === 'object';\n  }\n  /**\n   * Get the raw type string of a value, e.g., [object Object].\n   */\n\n\n  var _toString = Object.prototype.toString;\n\n  function toRawType(value) {\n    return _toString.call(value).slice(8, -1);\n  }\n  /**\n   * Strict object type check. Only returns true\n   * for plain JavaScript objects.\n   */\n\n\n  function isPlainObject(obj) {\n    return _toString.call(obj) === '[object Object]';\n  }\n\n  function isRegExp(v) {\n    return _toString.call(v) === '[object RegExp]';\n  }\n  /**\n   * Check if val is a valid array index.\n   */\n\n\n  function isValidArrayIndex(val) {\n    var n = parseFloat(String(val));\n    return n >= 0 && Math.floor(n) === n && isFinite(val);\n  }\n\n  function isPromise(val) {\n    return isDef(val) && typeof val.then === 'function' && typeof val.catch === 'function';\n  }\n  /**\n   * Convert a value to a string that is actually rendered.\n   */\n\n\n  function toString(val) {\n    return val == null ? '' : Array.isArray(val) || isPlainObject(val) && val.toString === _toString ? JSON.stringify(val, null, 2) : String(val);\n  }\n  /**\n   * Convert an input value to a number for persistence.\n   * If the conversion fails, return original string.\n   */\n\n\n  function toNumber(val) {\n    var n = parseFloat(val);\n    return isNaN(n) ? val : n;\n  }\n  /**\n   * Make a map and return a function for checking if a key\n   * is in that map.\n   */\n\n\n  function makeMap(str, expectsLowerCase) {\n    var map = Object.create(null);\n    var list = str.split(',');\n\n    for (var i = 0; i < list.length; i++) {\n      map[list[i]] = true;\n    }\n\n    return expectsLowerCase ? function (val) {\n      return map[val.toLowerCase()];\n    } : function (val) {\n      return map[val];\n    };\n  }\n  /**\n   * Check if a tag is a built-in tag.\n   */\n\n\n  var isBuiltInTag = makeMap('slot,component', true);\n  /**\n   * Check if an attribute is a reserved attribute.\n   */\n\n  var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');\n  /**\n   * Remove an item from an array.\n   */\n\n  function remove(arr, item) {\n    if (arr.length) {\n      var index = arr.indexOf(item);\n\n      if (index > -1) {\n        return arr.splice(index, 1);\n      }\n    }\n  }\n  /**\n   * Check whether an object has the property.\n   */\n\n\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n  function hasOwn(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  }\n  /**\n   * Create a cached version of a pure function.\n   */\n\n\n  function cached(fn) {\n    var cache = Object.create(null);\n    return function cachedFn(str) {\n      var hit = cache[str];\n      return hit || (cache[str] = fn(str));\n    };\n  }\n  /**\n   * Camelize a hyphen-delimited string.\n   */\n\n\n  var camelizeRE = /-(\\w)/g;\n  var camelize = cached(function (str) {\n    return str.replace(camelizeRE, function (_, c) {\n      return c ? c.toUpperCase() : '';\n    });\n  });\n  /**\n   * Capitalize a string.\n   */\n\n  var capitalize = cached(function (str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n  });\n  /**\n   * Hyphenate a camelCase string.\n   */\n\n  var hyphenateRE = /\\B([A-Z])/g;\n  var hyphenate = cached(function (str) {\n    return str.replace(hyphenateRE, '-$1').toLowerCase();\n  });\n  /**\n   * Simple bind polyfill for environments that do not support it,\n   * e.g., PhantomJS 1.x. Technically, we don't need this anymore\n   * since native bind is now performant enough in most browsers.\n   * But removing it would mean breaking code that was able to run in\n   * PhantomJS 1.x, so this must be kept for backward compatibility.\n   */\n\n  /* istanbul ignore next */\n\n  function polyfillBind(fn, ctx) {\n    function boundFn(a) {\n      var l = arguments.length;\n      return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);\n    }\n\n    boundFn._length = fn.length;\n    return boundFn;\n  }\n\n  function nativeBind(fn, ctx) {\n    return fn.bind(ctx);\n  }\n\n  var bind = Function.prototype.bind ? nativeBind : polyfillBind;\n  /**\n   * Convert an Array-like object to a real Array.\n   */\n\n  function toArray(list, start) {\n    start = start || 0;\n    var i = list.length - start;\n    var ret = new Array(i);\n\n    while (i--) {\n      ret[i] = list[i + start];\n    }\n\n    return ret;\n  }\n  /**\n   * Mix properties into target object.\n   */\n\n\n  function extend(to, _from) {\n    for (var key in _from) {\n      to[key] = _from[key];\n    }\n\n    return to;\n  }\n  /**\n   * Merge an Array of Objects into a single Object.\n   */\n\n\n  function toObject(arr) {\n    var res = {};\n\n    for (var i = 0; i < arr.length; i++) {\n      if (arr[i]) {\n        extend(res, arr[i]);\n      }\n    }\n\n    return res;\n  }\n  /* eslint-disable no-unused-vars */\n\n  /**\n   * Perform no operation.\n   * Stubbing args to make Flow happy without leaving useless transpiled code\n   * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).\n   */\n\n\n  function noop(a, b, c) {}\n  /**\n   * Always return false.\n   */\n\n\n  var no = function no(a, b, c) {\n    return false;\n  };\n  /* eslint-enable no-unused-vars */\n\n  /**\n   * Return the same value.\n   */\n\n\n  var identity = function identity(_) {\n    return _;\n  };\n  /**\n   * Generate a string containing static keys from compiler modules.\n   */\n\n\n  function genStaticKeys(modules) {\n    return modules.reduce(function (keys, m) {\n      return keys.concat(m.staticKeys || []);\n    }, []).join(',');\n  }\n  /**\n   * Check if two values are loosely equal - that is,\n   * if they are plain objects, do they have the same shape?\n   */\n\n\n  function looseEqual(a, b) {\n    if (a === b) {\n      return true;\n    }\n\n    var isObjectA = isObject(a);\n    var isObjectB = isObject(b);\n\n    if (isObjectA && isObjectB) {\n      try {\n        var isArrayA = Array.isArray(a);\n        var isArrayB = Array.isArray(b);\n\n        if (isArrayA && isArrayB) {\n          return a.length === b.length && a.every(function (e, i) {\n            return looseEqual(e, b[i]);\n          });\n        } else if (a instanceof Date && b instanceof Date) {\n          return a.getTime() === b.getTime();\n        } else if (!isArrayA && !isArrayB) {\n          var keysA = Object.keys(a);\n          var keysB = Object.keys(b);\n          return keysA.length === keysB.length && keysA.every(function (key) {\n            return looseEqual(a[key], b[key]);\n          });\n        } else {\n          /* istanbul ignore next */\n          return false;\n        }\n      } catch (e) {\n        /* istanbul ignore next */\n        return false;\n      }\n    } else if (!isObjectA && !isObjectB) {\n      return String(a) === String(b);\n    } else {\n      return false;\n    }\n  }\n  /**\n   * Return the first index at which a loosely equal value can be\n   * found in the array (if value is a plain object, the array must\n   * contain an object of the same shape), or -1 if it is not present.\n   */\n\n\n  function looseIndexOf(arr, val) {\n    for (var i = 0; i < arr.length; i++) {\n      if (looseEqual(arr[i], val)) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * Ensure a function is called only once.\n   */\n\n\n  function once(fn) {\n    var called = false;\n    return function () {\n      if (!called) {\n        called = true;\n        fn.apply(this, arguments);\n      }\n    };\n  }\n\n  var SSR_ATTR = 'data-server-rendered';\n  var ASSET_TYPES = ['component', 'directive', 'filter'];\n  var LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured', 'serverPrefetch'];\n  /*  */\n\n  var config = {\n    /**\n     * Option merge strategies (used in core/util/options)\n     */\n    // $flow-disable-line\n    optionMergeStrategies: Object.create(null),\n\n    /**\n     * Whether to suppress warnings.\n     */\n    silent: false,\n\n    /**\n     * Show production mode tip message on boot?\n     */\n    productionTip: \"development\" !== 'production',\n\n    /**\n     * Whether to enable devtools\n     */\n    devtools: \"development\" !== 'production',\n\n    /**\n     * Whether to record perf\n     */\n    performance: false,\n\n    /**\n     * Error handler for watcher errors\n     */\n    errorHandler: null,\n\n    /**\n     * Warn handler for watcher warns\n     */\n    warnHandler: null,\n\n    /**\n     * Ignore certain custom elements\n     */\n    ignoredElements: [],\n\n    /**\n     * Custom user key aliases for v-on\n     */\n    // $flow-disable-line\n    keyCodes: Object.create(null),\n\n    /**\n     * Check if a tag is reserved so that it cannot be registered as a\n     * component. This is platform-dependent and may be overwritten.\n     */\n    isReservedTag: no,\n\n    /**\n     * Check if an attribute is reserved so that it cannot be used as a component\n     * prop. This is platform-dependent and may be overwritten.\n     */\n    isReservedAttr: no,\n\n    /**\n     * Check if a tag is an unknown element.\n     * Platform-dependent.\n     */\n    isUnknownElement: no,\n\n    /**\n     * Get the namespace of an element\n     */\n    getTagNamespace: noop,\n\n    /**\n     * Parse the real tag name for the specific platform.\n     */\n    parsePlatformTagName: identity,\n\n    /**\n     * Check if an attribute must be bound using property, e.g. value\n     * Platform-dependent.\n     */\n    mustUseProp: no,\n\n    /**\n     * Perform updates asynchronously. Intended to be used by Vue Test Utils\n     * This will significantly reduce performance if set to false.\n     */\n    async: true,\n\n    /**\n     * Exposed for legacy reasons\n     */\n    _lifecycleHooks: LIFECYCLE_HOOKS\n  };\n  /*  */\n\n  /**\n   * unicode letters used for parsing html tags, component names and property paths.\n   * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname\n   * skipping \\u10000-\\uEFFFF due to it freezing up PhantomJS\n   */\n\n  var unicodeRegExp = /a-zA-Z\\u00B7\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u203F-\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD/;\n  /**\n   * Check if a string starts with $ or _\n   */\n\n  function isReserved(str) {\n    var c = (str + '').charCodeAt(0);\n    return c === 0x24 || c === 0x5F;\n  }\n  /**\n   * Define a property.\n   */\n\n\n  function def(obj, key, val, enumerable) {\n    Object.defineProperty(obj, key, {\n      value: val,\n      enumerable: !!enumerable,\n      writable: true,\n      configurable: true\n    });\n  }\n  /**\n   * Parse simple path.\n   */\n\n\n  var bailRE = new RegExp(\"[^\" + unicodeRegExp.source + \".$_\\\\d]\");\n\n  function parsePath(path) {\n    if (bailRE.test(path)) {\n      return;\n    }\n\n    var segments = path.split('.');\n    return function (obj) {\n      for (var i = 0; i < segments.length; i++) {\n        if (!obj) {\n          return;\n        }\n\n        obj = obj[segments[i]];\n      }\n\n      return obj;\n    };\n  }\n  /*  */\n  // can we use __proto__?\n\n\n  var hasProto = '__proto__' in {}; // Browser environment sniffing\n\n  var inBrowser = typeof window !== 'undefined';\n  var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;\n  var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();\n  var UA = inBrowser && window.navigator.userAgent.toLowerCase();\n  var isIE = UA && /msie|trident/.test(UA);\n  var isIE9 = UA && UA.indexOf('msie 9.0') > 0;\n  var isEdge = UA && UA.indexOf('edge/') > 0;\n  var isAndroid = UA && UA.indexOf('android') > 0 || weexPlatform === 'android';\n  var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA) || weexPlatform === 'ios';\n  var isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\n  var isPhantomJS = UA && /phantomjs/.test(UA);\n  var isFF = UA && UA.match(/firefox\\/(\\d+)/); // Firefox has a \"watch\" function on Object.prototype...\n\n  var nativeWatch = {}.watch;\n  var supportsPassive = false;\n\n  if (inBrowser) {\n    try {\n      var opts = {};\n      Object.defineProperty(opts, 'passive', {\n        get: function get() {\n          /* istanbul ignore next */\n          supportsPassive = true;\n        }\n      }); // https://github.com/facebook/flow/issues/285\n\n      window.addEventListener('test-passive', null, opts);\n    } catch (e) {}\n  } // this needs to be lazy-evaled because vue may be required before\n  // vue-server-renderer can set VUE_ENV\n\n\n  var _isServer;\n\n  var isServerRendering = function isServerRendering() {\n    if (_isServer === undefined) {\n      /* istanbul ignore if */\n      if (!inBrowser && !inWeex && typeof global !== 'undefined') {\n        // detect presence of vue-server-renderer and avoid\n        // Webpack shimming the process\n        _isServer = global['process'] && global['process'].env.VUE_ENV === 'server';\n      } else {\n        _isServer = false;\n      }\n    }\n\n    return _isServer;\n  }; // detect devtools\n\n\n  var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n  /* istanbul ignore next */\n\n  function isNative(Ctor) {\n    return typeof Ctor === 'function' && /native code/.test(Ctor.toString());\n  }\n\n  var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\n  var _Set;\n  /* istanbul ignore if */\n  // $flow-disable-line\n\n\n  if (typeof Set !== 'undefined' && isNative(Set)) {\n    // use native Set when available.\n    _Set = Set;\n  } else {\n    // a non-standard Set polyfill that only works with primitive keys.\n    _Set =\n    /*@__PURE__*/\n    function () {\n      function Set() {\n        this.set = Object.create(null);\n      }\n\n      Set.prototype.has = function has(key) {\n        return this.set[key] === true;\n      };\n\n      Set.prototype.add = function add(key) {\n        this.set[key] = true;\n      };\n\n      Set.prototype.clear = function clear() {\n        this.set = Object.create(null);\n      };\n\n      return Set;\n    }();\n  }\n  /*  */\n\n\n  var warn = noop;\n  var tip = noop;\n  var generateComponentTrace = noop; // work around flow check\n\n  var formatComponentName = noop;\n  {\n    var hasConsole = typeof console !== 'undefined';\n    var classifyRE = /(?:^|[-_])(\\w)/g;\n\n    var classify = function classify(str) {\n      return str.replace(classifyRE, function (c) {\n        return c.toUpperCase();\n      }).replace(/[-_]/g, '');\n    };\n\n    warn = function warn(msg, vm) {\n      var trace = vm ? generateComponentTrace(vm) : '';\n\n      if (config.warnHandler) {\n        config.warnHandler.call(null, msg, vm, trace);\n      } else if (hasConsole && !config.silent) {\n        console.error(\"[Vue warn]: \" + msg + trace);\n      }\n    };\n\n    tip = function tip(msg, vm) {\n      if (hasConsole && !config.silent) {\n        console.warn(\"[Vue tip]: \" + msg + (vm ? generateComponentTrace(vm) : ''));\n      }\n    };\n\n    formatComponentName = function formatComponentName(vm, includeFile) {\n      if (vm.$root === vm) {\n        return '<Root>';\n      }\n\n      var options = typeof vm === 'function' && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm;\n      var name = options.name || options._componentTag;\n      var file = options.__file;\n\n      if (!name && file) {\n        var match = file.match(/([^/\\\\]+)\\.vue$/);\n        name = match && match[1];\n      }\n\n      return (name ? \"<\" + classify(name) + \">\" : \"<Anonymous>\") + (file && includeFile !== false ? \" at \" + file : '');\n    };\n\n    var repeat = function repeat(str, n) {\n      var res = '';\n\n      while (n) {\n        if (n % 2 === 1) {\n          res += str;\n        }\n\n        if (n > 1) {\n          str += str;\n        }\n\n        n >>= 1;\n      }\n\n      return res;\n    };\n\n    generateComponentTrace = function generateComponentTrace(vm) {\n      if (vm._isVue && vm.$parent) {\n        var tree = [];\n        var currentRecursiveSequence = 0;\n\n        while (vm) {\n          if (tree.length > 0) {\n            var last = tree[tree.length - 1];\n\n            if (last.constructor === vm.constructor) {\n              currentRecursiveSequence++;\n              vm = vm.$parent;\n              continue;\n            } else if (currentRecursiveSequence > 0) {\n              tree[tree.length - 1] = [last, currentRecursiveSequence];\n              currentRecursiveSequence = 0;\n            }\n          }\n\n          tree.push(vm);\n          vm = vm.$parent;\n        }\n\n        return '\\n\\nfound in\\n\\n' + tree.map(function (vm, i) {\n          return \"\" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + \"... (\" + vm[1] + \" recursive calls)\" : formatComponentName(vm));\n        }).join('\\n');\n      } else {\n        return \"\\n\\n(found in \" + formatComponentName(vm) + \")\";\n      }\n    };\n  }\n  /*  */\n\n  var uid = 0;\n  /**\n   * A dep is an observable that can have multiple\n   * directives subscribing to it.\n   */\n\n  var Dep = function Dep() {\n    this.id = uid++;\n    this.subs = [];\n  };\n\n  Dep.prototype.addSub = function addSub(sub) {\n    this.subs.push(sub);\n  };\n\n  Dep.prototype.removeSub = function removeSub(sub) {\n    remove(this.subs, sub);\n  };\n\n  Dep.prototype.depend = function depend() {\n    if (Dep.target) {\n      Dep.target.addDep(this);\n    }\n  };\n\n  Dep.prototype.notify = function notify() {\n    // stabilize the subscriber list first\n    var subs = this.subs.slice();\n\n    if (!config.async) {\n      // subs aren't sorted in scheduler if not running async\n      // we need to sort them now to make sure they fire in correct\n      // order\n      subs.sort(function (a, b) {\n        return a.id - b.id;\n      });\n    }\n\n    for (var i = 0, l = subs.length; i < l; i++) {\n      subs[i].update();\n    }\n  }; // The current target watcher being evaluated.\n  // This is globally unique because only one watcher\n  // can be evaluated at a time.\n\n\n  Dep.target = null;\n  var targetStack = [];\n\n  function pushTarget(target) {\n    targetStack.push(target);\n    Dep.target = target;\n  }\n\n  function popTarget() {\n    targetStack.pop();\n    Dep.target = targetStack[targetStack.length - 1];\n  }\n  /*  */\n\n\n  var VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {\n    this.tag = tag;\n    this.data = data;\n    this.children = children;\n    this.text = text;\n    this.elm = elm;\n    this.ns = undefined;\n    this.context = context;\n    this.fnContext = undefined;\n    this.fnOptions = undefined;\n    this.fnScopeId = undefined;\n    this.key = data && data.key;\n    this.componentOptions = componentOptions;\n    this.componentInstance = undefined;\n    this.parent = undefined;\n    this.raw = false;\n    this.isStatic = false;\n    this.isRootInsert = true;\n    this.isComment = false;\n    this.isCloned = false;\n    this.isOnce = false;\n    this.asyncFactory = asyncFactory;\n    this.asyncMeta = undefined;\n    this.isAsyncPlaceholder = false;\n  };\n\n  var prototypeAccessors = {\n    child: {\n      configurable: true\n    }\n  }; // DEPRECATED: alias for componentInstance for backwards compat.\n\n  /* istanbul ignore next */\n\n  prototypeAccessors.child.get = function () {\n    return this.componentInstance;\n  };\n\n  Object.defineProperties(VNode.prototype, prototypeAccessors);\n\n  var createEmptyVNode = function createEmptyVNode(text) {\n    if (text === void 0) text = '';\n    var node = new VNode();\n    node.text = text;\n    node.isComment = true;\n    return node;\n  };\n\n  function createTextVNode(val) {\n    return new VNode(undefined, undefined, undefined, String(val));\n  } // optimized shallow clone\n  // used for static nodes and slot nodes because they may be reused across\n  // multiple renders, cloning them avoids errors when DOM manipulations rely\n  // on their elm reference.\n\n\n  function cloneVNode(vnode) {\n    var cloned = new VNode(vnode.tag, vnode.data, // #7975\n    // clone children array to avoid mutating original in case of cloning\n    // a child.\n    vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);\n    cloned.ns = vnode.ns;\n    cloned.isStatic = vnode.isStatic;\n    cloned.key = vnode.key;\n    cloned.isComment = vnode.isComment;\n    cloned.fnContext = vnode.fnContext;\n    cloned.fnOptions = vnode.fnOptions;\n    cloned.fnScopeId = vnode.fnScopeId;\n    cloned.asyncMeta = vnode.asyncMeta;\n    cloned.isCloned = true;\n    return cloned;\n  }\n  /*\n   * not type checking this file because flow doesn't play well with\n   * dynamically accessing methods on Array prototype\n   */\n\n\n  var arrayProto = Array.prototype;\n  var arrayMethods = Object.create(arrayProto);\n  var methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];\n  /**\n   * Intercept mutating methods and emit events\n   */\n\n  methodsToPatch.forEach(function (method) {\n    // cache original method\n    var original = arrayProto[method];\n    def(arrayMethods, method, function mutator() {\n      var args = [],\n          len = arguments.length;\n\n      while (len--) {\n        args[len] = arguments[len];\n      }\n\n      var result = original.apply(this, args);\n      var ob = this.__ob__;\n      var inserted;\n\n      switch (method) {\n        case 'push':\n        case 'unshift':\n          inserted = args;\n          break;\n\n        case 'splice':\n          inserted = args.slice(2);\n          break;\n      }\n\n      if (inserted) {\n        ob.observeArray(inserted);\n      } // notify change\n\n\n      ob.dep.notify();\n      return result;\n    });\n  });\n  /*  */\n\n  var arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n  /**\n   * In some cases we may want to disable observation inside a component's\n   * update computation.\n   */\n\n  var shouldObserve = true;\n\n  function toggleObserving(value) {\n    shouldObserve = value;\n  }\n  /**\n   * Observer class that is attached to each observed\n   * object. Once attached, the observer converts the target\n   * object's property keys into getter/setters that\n   * collect dependencies and dispatch updates.\n   */\n\n\n  var Observer = function Observer(value) {\n    this.value = value;\n    this.dep = new Dep();\n    this.vmCount = 0;\n    def(value, '__ob__', this);\n\n    if (Array.isArray(value)) {\n      if (hasProto) {\n        protoAugment(value, arrayMethods);\n      } else {\n        copyAugment(value, arrayMethods, arrayKeys);\n      }\n\n      this.observeArray(value);\n    } else {\n      this.walk(value);\n    }\n  };\n  /**\n   * Walk through all properties and convert them into\n   * getter/setters. This method should only be called when\n   * value type is Object.\n   */\n\n\n  Observer.prototype.walk = function walk(obj) {\n    var keys = Object.keys(obj);\n\n    for (var i = 0; i < keys.length; i++) {\n      defineReactive$$1(obj, keys[i]);\n    }\n  };\n  /**\n   * Observe a list of Array items.\n   */\n\n\n  Observer.prototype.observeArray = function observeArray(items) {\n    for (var i = 0, l = items.length; i < l; i++) {\n      observe(items[i]);\n    }\n  }; // helpers\n\n  /**\n   * Augment a target Object or Array by intercepting\n   * the prototype chain using __proto__\n   */\n\n\n  function protoAugment(target, src) {\n    /* eslint-disable no-proto */\n    target.__proto__ = src;\n    /* eslint-enable no-proto */\n  }\n  /**\n   * Augment a target Object or Array by defining\n   * hidden properties.\n   */\n\n  /* istanbul ignore next */\n\n\n  function copyAugment(target, src, keys) {\n    for (var i = 0, l = keys.length; i < l; i++) {\n      var key = keys[i];\n      def(target, key, src[key]);\n    }\n  }\n  /**\n   * Attempt to create an observer instance for a value,\n   * returns the new observer if successfully observed,\n   * or the existing observer if the value already has one.\n   */\n\n\n  function observe(value, asRootData) {\n    if (!isObject(value) || value instanceof VNode) {\n      return;\n    }\n\n    var ob;\n\n    if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n      ob = value.__ob__;\n    } else if (shouldObserve && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {\n      ob = new Observer(value);\n    }\n\n    if (asRootData && ob) {\n      ob.vmCount++;\n    }\n\n    return ob;\n  }\n  /**\n   * Define a reactive property on an Object.\n   */\n\n\n  function defineReactive$$1(obj, key, val, customSetter, shallow) {\n    var dep = new Dep();\n    var property = Object.getOwnPropertyDescriptor(obj, key);\n\n    if (property && property.configurable === false) {\n      return;\n    } // cater for pre-defined getter/setters\n\n\n    var getter = property && property.get;\n    var setter = property && property.set;\n\n    if ((!getter || setter) && arguments.length === 2) {\n      val = obj[key];\n    }\n\n    var childOb = !shallow && observe(val);\n    Object.defineProperty(obj, key, {\n      enumerable: true,\n      configurable: true,\n      get: function reactiveGetter() {\n        var value = getter ? getter.call(obj) : val;\n\n        if (Dep.target) {\n          dep.depend();\n\n          if (childOb) {\n            childOb.dep.depend();\n\n            if (Array.isArray(value)) {\n              dependArray(value);\n            }\n          }\n        }\n\n        return value;\n      },\n      set: function reactiveSetter(newVal) {\n        var value = getter ? getter.call(obj) : val;\n        /* eslint-disable no-self-compare */\n\n        if (newVal === value || newVal !== newVal && value !== value) {\n          return;\n        }\n        /* eslint-enable no-self-compare */\n\n\n        if (customSetter) {\n          customSetter();\n        } // #7981: for accessor properties without setter\n\n\n        if (getter && !setter) {\n          return;\n        }\n\n        if (setter) {\n          setter.call(obj, newVal);\n        } else {\n          val = newVal;\n        }\n\n        childOb = !shallow && observe(newVal);\n        dep.notify();\n      }\n    });\n  }\n  /**\n   * Set a property on an object. Adds the new property and\n   * triggers change notification if the property doesn't\n   * already exist.\n   */\n\n\n  function set(target, key, val) {\n    if (isUndef(target) || isPrimitive(target)) {\n      warn(\"Cannot set reactive property on undefined, null, or primitive value: \" + target);\n    }\n\n    if (Array.isArray(target) && isValidArrayIndex(key)) {\n      target.length = Math.max(target.length, key);\n      target.splice(key, 1, val);\n      return val;\n    }\n\n    if (key in target && !(key in Object.prototype)) {\n      target[key] = val;\n      return val;\n    }\n\n    var ob = target.__ob__;\n\n    if (target._isVue || ob && ob.vmCount) {\n      warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');\n      return val;\n    }\n\n    if (!ob) {\n      target[key] = val;\n      return val;\n    }\n\n    defineReactive$$1(ob.value, key, val);\n    ob.dep.notify();\n    return val;\n  }\n  /**\n   * Delete a property and trigger change if necessary.\n   */\n\n\n  function del(target, key) {\n    if (isUndef(target) || isPrimitive(target)) {\n      warn(\"Cannot delete reactive property on undefined, null, or primitive value: \" + target);\n    }\n\n    if (Array.isArray(target) && isValidArrayIndex(key)) {\n      target.splice(key, 1);\n      return;\n    }\n\n    var ob = target.__ob__;\n\n    if (target._isVue || ob && ob.vmCount) {\n      warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');\n      return;\n    }\n\n    if (!hasOwn(target, key)) {\n      return;\n    }\n\n    delete target[key];\n\n    if (!ob) {\n      return;\n    }\n\n    ob.dep.notify();\n  }\n  /**\n   * Collect dependencies on array elements when the array is touched, since\n   * we cannot intercept array element access like property getters.\n   */\n\n\n  function dependArray(value) {\n    for (var e = void 0, i = 0, l = value.length; i < l; i++) {\n      e = value[i];\n      e && e.__ob__ && e.__ob__.dep.depend();\n\n      if (Array.isArray(e)) {\n        dependArray(e);\n      }\n    }\n  }\n  /*  */\n\n  /**\n   * Option overwriting strategies are functions that handle\n   * how to merge a parent option value and a child option\n   * value into the final value.\n   */\n\n\n  var strats = config.optionMergeStrategies;\n  /**\n   * Options with restrictions\n   */\n\n  {\n    strats.el = strats.propsData = function (parent, child, vm, key) {\n      if (!vm) {\n        warn(\"option \\\"\" + key + \"\\\" can only be used during instance \" + 'creation with the `new` keyword.');\n      }\n\n      return defaultStrat(parent, child);\n    };\n  }\n  /**\n   * Helper that recursively merges two data objects together.\n   */\n\n  function mergeData(to, from) {\n    if (!from) {\n      return to;\n    }\n\n    var key, toVal, fromVal;\n    var keys = hasSymbol ? Reflect.ownKeys(from) : Object.keys(from);\n\n    for (var i = 0; i < keys.length; i++) {\n      key = keys[i]; // in case the object is already observed...\n\n      if (key === '__ob__') {\n        continue;\n      }\n\n      toVal = to[key];\n      fromVal = from[key];\n\n      if (!hasOwn(to, key)) {\n        set(to, key, fromVal);\n      } else if (toVal !== fromVal && isPlainObject(toVal) && isPlainObject(fromVal)) {\n        mergeData(toVal, fromVal);\n      }\n    }\n\n    return to;\n  }\n  /**\n   * Data\n   */\n\n\n  function mergeDataOrFn(parentVal, childVal, vm) {\n    if (!vm) {\n      // in a Vue.extend merge, both should be functions\n      if (!childVal) {\n        return parentVal;\n      }\n\n      if (!parentVal) {\n        return childVal;\n      } // when parentVal & childVal are both present,\n      // we need to return a function that returns the\n      // merged result of both functions... no need to\n      // check if parentVal is a function here because\n      // it has to be a function to pass previous merges.\n\n\n      return function mergedDataFn() {\n        return mergeData(typeof childVal === 'function' ? childVal.call(this, this) : childVal, typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal);\n      };\n    } else {\n      return function mergedInstanceDataFn() {\n        // instance merge\n        var instanceData = typeof childVal === 'function' ? childVal.call(vm, vm) : childVal;\n        var defaultData = typeof parentVal === 'function' ? parentVal.call(vm, vm) : parentVal;\n\n        if (instanceData) {\n          return mergeData(instanceData, defaultData);\n        } else {\n          return defaultData;\n        }\n      };\n    }\n  }\n\n  strats.data = function (parentVal, childVal, vm) {\n    if (!vm) {\n      if (childVal && typeof childVal !== 'function') {\n        warn('The \"data\" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);\n        return parentVal;\n      }\n\n      return mergeDataOrFn(parentVal, childVal);\n    }\n\n    return mergeDataOrFn(parentVal, childVal, vm);\n  };\n  /**\n   * Hooks and props are merged as arrays.\n   */\n\n\n  function mergeHook(parentVal, childVal) {\n    var res = childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;\n    return res ? dedupeHooks(res) : res;\n  }\n\n  function dedupeHooks(hooks) {\n    var res = [];\n\n    for (var i = 0; i < hooks.length; i++) {\n      if (res.indexOf(hooks[i]) === -1) {\n        res.push(hooks[i]);\n      }\n    }\n\n    return res;\n  }\n\n  LIFECYCLE_HOOKS.forEach(function (hook) {\n    strats[hook] = mergeHook;\n  });\n  /**\n   * Assets\n   *\n   * When a vm is present (instance creation), we need to do\n   * a three-way merge between constructor options, instance\n   * options and parent options.\n   */\n\n  function mergeAssets(parentVal, childVal, vm, key) {\n    var res = Object.create(parentVal || null);\n\n    if (childVal) {\n      assertObjectType(key, childVal, vm);\n      return extend(res, childVal);\n    } else {\n      return res;\n    }\n  }\n\n  ASSET_TYPES.forEach(function (type) {\n    strats[type + 's'] = mergeAssets;\n  });\n  /**\n   * Watchers.\n   *\n   * Watchers hashes should not overwrite one\n   * another, so we merge them as arrays.\n   */\n\n  strats.watch = function (parentVal, childVal, vm, key) {\n    // work around Firefox's Object.prototype.watch...\n    if (parentVal === nativeWatch) {\n      parentVal = undefined;\n    }\n\n    if (childVal === nativeWatch) {\n      childVal = undefined;\n    }\n    /* istanbul ignore if */\n\n\n    if (!childVal) {\n      return Object.create(parentVal || null);\n    }\n\n    {\n      assertObjectType(key, childVal, vm);\n    }\n\n    if (!parentVal) {\n      return childVal;\n    }\n\n    var ret = {};\n    extend(ret, parentVal);\n\n    for (var key$1 in childVal) {\n      var parent = ret[key$1];\n      var child = childVal[key$1];\n\n      if (parent && !Array.isArray(parent)) {\n        parent = [parent];\n      }\n\n      ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];\n    }\n\n    return ret;\n  };\n  /**\n   * Other object hashes.\n   */\n\n\n  strats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal, vm, key) {\n    if (childVal && \"development\" !== 'production') {\n      assertObjectType(key, childVal, vm);\n    }\n\n    if (!parentVal) {\n      return childVal;\n    }\n\n    var ret = Object.create(null);\n    extend(ret, parentVal);\n\n    if (childVal) {\n      extend(ret, childVal);\n    }\n\n    return ret;\n  };\n\n  strats.provide = mergeDataOrFn;\n  /**\n   * Default strategy.\n   */\n\n  var defaultStrat = function defaultStrat(parentVal, childVal) {\n    return childVal === undefined ? parentVal : childVal;\n  };\n  /**\n   * Validate component names\n   */\n\n\n  function checkComponents(options) {\n    for (var key in options.components) {\n      validateComponentName(key);\n    }\n  }\n\n  function validateComponentName(name) {\n    if (!new RegExp(\"^[a-zA-Z][\\\\-\\\\.0-9_\" + unicodeRegExp.source + \"]*$\").test(name)) {\n      warn('Invalid component name: \"' + name + '\". Component names ' + 'should conform to valid custom element name in html5 specification.');\n    }\n\n    if (isBuiltInTag(name) || config.isReservedTag(name)) {\n      warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + name);\n    }\n  }\n  /**\n   * Ensure all props option syntax are normalized into the\n   * Object-based format.\n   */\n\n\n  function normalizeProps(options, vm) {\n    var props = options.props;\n\n    if (!props) {\n      return;\n    }\n\n    var res = {};\n    var i, val, name;\n\n    if (Array.isArray(props)) {\n      i = props.length;\n\n      while (i--) {\n        val = props[i];\n\n        if (typeof val === 'string') {\n          name = camelize(val);\n          res[name] = {\n            type: null\n          };\n        } else {\n          warn('props must be strings when using array syntax.');\n        }\n      }\n    } else if (isPlainObject(props)) {\n      for (var key in props) {\n        val = props[key];\n        name = camelize(key);\n        res[name] = isPlainObject(val) ? val : {\n          type: val\n        };\n      }\n    } else {\n      warn(\"Invalid value for option \\\"props\\\": expected an Array or an Object, \" + \"but got \" + toRawType(props) + \".\", vm);\n    }\n\n    options.props = res;\n  }\n  /**\n   * Normalize all injections into Object-based format\n   */\n\n\n  function normalizeInject(options, vm) {\n    var inject = options.inject;\n\n    if (!inject) {\n      return;\n    }\n\n    var normalized = options.inject = {};\n\n    if (Array.isArray(inject)) {\n      for (var i = 0; i < inject.length; i++) {\n        normalized[inject[i]] = {\n          from: inject[i]\n        };\n      }\n    } else if (isPlainObject(inject)) {\n      for (var key in inject) {\n        var val = inject[key];\n        normalized[key] = isPlainObject(val) ? extend({\n          from: key\n        }, val) : {\n          from: val\n        };\n      }\n    } else {\n      warn(\"Invalid value for option \\\"inject\\\": expected an Array or an Object, \" + \"but got \" + toRawType(inject) + \".\", vm);\n    }\n  }\n  /**\n   * Normalize raw function directives into object format.\n   */\n\n\n  function normalizeDirectives(options) {\n    var dirs = options.directives;\n\n    if (dirs) {\n      for (var key in dirs) {\n        var def$$1 = dirs[key];\n\n        if (typeof def$$1 === 'function') {\n          dirs[key] = {\n            bind: def$$1,\n            update: def$$1\n          };\n        }\n      }\n    }\n  }\n\n  function assertObjectType(name, value, vm) {\n    if (!isPlainObject(value)) {\n      warn(\"Invalid value for option \\\"\" + name + \"\\\": expected an Object, \" + \"but got \" + toRawType(value) + \".\", vm);\n    }\n  }\n  /**\n   * Merge two option objects into a new one.\n   * Core utility used in both instantiation and inheritance.\n   */\n\n\n  function mergeOptions(parent, child, vm) {\n    {\n      checkComponents(child);\n    }\n\n    if (typeof child === 'function') {\n      child = child.options;\n    }\n\n    normalizeProps(child, vm);\n    normalizeInject(child, vm);\n    normalizeDirectives(child); // Apply extends and mixins on the child options,\n    // but only if it is a raw options object that isn't\n    // the result of another mergeOptions call.\n    // Only merged options has the _base property.\n\n    if (!child._base) {\n      if (child.extends) {\n        parent = mergeOptions(parent, child.extends, vm);\n      }\n\n      if (child.mixins) {\n        for (var i = 0, l = child.mixins.length; i < l; i++) {\n          parent = mergeOptions(parent, child.mixins[i], vm);\n        }\n      }\n    }\n\n    var options = {};\n    var key;\n\n    for (key in parent) {\n      mergeField(key);\n    }\n\n    for (key in child) {\n      if (!hasOwn(parent, key)) {\n        mergeField(key);\n      }\n    }\n\n    function mergeField(key) {\n      var strat = strats[key] || defaultStrat;\n      options[key] = strat(parent[key], child[key], vm, key);\n    }\n\n    return options;\n  }\n  /**\n   * Resolve an asset.\n   * This function is used because child instances need access\n   * to assets defined in its ancestor chain.\n   */\n\n\n  function resolveAsset(options, type, id, warnMissing) {\n    /* istanbul ignore if */\n    if (typeof id !== 'string') {\n      return;\n    }\n\n    var assets = options[type]; // check local registration variations first\n\n    if (hasOwn(assets, id)) {\n      return assets[id];\n    }\n\n    var camelizedId = camelize(id);\n\n    if (hasOwn(assets, camelizedId)) {\n      return assets[camelizedId];\n    }\n\n    var PascalCaseId = capitalize(camelizedId);\n\n    if (hasOwn(assets, PascalCaseId)) {\n      return assets[PascalCaseId];\n    } // fallback to prototype chain\n\n\n    var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n\n    if (warnMissing && !res) {\n      warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);\n    }\n\n    return res;\n  }\n  /*  */\n\n\n  function validateProp(key, propOptions, propsData, vm) {\n    var prop = propOptions[key];\n    var absent = !hasOwn(propsData, key);\n    var value = propsData[key]; // boolean casting\n\n    var booleanIndex = getTypeIndex(Boolean, prop.type);\n\n    if (booleanIndex > -1) {\n      if (absent && !hasOwn(prop, 'default')) {\n        value = false;\n      } else if (value === '' || value === hyphenate(key)) {\n        // only cast empty string / same name to boolean if\n        // boolean has higher priority\n        var stringIndex = getTypeIndex(String, prop.type);\n\n        if (stringIndex < 0 || booleanIndex < stringIndex) {\n          value = true;\n        }\n      }\n    } // check default value\n\n\n    if (value === undefined) {\n      value = getPropDefaultValue(vm, prop, key); // since the default value is a fresh copy,\n      // make sure to observe it.\n\n      var prevShouldObserve = shouldObserve;\n      toggleObserving(true);\n      observe(value);\n      toggleObserving(prevShouldObserve);\n    }\n\n    {\n      assertProp(prop, key, value, vm, absent);\n    }\n    return value;\n  }\n  /**\n   * Get the default value of a prop.\n   */\n\n\n  function getPropDefaultValue(vm, prop, key) {\n    // no default, return undefined\n    if (!hasOwn(prop, 'default')) {\n      return undefined;\n    }\n\n    var def = prop.default; // warn against non-factory defaults for Object & Array\n\n    if (isObject(def)) {\n      warn('Invalid default value for prop \"' + key + '\": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);\n    } // the raw prop value was also undefined from previous render,\n    // return previous default value to avoid unnecessary watcher trigger\n\n\n    if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {\n      return vm._props[key];\n    } // call factory function for non-Function types\n    // a value is Function if its prototype is function even across different execution context\n\n\n    return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;\n  }\n  /**\n   * Assert whether a prop is valid.\n   */\n\n\n  function assertProp(prop, name, value, vm, absent) {\n    if (prop.required && absent) {\n      warn('Missing required prop: \"' + name + '\"', vm);\n      return;\n    }\n\n    if (value == null && !prop.required) {\n      return;\n    }\n\n    var type = prop.type;\n    var valid = !type || type === true;\n    var expectedTypes = [];\n\n    if (type) {\n      if (!Array.isArray(type)) {\n        type = [type];\n      }\n\n      for (var i = 0; i < type.length && !valid; i++) {\n        var assertedType = assertType(value, type[i]);\n        expectedTypes.push(assertedType.expectedType || '');\n        valid = assertedType.valid;\n      }\n    }\n\n    if (!valid) {\n      warn(getInvalidTypeMessage(name, value, expectedTypes), vm);\n      return;\n    }\n\n    var validator = prop.validator;\n\n    if (validator) {\n      if (!validator(value)) {\n        warn('Invalid prop: custom validator check failed for prop \"' + name + '\".', vm);\n      }\n    }\n  }\n\n  var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\n\n  function assertType(value, type) {\n    var valid;\n    var expectedType = getType(type);\n\n    if (simpleCheckRE.test(expectedType)) {\n      var t = _typeof(value);\n\n      valid = t === expectedType.toLowerCase(); // for primitive wrapper objects\n\n      if (!valid && t === 'object') {\n        valid = value instanceof type;\n      }\n    } else if (expectedType === 'Object') {\n      valid = isPlainObject(value);\n    } else if (expectedType === 'Array') {\n      valid = Array.isArray(value);\n    } else {\n      valid = value instanceof type;\n    }\n\n    return {\n      valid: valid,\n      expectedType: expectedType\n    };\n  }\n  /**\n   * Use function string name to check built-in types,\n   * because a simple equality check will fail when running\n   * across different vms / iframes.\n   */\n\n\n  function getType(fn) {\n    var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n    return match ? match[1] : '';\n  }\n\n  function isSameType(a, b) {\n    return getType(a) === getType(b);\n  }\n\n  function getTypeIndex(type, expectedTypes) {\n    if (!Array.isArray(expectedTypes)) {\n      return isSameType(expectedTypes, type) ? 0 : -1;\n    }\n\n    for (var i = 0, len = expectedTypes.length; i < len; i++) {\n      if (isSameType(expectedTypes[i], type)) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  function getInvalidTypeMessage(name, value, expectedTypes) {\n    var message = \"Invalid prop: type check failed for prop \\\"\" + name + \"\\\".\" + \" Expected \" + expectedTypes.map(capitalize).join(', ');\n    var expectedType = expectedTypes[0];\n    var receivedType = toRawType(value);\n    var expectedValue = styleValue(value, expectedType);\n    var receivedValue = styleValue(value, receivedType); // check if we need to specify expected value\n\n    if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {\n      message += \" with value \" + expectedValue;\n    }\n\n    message += \", got \" + receivedType + \" \"; // check if we need to specify received value\n\n    if (isExplicable(receivedType)) {\n      message += \"with value \" + receivedValue + \".\";\n    }\n\n    return message;\n  }\n\n  function styleValue(value, type) {\n    if (type === 'String') {\n      return \"\\\"\" + value + \"\\\"\";\n    } else if (type === 'Number') {\n      return \"\" + Number(value);\n    } else {\n      return \"\" + value;\n    }\n  }\n\n  function isExplicable(value) {\n    var explicitTypes = ['string', 'number', 'boolean'];\n    return explicitTypes.some(function (elem) {\n      return value.toLowerCase() === elem;\n    });\n  }\n\n  function isBoolean() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    return args.some(function (elem) {\n      return elem.toLowerCase() === 'boolean';\n    });\n  }\n  /*  */\n\n\n  function handleError(err, vm, info) {\n    // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.\n    // See: https://github.com/vuejs/vuex/issues/1505\n    pushTarget();\n\n    try {\n      if (vm) {\n        var cur = vm;\n\n        while (cur = cur.$parent) {\n          var hooks = cur.$options.errorCaptured;\n\n          if (hooks) {\n            for (var i = 0; i < hooks.length; i++) {\n              try {\n                var capture = hooks[i].call(cur, err, vm, info) === false;\n\n                if (capture) {\n                  return;\n                }\n              } catch (e) {\n                globalHandleError(e, cur, 'errorCaptured hook');\n              }\n            }\n          }\n        }\n      }\n\n      globalHandleError(err, vm, info);\n    } finally {\n      popTarget();\n    }\n  }\n\n  function invokeWithErrorHandling(handler, context, args, vm, info) {\n    var res;\n\n    try {\n      res = args ? handler.apply(context, args) : handler.call(context);\n\n      if (res && !res._isVue && isPromise(res) && !res._handled) {\n        res.catch(function (e) {\n          return handleError(e, vm, info + \" (Promise/async)\");\n        }); // issue #9511\n        // avoid catch triggering multiple times when nested calls\n\n        res._handled = true;\n      }\n    } catch (e) {\n      handleError(e, vm, info);\n    }\n\n    return res;\n  }\n\n  function globalHandleError(err, vm, info) {\n    if (config.errorHandler) {\n      try {\n        return config.errorHandler.call(null, err, vm, info);\n      } catch (e) {\n        // if the user intentionally throws the original error in the handler,\n        // do not log it twice\n        if (e !== err) {\n          logError(e, null, 'config.errorHandler');\n        }\n      }\n    }\n\n    logError(err, vm, info);\n  }\n\n  function logError(err, vm, info) {\n    {\n      warn(\"Error in \" + info + \": \\\"\" + err.toString() + \"\\\"\", vm);\n    }\n    /* istanbul ignore else */\n\n    if ((inBrowser || inWeex) && typeof console !== 'undefined') {\n      console.error(err);\n    } else {\n      throw err;\n    }\n  }\n  /*  */\n\n\n  var isUsingMicroTask = false;\n  var callbacks = [];\n  var pending = false;\n\n  function flushCallbacks() {\n    pending = false;\n    var copies = callbacks.slice(0);\n    callbacks.length = 0;\n\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]();\n    }\n  } // Here we have async deferring wrappers using microtasks.\n  // In 2.5 we used (macro) tasks (in combination with microtasks).\n  // However, it has subtle problems when state is changed right before repaint\n  // (e.g. #6813, out-in transitions).\n  // Also, using (macro) tasks in event handler would cause some weird behaviors\n  // that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).\n  // So we now use microtasks everywhere, again.\n  // A major drawback of this tradeoff is that there are some scenarios\n  // where microtasks have too high a priority and fire in between supposedly\n  // sequential events (e.g. #4521, #6690, which have workarounds)\n  // or even between bubbling of the same event (#6566).\n\n\n  var timerFunc; // The nextTick behavior leverages the microtask queue, which can be accessed\n  // via either native Promise.then or MutationObserver.\n  // MutationObserver has wider support, however it is seriously bugged in\n  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n  // completely stops working after triggering a few times... so, if native\n  // Promise is available, we will use it:\n\n  /* istanbul ignore next, $flow-disable-line */\n\n  if (typeof Promise !== 'undefined' && isNative(Promise)) {\n    var p = Promise.resolve();\n\n    timerFunc = function timerFunc() {\n      p.then(flushCallbacks); // In problematic UIWebViews, Promise.then doesn't completely break, but\n      // it can get stuck in a weird state where callbacks are pushed into the\n      // microtask queue but the queue isn't being flushed, until the browser\n      // needs to do some other work, e.g. handle a timer. Therefore we can\n      // \"force\" the microtask queue to be flushed by adding an empty timer.\n\n      if (isIOS) {\n        setTimeout(noop);\n      }\n    };\n\n    isUsingMicroTask = true;\n  } else if (!isIE && typeof MutationObserver !== 'undefined' && (isNative(MutationObserver) || // PhantomJS and iOS 7.x\n  MutationObserver.toString() === '[object MutationObserverConstructor]')) {\n    // Use MutationObserver where native Promise is not available,\n    // e.g. PhantomJS, iOS7, Android 4.4\n    // (#6466 MutationObserver is unreliable in IE11)\n    var counter = 1;\n    var observer = new MutationObserver(flushCallbacks);\n    var textNode = document.createTextNode(String(counter));\n    observer.observe(textNode, {\n      characterData: true\n    });\n\n    timerFunc = function timerFunc() {\n      counter = (counter + 1) % 2;\n      textNode.data = String(counter);\n    };\n\n    isUsingMicroTask = true;\n  } else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n    // Fallback to setImmediate.\n    // Techinically it leverages the (macro) task queue,\n    // but it is still a better choice than setTimeout.\n    timerFunc = function timerFunc() {\n      setImmediate(flushCallbacks);\n    };\n  } else {\n    // Fallback to setTimeout.\n    timerFunc = function timerFunc() {\n      setTimeout(flushCallbacks, 0);\n    };\n  }\n\n  function nextTick(cb, ctx) {\n    var _resolve;\n\n    callbacks.push(function () {\n      if (cb) {\n        try {\n          cb.call(ctx);\n        } catch (e) {\n          handleError(e, ctx, 'nextTick');\n        }\n      } else if (_resolve) {\n        _resolve(ctx);\n      }\n    });\n\n    if (!pending) {\n      pending = true;\n      timerFunc();\n    } // $flow-disable-line\n\n\n    if (!cb && typeof Promise !== 'undefined') {\n      return new Promise(function (resolve) {\n        _resolve = resolve;\n      });\n    }\n  }\n  /*  */\n\n\n  var mark;\n  var measure;\n  {\n    var perf = inBrowser && window.performance;\n    /* istanbul ignore if */\n\n    if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {\n      mark = function mark(tag) {\n        return perf.mark(tag);\n      };\n\n      measure = function measure(name, startTag, endTag) {\n        perf.measure(name, startTag, endTag);\n        perf.clearMarks(startTag);\n        perf.clearMarks(endTag); // perf.clearMeasures(name)\n      };\n    }\n  }\n  /* not type checking this file because flow doesn't play well with Proxy */\n\n  var initProxy;\n  {\n    var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify\n    );\n\n    var warnNonPresent = function warnNonPresent(target, key) {\n      warn(\"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" + 'referenced during render. Make sure that this property is reactive, ' + 'either in the data option, or for class-based components, by ' + 'initializing the property. ' + 'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);\n    };\n\n    var warnReservedPrefix = function warnReservedPrefix(target, key) {\n      warn(\"Property \\\"\" + key + \"\\\" must be accessed with \\\"$data.\" + key + \"\\\" because \" + 'properties starting with \"$\" or \"_\" are not proxied in the Vue instance to ' + 'prevent conflicts with Vue internals' + 'See: https://vuejs.org/v2/api/#data', target);\n    };\n\n    var hasProxy = typeof Proxy !== 'undefined' && isNative(Proxy);\n\n    if (hasProxy) {\n      var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');\n      config.keyCodes = new Proxy(config.keyCodes, {\n        set: function set(target, key, value) {\n          if (isBuiltInModifier(key)) {\n            warn(\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key);\n            return false;\n          } else {\n            target[key] = value;\n            return true;\n          }\n        }\n      });\n    }\n\n    var hasHandler = {\n      has: function has(target, key) {\n        var has = key in target;\n        var isAllowed = allowedGlobals(key) || typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data);\n\n        if (!has && !isAllowed) {\n          if (key in target.$data) {\n            warnReservedPrefix(target, key);\n          } else {\n            warnNonPresent(target, key);\n          }\n        }\n\n        return has || !isAllowed;\n      }\n    };\n    var getHandler = {\n      get: function get(target, key) {\n        if (typeof key === 'string' && !(key in target)) {\n          if (key in target.$data) {\n            warnReservedPrefix(target, key);\n          } else {\n            warnNonPresent(target, key);\n          }\n        }\n\n        return target[key];\n      }\n    };\n\n    initProxy = function initProxy(vm) {\n      if (hasProxy) {\n        // determine which proxy handler to use\n        var options = vm.$options;\n        var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;\n        vm._renderProxy = new Proxy(vm, handlers);\n      } else {\n        vm._renderProxy = vm;\n      }\n    };\n  }\n  /*  */\n\n  var seenObjects = new _Set();\n  /**\n   * Recursively traverse an object to evoke all converted\n   * getters, so that every nested property inside the object\n   * is collected as a \"deep\" dependency.\n   */\n\n  function traverse(val) {\n    _traverse(val, seenObjects);\n\n    seenObjects.clear();\n  }\n\n  function _traverse(val, seen) {\n    var i, keys;\n    var isA = Array.isArray(val);\n\n    if (!isA && !isObject(val) || Object.isFrozen(val) || val instanceof VNode) {\n      return;\n    }\n\n    if (val.__ob__) {\n      var depId = val.__ob__.dep.id;\n\n      if (seen.has(depId)) {\n        return;\n      }\n\n      seen.add(depId);\n    }\n\n    if (isA) {\n      i = val.length;\n\n      while (i--) {\n        _traverse(val[i], seen);\n      }\n    } else {\n      keys = Object.keys(val);\n      i = keys.length;\n\n      while (i--) {\n        _traverse(val[keys[i]], seen);\n      }\n    }\n  }\n  /*  */\n\n\n  var normalizeEvent = cached(function (name) {\n    var passive = name.charAt(0) === '&';\n    name = passive ? name.slice(1) : name;\n    var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n\n    name = once$$1 ? name.slice(1) : name;\n    var capture = name.charAt(0) === '!';\n    name = capture ? name.slice(1) : name;\n    return {\n      name: name,\n      once: once$$1,\n      capture: capture,\n      passive: passive\n    };\n  });\n\n  function createFnInvoker(fns, vm) {\n    function invoker() {\n      var arguments$1 = arguments;\n      var fns = invoker.fns;\n\n      if (Array.isArray(fns)) {\n        var cloned = fns.slice();\n\n        for (var i = 0; i < cloned.length; i++) {\n          invokeWithErrorHandling(cloned[i], null, arguments$1, vm, \"v-on handler\");\n        }\n      } else {\n        // return handler return value for single handlers\n        return invokeWithErrorHandling(fns, null, arguments, vm, \"v-on handler\");\n      }\n    }\n\n    invoker.fns = fns;\n    return invoker;\n  }\n\n  function updateListeners(on, oldOn, add, remove$$1, createOnceHandler, vm) {\n    var name, def$$1, cur, old, event;\n\n    for (name in on) {\n      def$$1 = cur = on[name];\n      old = oldOn[name];\n      event = normalizeEvent(name);\n\n      if (isUndef(cur)) {\n        warn(\"Invalid handler for event \\\"\" + event.name + \"\\\": got \" + String(cur), vm);\n      } else if (isUndef(old)) {\n        if (isUndef(cur.fns)) {\n          cur = on[name] = createFnInvoker(cur, vm);\n        }\n\n        if (isTrue(event.once)) {\n          cur = on[name] = createOnceHandler(event.name, cur, event.capture);\n        }\n\n        add(event.name, cur, event.capture, event.passive, event.params);\n      } else if (cur !== old) {\n        old.fns = cur;\n        on[name] = old;\n      }\n    }\n\n    for (name in oldOn) {\n      if (isUndef(on[name])) {\n        event = normalizeEvent(name);\n        remove$$1(event.name, oldOn[name], event.capture);\n      }\n    }\n  }\n  /*  */\n\n\n  function mergeVNodeHook(def, hookKey, hook) {\n    if (def instanceof VNode) {\n      def = def.data.hook || (def.data.hook = {});\n    }\n\n    var invoker;\n    var oldHook = def[hookKey];\n\n    function wrappedHook() {\n      hook.apply(this, arguments); // important: remove merged hook to ensure it's called only once\n      // and prevent memory leak\n\n      remove(invoker.fns, wrappedHook);\n    }\n\n    if (isUndef(oldHook)) {\n      // no existing hook\n      invoker = createFnInvoker([wrappedHook]);\n    } else {\n      /* istanbul ignore if */\n      if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n        // already a merged invoker\n        invoker = oldHook;\n        invoker.fns.push(wrappedHook);\n      } else {\n        // existing plain hook\n        invoker = createFnInvoker([oldHook, wrappedHook]);\n      }\n    }\n\n    invoker.merged = true;\n    def[hookKey] = invoker;\n  }\n  /*  */\n\n\n  function extractPropsFromVNodeData(data, Ctor, tag) {\n    // we are only extracting raw values here.\n    // validation and default values are handled in the child\n    // component itself.\n    var propOptions = Ctor.options.props;\n\n    if (isUndef(propOptions)) {\n      return;\n    }\n\n    var res = {};\n    var attrs = data.attrs;\n    var props = data.props;\n\n    if (isDef(attrs) || isDef(props)) {\n      for (var key in propOptions) {\n        var altKey = hyphenate(key);\n        {\n          var keyInLowerCase = key.toLowerCase();\n\n          if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {\n            tip(\"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" + formatComponentName(tag || Ctor) + \", but the declared prop name is\" + \" \\\"\" + key + \"\\\". \" + \"Note that HTML attributes are case-insensitive and camelCased \" + \"props need to use their kebab-case equivalents when using in-DOM \" + \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\");\n          }\n        }\n        checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);\n      }\n    }\n\n    return res;\n  }\n\n  function checkProp(res, hash, key, altKey, preserve) {\n    if (isDef(hash)) {\n      if (hasOwn(hash, key)) {\n        res[key] = hash[key];\n\n        if (!preserve) {\n          delete hash[key];\n        }\n\n        return true;\n      } else if (hasOwn(hash, altKey)) {\n        res[key] = hash[altKey];\n\n        if (!preserve) {\n          delete hash[altKey];\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /*  */\n  // The template compiler attempts to minimize the need for normalization by\n  // statically analyzing the template at compile time.\n  //\n  // For plain HTML markup, normalization can be completely skipped because the\n  // generated render function is guaranteed to return Array<VNode>. There are\n  // two cases where extra normalization is needed:\n  // 1. When the children contains components - because a functional component\n  // may return an Array instead of a single root. In this case, just a simple\n  // normalization is needed - if any child is an Array, we flatten the whole\n  // thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n  // because functional components already normalize their own children.\n\n\n  function simpleNormalizeChildren(children) {\n    for (var i = 0; i < children.length; i++) {\n      if (Array.isArray(children[i])) {\n        return Array.prototype.concat.apply([], children);\n      }\n    }\n\n    return children;\n  } // 2. When the children contains constructs that always generated nested Arrays,\n  // e.g. <template>, <slot>, v-for, or when the children is provided by user\n  // with hand-written render functions / JSX. In such cases a full normalization\n  // is needed to cater to all possible types of children values.\n\n\n  function normalizeChildren(children) {\n    return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;\n  }\n\n  function isTextNode(node) {\n    return isDef(node) && isDef(node.text) && isFalse(node.isComment);\n  }\n\n  function normalizeArrayChildren(children, nestedIndex) {\n    var res = [];\n    var i, c, lastIndex, last;\n\n    for (i = 0; i < children.length; i++) {\n      c = children[i];\n\n      if (isUndef(c) || typeof c === 'boolean') {\n        continue;\n      }\n\n      lastIndex = res.length - 1;\n      last = res[lastIndex]; //  nested\n\n      if (Array.isArray(c)) {\n        if (c.length > 0) {\n          c = normalizeArrayChildren(c, (nestedIndex || '') + \"_\" + i); // merge adjacent text nodes\n\n          if (isTextNode(c[0]) && isTextNode(last)) {\n            res[lastIndex] = createTextVNode(last.text + c[0].text);\n            c.shift();\n          }\n\n          res.push.apply(res, c);\n        }\n      } else if (isPrimitive(c)) {\n        if (isTextNode(last)) {\n          // merge adjacent text nodes\n          // this is necessary for SSR hydration because text nodes are\n          // essentially merged when rendered to HTML strings\n          res[lastIndex] = createTextVNode(last.text + c);\n        } else if (c !== '') {\n          // convert primitive to vnode\n          res.push(createTextVNode(c));\n        }\n      } else {\n        if (isTextNode(c) && isTextNode(last)) {\n          // merge adjacent text nodes\n          res[lastIndex] = createTextVNode(last.text + c.text);\n        } else {\n          // default key for nested array children (likely generated by v-for)\n          if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {\n            c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n          }\n\n          res.push(c);\n        }\n      }\n    }\n\n    return res;\n  }\n  /*  */\n\n\n  function initProvide(vm) {\n    var provide = vm.$options.provide;\n\n    if (provide) {\n      vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;\n    }\n  }\n\n  function initInjections(vm) {\n    var result = resolveInject(vm.$options.inject, vm);\n\n    if (result) {\n      toggleObserving(false);\n      Object.keys(result).forEach(function (key) {\n        /* istanbul ignore else */\n        {\n          defineReactive$$1(vm, key, result[key], function () {\n            warn(\"Avoid mutating an injected value directly since the changes will be \" + \"overwritten whenever the provided component re-renders. \" + \"injection being mutated: \\\"\" + key + \"\\\"\", vm);\n          });\n        }\n      });\n      toggleObserving(true);\n    }\n  }\n\n  function resolveInject(inject, vm) {\n    if (inject) {\n      // inject is :any because flow is not smart enough to figure out cached\n      var result = Object.create(null);\n      var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);\n\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i]; // #6574 in case the inject object is observed...\n\n        if (key === '__ob__') {\n          continue;\n        }\n\n        var provideKey = inject[key].from;\n        var source = vm;\n\n        while (source) {\n          if (source._provided && hasOwn(source._provided, provideKey)) {\n            result[key] = source._provided[provideKey];\n            break;\n          }\n\n          source = source.$parent;\n        }\n\n        if (!source) {\n          if ('default' in inject[key]) {\n            var provideDefault = inject[key].default;\n            result[key] = typeof provideDefault === 'function' ? provideDefault.call(vm) : provideDefault;\n          } else {\n            warn(\"Injection \\\"\" + key + \"\\\" not found\", vm);\n          }\n        }\n      }\n\n      return result;\n    }\n  }\n  /*  */\n\n  /**\n   * Runtime helper for resolving raw children VNodes into a slot object.\n   */\n\n\n  function resolveSlots(children, context) {\n    if (!children || !children.length) {\n      return {};\n    }\n\n    var slots = {};\n\n    for (var i = 0, l = children.length; i < l; i++) {\n      var child = children[i];\n      var data = child.data; // remove slot attribute if the node is resolved as a Vue slot node\n\n      if (data && data.attrs && data.attrs.slot) {\n        delete data.attrs.slot;\n      } // named slots should only be respected if the vnode was rendered in the\n      // same context.\n\n\n      if ((child.context === context || child.fnContext === context) && data && data.slot != null) {\n        var name = data.slot;\n        var slot = slots[name] || (slots[name] = []);\n\n        if (child.tag === 'template') {\n          slot.push.apply(slot, child.children || []);\n        } else {\n          slot.push(child);\n        }\n      } else {\n        (slots.default || (slots.default = [])).push(child);\n      }\n    } // ignore slots that contains only whitespace\n\n\n    for (var name$1 in slots) {\n      if (slots[name$1].every(isWhitespace)) {\n        delete slots[name$1];\n      }\n    }\n\n    return slots;\n  }\n\n  function isWhitespace(node) {\n    return node.isComment && !node.asyncFactory || node.text === ' ';\n  }\n  /*  */\n\n\n  function normalizeScopedSlots(slots, normalSlots, prevSlots) {\n    var res;\n    var hasNormalSlots = Object.keys(normalSlots).length > 0;\n    var isStable = slots ? !!slots.$stable : !hasNormalSlots;\n    var key = slots && slots.$key;\n\n    if (!slots) {\n      res = {};\n    } else if (slots._normalized) {\n      // fast path 1: child component re-render only, parent did not change\n      return slots._normalized;\n    } else if (isStable && prevSlots && prevSlots !== emptyObject && key === prevSlots.$key && !hasNormalSlots && !prevSlots.$hasNormal) {\n      // fast path 2: stable scoped slots w/ no normal slots to proxy,\n      // only need to normalize once\n      return prevSlots;\n    } else {\n      res = {};\n\n      for (var key$1 in slots) {\n        if (slots[key$1] && key$1[0] !== '$') {\n          res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);\n        }\n      }\n    } // expose normal slots on scopedSlots\n\n\n    for (var key$2 in normalSlots) {\n      if (!(key$2 in res)) {\n        res[key$2] = proxyNormalSlot(normalSlots, key$2);\n      }\n    } // avoriaz seems to mock a non-extensible $scopedSlots object\n    // and when that is passed down this would cause an error\n\n\n    if (slots && Object.isExtensible(slots)) {\n      slots._normalized = res;\n    }\n\n    def(res, '$stable', isStable);\n    def(res, '$key', key);\n    def(res, '$hasNormal', hasNormalSlots);\n    return res;\n  }\n\n  function normalizeScopedSlot(normalSlots, key, fn) {\n    var normalized = function normalized() {\n      var res = arguments.length ? fn.apply(null, arguments) : fn({});\n      res = res && _typeof(res) === 'object' && !Array.isArray(res) ? [res] // single vnode\n      : normalizeChildren(res);\n      return res && (res.length === 0 || res.length === 1 && res[0].isComment // #9658\n      ) ? undefined : res;\n    }; // this is a slot using the new v-slot syntax without scope. although it is\n    // compiled as a scoped slot, render fn users would expect it to be present\n    // on this.$slots because the usage is semantically a normal slot.\n\n\n    if (fn.proxy) {\n      Object.defineProperty(normalSlots, key, {\n        get: normalized,\n        enumerable: true,\n        configurable: true\n      });\n    }\n\n    return normalized;\n  }\n\n  function proxyNormalSlot(slots, key) {\n    return function () {\n      return slots[key];\n    };\n  }\n  /*  */\n\n  /**\n   * Runtime helper for rendering v-for lists.\n   */\n\n\n  function renderList(val, render) {\n    var ret, i, l, keys, key;\n\n    if (Array.isArray(val) || typeof val === 'string') {\n      ret = new Array(val.length);\n\n      for (i = 0, l = val.length; i < l; i++) {\n        ret[i] = render(val[i], i);\n      }\n    } else if (typeof val === 'number') {\n      ret = new Array(val);\n\n      for (i = 0; i < val; i++) {\n        ret[i] = render(i + 1, i);\n      }\n    } else if (isObject(val)) {\n      if (hasSymbol && val[Symbol.iterator]) {\n        ret = [];\n        var iterator = val[Symbol.iterator]();\n        var result = iterator.next();\n\n        while (!result.done) {\n          ret.push(render(result.value, ret.length));\n          result = iterator.next();\n        }\n      } else {\n        keys = Object.keys(val);\n        ret = new Array(keys.length);\n\n        for (i = 0, l = keys.length; i < l; i++) {\n          key = keys[i];\n          ret[i] = render(val[key], key, i);\n        }\n      }\n    }\n\n    if (!isDef(ret)) {\n      ret = [];\n    }\n\n    ret._isVList = true;\n    return ret;\n  }\n  /*  */\n\n  /**\n   * Runtime helper for rendering <slot>\n   */\n\n\n  function renderSlot(name, fallback, props, bindObject) {\n    var scopedSlotFn = this.$scopedSlots[name];\n    var nodes;\n\n    if (scopedSlotFn) {\n      // scoped slot\n      props = props || {};\n\n      if (bindObject) {\n        if (!isObject(bindObject)) {\n          warn('slot v-bind without argument expects an Object', this);\n        }\n\n        props = extend(extend({}, bindObject), props);\n      }\n\n      nodes = scopedSlotFn(props) || fallback;\n    } else {\n      nodes = this.$slots[name] || fallback;\n    }\n\n    var target = props && props.slot;\n\n    if (target) {\n      return this.$createElement('template', {\n        slot: target\n      }, nodes);\n    } else {\n      return nodes;\n    }\n  }\n  /*  */\n\n  /**\n   * Runtime helper for resolving filters\n   */\n\n\n  function resolveFilter(id) {\n    return resolveAsset(this.$options, 'filters', id, true) || identity;\n  }\n  /*  */\n\n\n  function isKeyNotMatch(expect, actual) {\n    if (Array.isArray(expect)) {\n      return expect.indexOf(actual) === -1;\n    } else {\n      return expect !== actual;\n    }\n  }\n  /**\n   * Runtime helper for checking keyCodes from config.\n   * exposed as Vue.prototype._k\n   * passing in eventKeyName as last argument separately for backwards compat\n   */\n\n\n  function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {\n    var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;\n\n    if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {\n      return isKeyNotMatch(builtInKeyName, eventKeyName);\n    } else if (mappedKeyCode) {\n      return isKeyNotMatch(mappedKeyCode, eventKeyCode);\n    } else if (eventKeyName) {\n      return hyphenate(eventKeyName) !== key;\n    }\n  }\n  /*  */\n\n  /**\n   * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n   */\n\n\n  function bindObjectProps(data, tag, value, asProp, isSync) {\n    if (value) {\n      if (!isObject(value)) {\n        warn('v-bind without argument expects an Object or Array value', this);\n      } else {\n        if (Array.isArray(value)) {\n          value = toObject(value);\n        }\n\n        var hash;\n\n        var loop = function loop(key) {\n          if (key === 'class' || key === 'style' || isReservedAttribute(key)) {\n            hash = data;\n          } else {\n            var type = data.attrs && data.attrs.type;\n            hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});\n          }\n\n          var camelizedKey = camelize(key);\n          var hyphenatedKey = hyphenate(key);\n\n          if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {\n            hash[key] = value[key];\n\n            if (isSync) {\n              var on = data.on || (data.on = {});\n\n              on[\"update:\" + key] = function ($event) {\n                value[key] = $event;\n              };\n            }\n          }\n        };\n\n        for (var key in value) {\n          loop(key);\n        }\n      }\n    }\n\n    return data;\n  }\n  /*  */\n\n  /**\n   * Runtime helper for rendering static trees.\n   */\n\n\n  function renderStatic(index, isInFor) {\n    var cached = this._staticTrees || (this._staticTrees = []);\n    var tree = cached[index]; // if has already-rendered static tree and not inside v-for,\n    // we can reuse the same tree.\n\n    if (tree && !isInFor) {\n      return tree;\n    } // otherwise, render a fresh tree.\n\n\n    tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, null, this // for render fns generated for functional component templates\n    );\n    markStatic(tree, \"__static__\" + index, false);\n    return tree;\n  }\n  /**\n   * Runtime helper for v-once.\n   * Effectively it means marking the node as static with a unique key.\n   */\n\n\n  function markOnce(tree, index, key) {\n    markStatic(tree, \"__once__\" + index + (key ? \"_\" + key : \"\"), true);\n    return tree;\n  }\n\n  function markStatic(tree, key, isOnce) {\n    if (Array.isArray(tree)) {\n      for (var i = 0; i < tree.length; i++) {\n        if (tree[i] && typeof tree[i] !== 'string') {\n          markStaticNode(tree[i], key + \"_\" + i, isOnce);\n        }\n      }\n    } else {\n      markStaticNode(tree, key, isOnce);\n    }\n  }\n\n  function markStaticNode(node, key, isOnce) {\n    node.isStatic = true;\n    node.key = key;\n    node.isOnce = isOnce;\n  }\n  /*  */\n\n\n  function bindObjectListeners(data, value) {\n    if (value) {\n      if (!isPlainObject(value)) {\n        warn('v-on without argument expects an Object value', this);\n      } else {\n        var on = data.on = data.on ? extend({}, data.on) : {};\n\n        for (var key in value) {\n          var existing = on[key];\n          var ours = value[key];\n          on[key] = existing ? [].concat(existing, ours) : ours;\n        }\n      }\n    }\n\n    return data;\n  }\n  /*  */\n\n\n  function resolveScopedSlots(fns, // see flow/vnode\n  res, // the following are added in 2.6\n  hasDynamicKeys, contentHashKey) {\n    res = res || {\n      $stable: !hasDynamicKeys\n    };\n\n    for (var i = 0; i < fns.length; i++) {\n      var slot = fns[i];\n\n      if (Array.isArray(slot)) {\n        resolveScopedSlots(slot, res, hasDynamicKeys);\n      } else if (slot) {\n        // marker for reverse proxying v-slot without scope on this.$slots\n        if (slot.proxy) {\n          slot.fn.proxy = true;\n        }\n\n        res[slot.key] = slot.fn;\n      }\n    }\n\n    if (contentHashKey) {\n      res.$key = contentHashKey;\n    }\n\n    return res;\n  }\n  /*  */\n\n\n  function bindDynamicKeys(baseObj, values) {\n    for (var i = 0; i < values.length; i += 2) {\n      var key = values[i];\n\n      if (typeof key === 'string' && key) {\n        baseObj[values[i]] = values[i + 1];\n      } else if (key !== '' && key !== null) {\n        // null is a speical value for explicitly removing a binding\n        warn(\"Invalid value for dynamic directive argument (expected string or null): \" + key, this);\n      }\n    }\n\n    return baseObj;\n  } // helper to dynamically append modifier runtime markers to event names.\n  // ensure only append when value is already string, otherwise it will be cast\n  // to string and cause the type check to miss.\n\n\n  function prependModifier(value, symbol) {\n    return typeof value === 'string' ? symbol + value : value;\n  }\n  /*  */\n\n\n  function installRenderHelpers(target) {\n    target._o = markOnce;\n    target._n = toNumber;\n    target._s = toString;\n    target._l = renderList;\n    target._t = renderSlot;\n    target._q = looseEqual;\n    target._i = looseIndexOf;\n    target._m = renderStatic;\n    target._f = resolveFilter;\n    target._k = checkKeyCodes;\n    target._b = bindObjectProps;\n    target._v = createTextVNode;\n    target._e = createEmptyVNode;\n    target._u = resolveScopedSlots;\n    target._g = bindObjectListeners;\n    target._d = bindDynamicKeys;\n    target._p = prependModifier;\n  }\n  /*  */\n\n\n  function FunctionalRenderContext(data, props, children, parent, Ctor) {\n    var this$1 = this;\n    var options = Ctor.options; // ensure the createElement function in functional components\n    // gets a unique context - this is necessary for correct named slot check\n\n    var contextVm;\n\n    if (hasOwn(parent, '_uid')) {\n      contextVm = Object.create(parent); // $flow-disable-line\n\n      contextVm._original = parent;\n    } else {\n      // the context vm passed in is a functional context as well.\n      // in this case we want to make sure we are able to get a hold to the\n      // real context instance.\n      contextVm = parent; // $flow-disable-line\n\n      parent = parent._original;\n    }\n\n    var isCompiled = isTrue(options._compiled);\n    var needNormalization = !isCompiled;\n    this.data = data;\n    this.props = props;\n    this.children = children;\n    this.parent = parent;\n    this.listeners = data.on || emptyObject;\n    this.injections = resolveInject(options.inject, parent);\n\n    this.slots = function () {\n      if (!this$1.$slots) {\n        normalizeScopedSlots(data.scopedSlots, this$1.$slots = resolveSlots(children, parent));\n      }\n\n      return this$1.$slots;\n    };\n\n    Object.defineProperty(this, 'scopedSlots', {\n      enumerable: true,\n      get: function get() {\n        return normalizeScopedSlots(data.scopedSlots, this.slots());\n      }\n    }); // support for compiled functional template\n\n    if (isCompiled) {\n      // exposing $options for renderStatic()\n      this.$options = options; // pre-resolve slots for renderSlot()\n\n      this.$slots = this.slots();\n      this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);\n    }\n\n    if (options._scopeId) {\n      this._c = function (a, b, c, d) {\n        var vnode = createElement(contextVm, a, b, c, d, needNormalization);\n\n        if (vnode && !Array.isArray(vnode)) {\n          vnode.fnScopeId = options._scopeId;\n          vnode.fnContext = parent;\n        }\n\n        return vnode;\n      };\n    } else {\n      this._c = function (a, b, c, d) {\n        return createElement(contextVm, a, b, c, d, needNormalization);\n      };\n    }\n  }\n\n  installRenderHelpers(FunctionalRenderContext.prototype);\n\n  function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {\n    var options = Ctor.options;\n    var props = {};\n    var propOptions = options.props;\n\n    if (isDef(propOptions)) {\n      for (var key in propOptions) {\n        props[key] = validateProp(key, propOptions, propsData || emptyObject);\n      }\n    } else {\n      if (isDef(data.attrs)) {\n        mergeProps(props, data.attrs);\n      }\n\n      if (isDef(data.props)) {\n        mergeProps(props, data.props);\n      }\n    }\n\n    var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);\n    var vnode = options.render.call(null, renderContext._c, renderContext);\n\n    if (vnode instanceof VNode) {\n      return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);\n    } else if (Array.isArray(vnode)) {\n      var vnodes = normalizeChildren(vnode) || [];\n      var res = new Array(vnodes.length);\n\n      for (var i = 0; i < vnodes.length; i++) {\n        res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);\n      }\n\n      return res;\n    }\n  }\n\n  function cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {\n    // #7817 clone node before setting fnContext, otherwise if the node is reused\n    // (e.g. it was from a cached normal slot) the fnContext causes named slots\n    // that should not be matched to match.\n    var clone = cloneVNode(vnode);\n    clone.fnContext = contextVm;\n    clone.fnOptions = options;\n    {\n      (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;\n    }\n\n    if (data.slot) {\n      (clone.data || (clone.data = {})).slot = data.slot;\n    }\n\n    return clone;\n  }\n\n  function mergeProps(to, from) {\n    for (var key in from) {\n      to[camelize(key)] = from[key];\n    }\n  }\n  /*  */\n\n  /*  */\n\n  /*  */\n\n  /*  */\n  // inline hooks to be invoked on component VNodes during patch\n\n\n  var componentVNodeHooks = {\n    init: function init(vnode, hydrating) {\n      if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {\n        // kept-alive components, treat as a patch\n        var mountedNode = vnode; // work around flow\n\n        componentVNodeHooks.prepatch(mountedNode, mountedNode);\n      } else {\n        var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance);\n        child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n      }\n    },\n    prepatch: function prepatch(oldVnode, vnode) {\n      var options = vnode.componentOptions;\n      var child = vnode.componentInstance = oldVnode.componentInstance;\n      updateChildComponent(child, options.propsData, // updated props\n      options.listeners, // updated listeners\n      vnode, // new parent vnode\n      options.children // new children\n      );\n    },\n    insert: function insert(vnode) {\n      var context = vnode.context;\n      var componentInstance = vnode.componentInstance;\n\n      if (!componentInstance._isMounted) {\n        componentInstance._isMounted = true;\n        callHook(componentInstance, 'mounted');\n      }\n\n      if (vnode.data.keepAlive) {\n        if (context._isMounted) {\n          // vue-router#1212\n          // During updates, a kept-alive component's child components may\n          // change, so directly walking the tree here may call activated hooks\n          // on incorrect children. Instead we push them into a queue which will\n          // be processed after the whole patch process ended.\n          queueActivatedComponent(componentInstance);\n        } else {\n          activateChildComponent(componentInstance, true\n          /* direct */\n          );\n        }\n      }\n    },\n    destroy: function destroy(vnode) {\n      var componentInstance = vnode.componentInstance;\n\n      if (!componentInstance._isDestroyed) {\n        if (!vnode.data.keepAlive) {\n          componentInstance.$destroy();\n        } else {\n          deactivateChildComponent(componentInstance, true\n          /* direct */\n          );\n        }\n      }\n    }\n  };\n  var hooksToMerge = Object.keys(componentVNodeHooks);\n\n  function createComponent(Ctor, data, context, children, tag) {\n    if (isUndef(Ctor)) {\n      return;\n    }\n\n    var baseCtor = context.$options._base; // plain options object: turn it into a constructor\n\n    if (isObject(Ctor)) {\n      Ctor = baseCtor.extend(Ctor);\n    } // if at this stage it's not a constructor or an async component factory,\n    // reject.\n\n\n    if (typeof Ctor !== 'function') {\n      {\n        warn(\"Invalid Component definition: \" + String(Ctor), context);\n      }\n      return;\n    } // async component\n\n\n    var asyncFactory;\n\n    if (isUndef(Ctor.cid)) {\n      asyncFactory = Ctor;\n      Ctor = resolveAsyncComponent(asyncFactory, baseCtor);\n\n      if (Ctor === undefined) {\n        // return a placeholder node for async component, which is rendered\n        // as a comment node but preserves all the raw information for the node.\n        // the information will be used for async server-rendering and hydration.\n        return createAsyncPlaceholder(asyncFactory, data, context, children, tag);\n      }\n    }\n\n    data = data || {}; // resolve constructor options in case global mixins are applied after\n    // component constructor creation\n\n    resolveConstructorOptions(Ctor); // transform component v-model data into props & events\n\n    if (isDef(data.model)) {\n      transformModel(Ctor.options, data);\n    } // extract props\n\n\n    var propsData = extractPropsFromVNodeData(data, Ctor, tag); // functional component\n\n    if (isTrue(Ctor.options.functional)) {\n      return createFunctionalComponent(Ctor, propsData, data, context, children);\n    } // extract listeners, since these needs to be treated as\n    // child component listeners instead of DOM listeners\n\n\n    var listeners = data.on; // replace with listeners with .native modifier\n    // so it gets processed during parent component patch.\n\n    data.on = data.nativeOn;\n\n    if (isTrue(Ctor.options.abstract)) {\n      // abstract components do not keep anything\n      // other than props & listeners & slot\n      // work around flow\n      var slot = data.slot;\n      data = {};\n\n      if (slot) {\n        data.slot = slot;\n      }\n    } // install component management hooks onto the placeholder node\n\n\n    installComponentHooks(data); // return a placeholder vnode\n\n    var name = Ctor.options.name || tag;\n    var vnode = new VNode(\"vue-component-\" + Ctor.cid + (name ? \"-\" + name : ''), data, undefined, undefined, undefined, context, {\n      Ctor: Ctor,\n      propsData: propsData,\n      listeners: listeners,\n      tag: tag,\n      children: children\n    }, asyncFactory);\n    return vnode;\n  }\n\n  function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't\n  parent // activeInstance in lifecycle state\n  ) {\n    var options = {\n      _isComponent: true,\n      _parentVnode: vnode,\n      parent: parent\n    }; // check inline-template render functions\n\n    var inlineTemplate = vnode.data.inlineTemplate;\n\n    if (isDef(inlineTemplate)) {\n      options.render = inlineTemplate.render;\n      options.staticRenderFns = inlineTemplate.staticRenderFns;\n    }\n\n    return new vnode.componentOptions.Ctor(options);\n  }\n\n  function installComponentHooks(data) {\n    var hooks = data.hook || (data.hook = {});\n\n    for (var i = 0; i < hooksToMerge.length; i++) {\n      var key = hooksToMerge[i];\n      var existing = hooks[key];\n      var toMerge = componentVNodeHooks[key];\n\n      if (existing !== toMerge && !(existing && existing._merged)) {\n        hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;\n      }\n    }\n  }\n\n  function mergeHook$1(f1, f2) {\n    var merged = function merged(a, b) {\n      // flow complains about extra args which is why we use any\n      f1(a, b);\n      f2(a, b);\n    };\n\n    merged._merged = true;\n    return merged;\n  } // transform component v-model info (value and callback) into\n  // prop and event handler respectively.\n\n\n  function transformModel(options, data) {\n    var prop = options.model && options.model.prop || 'value';\n    var event = options.model && options.model.event || 'input';\n    (data.attrs || (data.attrs = {}))[prop] = data.model.value;\n    var on = data.on || (data.on = {});\n    var existing = on[event];\n    var callback = data.model.callback;\n\n    if (isDef(existing)) {\n      if (Array.isArray(existing) ? existing.indexOf(callback) === -1 : existing !== callback) {\n        on[event] = [callback].concat(existing);\n      }\n    } else {\n      on[event] = callback;\n    }\n  }\n  /*  */\n\n\n  var SIMPLE_NORMALIZE = 1;\n  var ALWAYS_NORMALIZE = 2; // wrapper function for providing a more flexible interface\n  // without getting yelled at by flow\n\n  function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {\n    if (Array.isArray(data) || isPrimitive(data)) {\n      normalizationType = children;\n      children = data;\n      data = undefined;\n    }\n\n    if (isTrue(alwaysNormalize)) {\n      normalizationType = ALWAYS_NORMALIZE;\n    }\n\n    return _createElement(context, tag, data, children, normalizationType);\n  }\n\n  function _createElement(context, tag, data, children, normalizationType) {\n    if (isDef(data) && isDef(data.__ob__)) {\n      warn(\"Avoid using observed data object as vnode data: \" + JSON.stringify(data) + \"\\n\" + 'Always create fresh vnode data objects in each render!', context);\n      return createEmptyVNode();\n    } // object syntax in v-bind\n\n\n    if (isDef(data) && isDef(data.is)) {\n      tag = data.is;\n    }\n\n    if (!tag) {\n      // in case of component :is set to falsy value\n      return createEmptyVNode();\n    } // warn against non-primitive key\n\n\n    if (isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {\n      {\n        warn('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);\n      }\n    } // support single function children as default scoped slot\n\n\n    if (Array.isArray(children) && typeof children[0] === 'function') {\n      data = data || {};\n      data.scopedSlots = {\n        default: children[0]\n      };\n      children.length = 0;\n    }\n\n    if (normalizationType === ALWAYS_NORMALIZE) {\n      children = normalizeChildren(children);\n    } else if (normalizationType === SIMPLE_NORMALIZE) {\n      children = simpleNormalizeChildren(children);\n    }\n\n    var vnode, ns;\n\n    if (typeof tag === 'string') {\n      var Ctor;\n      ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);\n\n      if (config.isReservedTag(tag)) {\n        // platform built-in elements\n        vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);\n      } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n        // component\n        vnode = createComponent(Ctor, data, context, children, tag);\n      } else {\n        // unknown or unlisted namespaced elements\n        // check at runtime because it may get assigned a namespace when its\n        // parent normalizes children\n        vnode = new VNode(tag, data, children, undefined, undefined, context);\n      }\n    } else {\n      // direct component options / constructor\n      vnode = createComponent(tag, data, context, children);\n    }\n\n    if (Array.isArray(vnode)) {\n      return vnode;\n    } else if (isDef(vnode)) {\n      if (isDef(ns)) {\n        applyNS(vnode, ns);\n      }\n\n      if (isDef(data)) {\n        registerDeepBindings(data);\n      }\n\n      return vnode;\n    } else {\n      return createEmptyVNode();\n    }\n  }\n\n  function applyNS(vnode, ns, force) {\n    vnode.ns = ns;\n\n    if (vnode.tag === 'foreignObject') {\n      // use default namespace inside foreignObject\n      ns = undefined;\n      force = true;\n    }\n\n    if (isDef(vnode.children)) {\n      for (var i = 0, l = vnode.children.length; i < l; i++) {\n        var child = vnode.children[i];\n\n        if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force) && child.tag !== 'svg')) {\n          applyNS(child, ns, force);\n        }\n      }\n    }\n  } // ref #5318\n  // necessary to ensure parent re-render when deep bindings like :style and\n  // :class are used on slot nodes\n\n\n  function registerDeepBindings(data) {\n    if (isObject(data.style)) {\n      traverse(data.style);\n    }\n\n    if (isObject(data.class)) {\n      traverse(data.class);\n    }\n  }\n  /*  */\n\n\n  function initRender(vm) {\n    vm._vnode = null; // the root of the child tree\n\n    vm._staticTrees = null; // v-once cached trees\n\n    var options = vm.$options;\n    var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree\n\n    var renderContext = parentVnode && parentVnode.context;\n    vm.$slots = resolveSlots(options._renderChildren, renderContext);\n    vm.$scopedSlots = emptyObject; // bind the createElement fn to this instance\n    // so that we get proper render context inside it.\n    // args order: tag, data, children, normalizationType, alwaysNormalize\n    // internal version is used by render functions compiled from templates\n\n    vm._c = function (a, b, c, d) {\n      return createElement(vm, a, b, c, d, false);\n    }; // normalization is always applied for the public version, used in\n    // user-written render functions.\n\n\n    vm.$createElement = function (a, b, c, d) {\n      return createElement(vm, a, b, c, d, true);\n    }; // $attrs & $listeners are exposed for easier HOC creation.\n    // they need to be reactive so that HOCs using them are always updated\n\n\n    var parentData = parentVnode && parentVnode.data;\n    /* istanbul ignore else */\n\n    {\n      defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {\n        !isUpdatingChildComponent && warn(\"$attrs is readonly.\", vm);\n      }, true);\n      defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {\n        !isUpdatingChildComponent && warn(\"$listeners is readonly.\", vm);\n      }, true);\n    }\n  }\n\n  var currentRenderingInstance = null;\n\n  function renderMixin(Vue) {\n    // install runtime convenience helpers\n    installRenderHelpers(Vue.prototype);\n\n    Vue.prototype.$nextTick = function (fn) {\n      return nextTick(fn, this);\n    };\n\n    Vue.prototype._render = function () {\n      var vm = this;\n      var ref = vm.$options;\n      var render = ref.render;\n      var _parentVnode = ref._parentVnode;\n\n      if (_parentVnode) {\n        vm.$scopedSlots = normalizeScopedSlots(_parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);\n      } // set parent vnode. this allows render functions to have access\n      // to the data on the placeholder node.\n\n\n      vm.$vnode = _parentVnode; // render self\n\n      var vnode;\n\n      try {\n        // There's no need to maintain a stack becaues all render fns are called\n        // separately from one another. Nested component's render fns are called\n        // when parent component is patched.\n        currentRenderingInstance = vm;\n        vnode = render.call(vm._renderProxy, vm.$createElement);\n      } catch (e) {\n        handleError(e, vm, \"render\"); // return error render result,\n        // or previous vnode to prevent render error causing blank component\n\n        /* istanbul ignore else */\n\n        if (vm.$options.renderError) {\n          try {\n            vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);\n          } catch (e) {\n            handleError(e, vm, \"renderError\");\n            vnode = vm._vnode;\n          }\n        } else {\n          vnode = vm._vnode;\n        }\n      } finally {\n        currentRenderingInstance = null;\n      } // if the returned array contains only a single node, allow it\n\n\n      if (Array.isArray(vnode) && vnode.length === 1) {\n        vnode = vnode[0];\n      } // return empty vnode in case the render function errored out\n\n\n      if (!(vnode instanceof VNode)) {\n        if (Array.isArray(vnode)) {\n          warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);\n        }\n\n        vnode = createEmptyVNode();\n      } // set parent\n\n\n      vnode.parent = _parentVnode;\n      return vnode;\n    };\n  }\n  /*  */\n\n\n  function ensureCtor(comp, base) {\n    if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === 'Module') {\n      comp = comp.default;\n    }\n\n    return isObject(comp) ? base.extend(comp) : comp;\n  }\n\n  function createAsyncPlaceholder(factory, data, context, children, tag) {\n    var node = createEmptyVNode();\n    node.asyncFactory = factory;\n    node.asyncMeta = {\n      data: data,\n      context: context,\n      children: children,\n      tag: tag\n    };\n    return node;\n  }\n\n  function resolveAsyncComponent(factory, baseCtor) {\n    if (isTrue(factory.error) && isDef(factory.errorComp)) {\n      return factory.errorComp;\n    }\n\n    if (isDef(factory.resolved)) {\n      return factory.resolved;\n    }\n\n    var owner = currentRenderingInstance;\n\n    if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {\n      // already pending\n      factory.owners.push(owner);\n    }\n\n    if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n      return factory.loadingComp;\n    }\n\n    if (owner && !isDef(factory.owners)) {\n      var owners = factory.owners = [owner];\n      var sync = true;\n      var timerLoading = null;\n      var timerTimeout = null;\n      owner.$on('hook:destroyed', function () {\n        return remove(owners, owner);\n      });\n\n      var forceRender = function forceRender(renderCompleted) {\n        for (var i = 0, l = owners.length; i < l; i++) {\n          owners[i].$forceUpdate();\n        }\n\n        if (renderCompleted) {\n          owners.length = 0;\n\n          if (timerLoading !== null) {\n            clearTimeout(timerLoading);\n            timerLoading = null;\n          }\n\n          if (timerTimeout !== null) {\n            clearTimeout(timerTimeout);\n            timerTimeout = null;\n          }\n        }\n      };\n\n      var resolve = once(function (res) {\n        // cache resolved\n        factory.resolved = ensureCtor(res, baseCtor); // invoke callbacks only if this is not a synchronous resolve\n        // (async resolves are shimmed as synchronous during SSR)\n\n        if (!sync) {\n          forceRender(true);\n        } else {\n          owners.length = 0;\n        }\n      });\n      var reject = once(function (reason) {\n        warn(\"Failed to resolve async component: \" + String(factory) + (reason ? \"\\nReason: \" + reason : ''));\n\n        if (isDef(factory.errorComp)) {\n          factory.error = true;\n          forceRender(true);\n        }\n      });\n      var res = factory(resolve, reject);\n\n      if (isObject(res)) {\n        if (isPromise(res)) {\n          // () => Promise\n          if (isUndef(factory.resolved)) {\n            res.then(resolve, reject);\n          }\n        } else if (isPromise(res.component)) {\n          res.component.then(resolve, reject);\n\n          if (isDef(res.error)) {\n            factory.errorComp = ensureCtor(res.error, baseCtor);\n          }\n\n          if (isDef(res.loading)) {\n            factory.loadingComp = ensureCtor(res.loading, baseCtor);\n\n            if (res.delay === 0) {\n              factory.loading = true;\n            } else {\n              timerLoading = setTimeout(function () {\n                timerLoading = null;\n\n                if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                  factory.loading = true;\n                  forceRender(false);\n                }\n              }, res.delay || 200);\n            }\n          }\n\n          if (isDef(res.timeout)) {\n            timerTimeout = setTimeout(function () {\n              timerTimeout = null;\n\n              if (isUndef(factory.resolved)) {\n                reject(\"timeout (\" + res.timeout + \"ms)\");\n              }\n            }, res.timeout);\n          }\n        }\n      }\n\n      sync = false; // return in case resolved synchronously\n\n      return factory.loading ? factory.loadingComp : factory.resolved;\n    }\n  }\n  /*  */\n\n\n  function isAsyncPlaceholder(node) {\n    return node.isComment && node.asyncFactory;\n  }\n  /*  */\n\n\n  function getFirstComponentChild(children) {\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length; i++) {\n        var c = children[i];\n\n        if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {\n          return c;\n        }\n      }\n    }\n  }\n  /*  */\n\n  /*  */\n\n\n  function initEvents(vm) {\n    vm._events = Object.create(null);\n    vm._hasHookEvent = false; // init parent attached events\n\n    var listeners = vm.$options._parentListeners;\n\n    if (listeners) {\n      updateComponentListeners(vm, listeners);\n    }\n  }\n\n  var target;\n\n  function add(event, fn) {\n    target.$on(event, fn);\n  }\n\n  function remove$1(event, fn) {\n    target.$off(event, fn);\n  }\n\n  function createOnceHandler(event, fn) {\n    var _target = target;\n    return function onceHandler() {\n      var res = fn.apply(null, arguments);\n\n      if (res !== null) {\n        _target.$off(event, onceHandler);\n      }\n    };\n  }\n\n  function updateComponentListeners(vm, listeners, oldListeners) {\n    target = vm;\n    updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);\n    target = undefined;\n  }\n\n  function eventsMixin(Vue) {\n    var hookRE = /^hook:/;\n\n    Vue.prototype.$on = function (event, fn) {\n      var vm = this;\n\n      if (Array.isArray(event)) {\n        for (var i = 0, l = event.length; i < l; i++) {\n          vm.$on(event[i], fn);\n        }\n      } else {\n        (vm._events[event] || (vm._events[event] = [])).push(fn); // optimize hook:event cost by using a boolean flag marked at registration\n        // instead of a hash lookup\n\n        if (hookRE.test(event)) {\n          vm._hasHookEvent = true;\n        }\n      }\n\n      return vm;\n    };\n\n    Vue.prototype.$once = function (event, fn) {\n      var vm = this;\n\n      function on() {\n        vm.$off(event, on);\n        fn.apply(vm, arguments);\n      }\n\n      on.fn = fn;\n      vm.$on(event, on);\n      return vm;\n    };\n\n    Vue.prototype.$off = function (event, fn) {\n      var vm = this; // all\n\n      if (!arguments.length) {\n        vm._events = Object.create(null);\n        return vm;\n      } // array of events\n\n\n      if (Array.isArray(event)) {\n        for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {\n          vm.$off(event[i$1], fn);\n        }\n\n        return vm;\n      } // specific event\n\n\n      var cbs = vm._events[event];\n\n      if (!cbs) {\n        return vm;\n      }\n\n      if (!fn) {\n        vm._events[event] = null;\n        return vm;\n      } // specific handler\n\n\n      var cb;\n      var i = cbs.length;\n\n      while (i--) {\n        cb = cbs[i];\n\n        if (cb === fn || cb.fn === fn) {\n          cbs.splice(i, 1);\n          break;\n        }\n      }\n\n      return vm;\n    };\n\n    Vue.prototype.$emit = function (event) {\n      var vm = this;\n      {\n        var lowerCaseEvent = event.toLowerCase();\n\n        if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n          tip(\"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" + formatComponentName(vm) + \" but the handler is registered for \\\"\" + event + \"\\\". \" + \"Note that HTML attributes are case-insensitive and you cannot use \" + \"v-on to listen to camelCase events when using in-DOM templates. \" + \"You should probably use \\\"\" + hyphenate(event) + \"\\\" instead of \\\"\" + event + \"\\\".\");\n        }\n      }\n      var cbs = vm._events[event];\n\n      if (cbs) {\n        cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n        var args = toArray(arguments, 1);\n        var info = \"event handler for \\\"\" + event + \"\\\"\";\n\n        for (var i = 0, l = cbs.length; i < l; i++) {\n          invokeWithErrorHandling(cbs[i], vm, args, vm, info);\n        }\n      }\n\n      return vm;\n    };\n  }\n  /*  */\n\n\n  var activeInstance = null;\n  var isUpdatingChildComponent = false;\n\n  function setActiveInstance(vm) {\n    var prevActiveInstance = activeInstance;\n    activeInstance = vm;\n    return function () {\n      activeInstance = prevActiveInstance;\n    };\n  }\n\n  function initLifecycle(vm) {\n    var options = vm.$options; // locate first non-abstract parent\n\n    var parent = options.parent;\n\n    if (parent && !options.abstract) {\n      while (parent.$options.abstract && parent.$parent) {\n        parent = parent.$parent;\n      }\n\n      parent.$children.push(vm);\n    }\n\n    vm.$parent = parent;\n    vm.$root = parent ? parent.$root : vm;\n    vm.$children = [];\n    vm.$refs = {};\n    vm._watcher = null;\n    vm._inactive = null;\n    vm._directInactive = false;\n    vm._isMounted = false;\n    vm._isDestroyed = false;\n    vm._isBeingDestroyed = false;\n  }\n\n  function lifecycleMixin(Vue) {\n    Vue.prototype._update = function (vnode, hydrating) {\n      var vm = this;\n      var prevEl = vm.$el;\n      var prevVnode = vm._vnode;\n      var restoreActiveInstance = setActiveInstance(vm);\n      vm._vnode = vnode; // Vue.prototype.__patch__ is injected in entry points\n      // based on the rendering backend used.\n\n      if (!prevVnode) {\n        // initial render\n        vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false\n        /* removeOnly */\n        );\n      } else {\n        // updates\n        vm.$el = vm.__patch__(prevVnode, vnode);\n      }\n\n      restoreActiveInstance(); // update __vue__ reference\n\n      if (prevEl) {\n        prevEl.__vue__ = null;\n      }\n\n      if (vm.$el) {\n        vm.$el.__vue__ = vm;\n      } // if parent is an HOC, update its $el as well\n\n\n      if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n        vm.$parent.$el = vm.$el;\n      } // updated hook is called by the scheduler to ensure that children are\n      // updated in a parent's updated hook.\n\n    };\n\n    Vue.prototype.$forceUpdate = function () {\n      var vm = this;\n\n      if (vm._watcher) {\n        vm._watcher.update();\n      }\n    };\n\n    Vue.prototype.$destroy = function () {\n      var vm = this;\n\n      if (vm._isBeingDestroyed) {\n        return;\n      }\n\n      callHook(vm, 'beforeDestroy');\n      vm._isBeingDestroyed = true; // remove self from parent\n\n      var parent = vm.$parent;\n\n      if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n        remove(parent.$children, vm);\n      } // teardown watchers\n\n\n      if (vm._watcher) {\n        vm._watcher.teardown();\n      }\n\n      var i = vm._watchers.length;\n\n      while (i--) {\n        vm._watchers[i].teardown();\n      } // remove reference from data ob\n      // frozen object may not have observer.\n\n\n      if (vm._data.__ob__) {\n        vm._data.__ob__.vmCount--;\n      } // call the last hook...\n\n\n      vm._isDestroyed = true; // invoke destroy hooks on current rendered tree\n\n      vm.__patch__(vm._vnode, null); // fire destroyed hook\n\n\n      callHook(vm, 'destroyed'); // turn off all instance listeners.\n\n      vm.$off(); // remove __vue__ reference\n\n      if (vm.$el) {\n        vm.$el.__vue__ = null;\n      } // release circular reference (#6759)\n\n\n      if (vm.$vnode) {\n        vm.$vnode.parent = null;\n      }\n    };\n  }\n\n  function mountComponent(vm, el, hydrating) {\n    vm.$el = el;\n\n    if (!vm.$options.render) {\n      vm.$options.render = createEmptyVNode;\n      {\n        /* istanbul ignore if */\n        if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {\n          warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);\n        } else {\n          warn('Failed to mount component: template or render function not defined.', vm);\n        }\n      }\n    }\n\n    callHook(vm, 'beforeMount');\n    var updateComponent;\n    /* istanbul ignore if */\n\n    if (config.performance && mark) {\n      updateComponent = function updateComponent() {\n        var name = vm._name;\n        var id = vm._uid;\n        var startTag = \"vue-perf-start:\" + id;\n        var endTag = \"vue-perf-end:\" + id;\n        mark(startTag);\n\n        var vnode = vm._render();\n\n        mark(endTag);\n        measure(\"vue \" + name + \" render\", startTag, endTag);\n        mark(startTag);\n\n        vm._update(vnode, hydrating);\n\n        mark(endTag);\n        measure(\"vue \" + name + \" patch\", startTag, endTag);\n      };\n    } else {\n      updateComponent = function updateComponent() {\n        vm._update(vm._render(), hydrating);\n      };\n    } // we set this to vm._watcher inside the watcher's constructor\n    // since the watcher's initial patch may call $forceUpdate (e.g. inside child\n    // component's mounted hook), which relies on vm._watcher being already defined\n\n\n    new Watcher(vm, updateComponent, noop, {\n      before: function before() {\n        if (vm._isMounted && !vm._isDestroyed) {\n          callHook(vm, 'beforeUpdate');\n        }\n      }\n    }, true\n    /* isRenderWatcher */\n    );\n    hydrating = false; // manually mounted instance, call mounted on self\n    // mounted is called for render-created child components in its inserted hook\n\n    if (vm.$vnode == null) {\n      vm._isMounted = true;\n      callHook(vm, 'mounted');\n    }\n\n    return vm;\n  }\n\n  function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {\n    {\n      isUpdatingChildComponent = true;\n    } // determine whether component has slot children\n    // we need to do this before overwriting $options._renderChildren.\n    // check if there are dynamic scopedSlots (hand-written or compiled but with\n    // dynamic slot names). Static scoped slots compiled from template has the\n    // \"$stable\" marker.\n\n    var newScopedSlots = parentVnode.data.scopedSlots;\n    var oldScopedSlots = vm.$scopedSlots;\n    var hasDynamicScopedSlot = !!(newScopedSlots && !newScopedSlots.$stable || oldScopedSlots !== emptyObject && !oldScopedSlots.$stable || newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key); // Any static slot children from the parent may have changed during parent's\n    // update. Dynamic scoped slots may also have changed. In such cases, a forced\n    // update is necessary to ensure correctness.\n\n    var needsForceUpdate = !!(renderChildren || // has new static slots\n    vm.$options._renderChildren || // has old static slots\n    hasDynamicScopedSlot);\n    vm.$options._parentVnode = parentVnode;\n    vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n\n    if (vm._vnode) {\n      // update child tree's parent\n      vm._vnode.parent = parentVnode;\n    }\n\n    vm.$options._renderChildren = renderChildren; // update $attrs and $listeners hash\n    // these are also reactive so they may trigger child update if the child\n    // used them during render\n\n    vm.$attrs = parentVnode.data.attrs || emptyObject;\n    vm.$listeners = listeners || emptyObject; // update props\n\n    if (propsData && vm.$options.props) {\n      toggleObserving(false);\n      var props = vm._props;\n      var propKeys = vm.$options._propKeys || [];\n\n      for (var i = 0; i < propKeys.length; i++) {\n        var key = propKeys[i];\n        var propOptions = vm.$options.props; // wtf flow?\n\n        props[key] = validateProp(key, propOptions, propsData, vm);\n      }\n\n      toggleObserving(true); // keep a copy of raw propsData\n\n      vm.$options.propsData = propsData;\n    } // update listeners\n\n\n    listeners = listeners || emptyObject;\n    var oldListeners = vm.$options._parentListeners;\n    vm.$options._parentListeners = listeners;\n    updateComponentListeners(vm, listeners, oldListeners); // resolve slots + force update if has children\n\n    if (needsForceUpdate) {\n      vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n      vm.$forceUpdate();\n    }\n\n    {\n      isUpdatingChildComponent = false;\n    }\n  }\n\n  function isInInactiveTree(vm) {\n    while (vm && (vm = vm.$parent)) {\n      if (vm._inactive) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function activateChildComponent(vm, direct) {\n    if (direct) {\n      vm._directInactive = false;\n\n      if (isInInactiveTree(vm)) {\n        return;\n      }\n    } else if (vm._directInactive) {\n      return;\n    }\n\n    if (vm._inactive || vm._inactive === null) {\n      vm._inactive = false;\n\n      for (var i = 0; i < vm.$children.length; i++) {\n        activateChildComponent(vm.$children[i]);\n      }\n\n      callHook(vm, 'activated');\n    }\n  }\n\n  function deactivateChildComponent(vm, direct) {\n    if (direct) {\n      vm._directInactive = true;\n\n      if (isInInactiveTree(vm)) {\n        return;\n      }\n    }\n\n    if (!vm._inactive) {\n      vm._inactive = true;\n\n      for (var i = 0; i < vm.$children.length; i++) {\n        deactivateChildComponent(vm.$children[i]);\n      }\n\n      callHook(vm, 'deactivated');\n    }\n  }\n\n  function callHook(vm, hook) {\n    // #7573 disable dep collection when invoking lifecycle hooks\n    pushTarget();\n    var handlers = vm.$options[hook];\n    var info = hook + \" hook\";\n\n    if (handlers) {\n      for (var i = 0, j = handlers.length; i < j; i++) {\n        invokeWithErrorHandling(handlers[i], vm, null, vm, info);\n      }\n    }\n\n    if (vm._hasHookEvent) {\n      vm.$emit('hook:' + hook);\n    }\n\n    popTarget();\n  }\n  /*  */\n\n\n  var MAX_UPDATE_COUNT = 100;\n  var queue = [];\n  var activatedChildren = [];\n  var has = {};\n  var circular = {};\n  var waiting = false;\n  var flushing = false;\n  var index = 0;\n  /**\n   * Reset the scheduler's state.\n   */\n\n  function resetSchedulerState() {\n    index = queue.length = activatedChildren.length = 0;\n    has = {};\n    {\n      circular = {};\n    }\n    waiting = flushing = false;\n  } // Async edge case #6566 requires saving the timestamp when event listeners are\n  // attached. However, calling performance.now() has a perf overhead especially\n  // if the page has thousands of event listeners. Instead, we take a timestamp\n  // every time the scheduler flushes and use that for all event listeners\n  // attached during that flush.\n\n\n  var currentFlushTimestamp = 0; // Async edge case fix requires storing an event listener's attach timestamp.\n\n  var getNow = Date.now; // Determine what event timestamp the browser is using. Annoyingly, the\n  // timestamp can either be hi-res (relative to page load) or low-res\n  // (relative to UNIX epoch), so in order to compare time we have to use the\n  // same timestamp type when saving the flush timestamp.\n  // All IE versions use low-res event timestamps, and have problematic clock\n  // implementations (#9632)\n\n  if (inBrowser && !isIE) {\n    var performance = window.performance;\n\n    if (performance && typeof performance.now === 'function' && getNow() > document.createEvent('Event').timeStamp) {\n      // if the event timestamp, although evaluated AFTER the Date.now(), is\n      // smaller than it, it means the event is using a hi-res timestamp,\n      // and we need to use the hi-res version for event listener timestamps as\n      // well.\n      getNow = function getNow() {\n        return performance.now();\n      };\n    }\n  }\n  /**\n   * Flush both queues and run the watchers.\n   */\n\n\n  function flushSchedulerQueue() {\n    currentFlushTimestamp = getNow();\n    flushing = true;\n    var watcher, id; // Sort queue before flush.\n    // This ensures that:\n    // 1. Components are updated from parent to child. (because parent is always\n    //    created before the child)\n    // 2. A component's user watchers are run before its render watcher (because\n    //    user watchers are created before the render watcher)\n    // 3. If a component is destroyed during a parent component's watcher run,\n    //    its watchers can be skipped.\n\n    queue.sort(function (a, b) {\n      return a.id - b.id;\n    }); // do not cache length because more watchers might be pushed\n    // as we run existing watchers\n\n    for (index = 0; index < queue.length; index++) {\n      watcher = queue[index];\n\n      if (watcher.before) {\n        watcher.before();\n      }\n\n      id = watcher.id;\n      has[id] = null;\n      watcher.run(); // in dev build, check and stop circular updates.\n\n      if (has[id] != null) {\n        circular[id] = (circular[id] || 0) + 1;\n\n        if (circular[id] > MAX_UPDATE_COUNT) {\n          warn('You may have an infinite update loop ' + (watcher.user ? \"in watcher with expression \\\"\" + watcher.expression + \"\\\"\" : \"in a component render function.\"), watcher.vm);\n          break;\n        }\n      }\n    } // keep copies of post queues before resetting state\n\n\n    var activatedQueue = activatedChildren.slice();\n    var updatedQueue = queue.slice();\n    resetSchedulerState(); // call component updated and activated hooks\n\n    callActivatedHooks(activatedQueue);\n    callUpdatedHooks(updatedQueue); // devtool hook\n\n    /* istanbul ignore if */\n\n    if (devtools && config.devtools) {\n      devtools.emit('flush');\n    }\n  }\n\n  function callUpdatedHooks(queue) {\n    var i = queue.length;\n\n    while (i--) {\n      var watcher = queue[i];\n      var vm = watcher.vm;\n\n      if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {\n        callHook(vm, 'updated');\n      }\n    }\n  }\n  /**\n   * Queue a kept-alive component that was activated during patch.\n   * The queue will be processed after the entire tree has been patched.\n   */\n\n\n  function queueActivatedComponent(vm) {\n    // setting _inactive to false here so that a render function can\n    // rely on checking whether it's in an inactive tree (e.g. router-view)\n    vm._inactive = false;\n    activatedChildren.push(vm);\n  }\n\n  function callActivatedHooks(queue) {\n    for (var i = 0; i < queue.length; i++) {\n      queue[i]._inactive = true;\n      activateChildComponent(queue[i], true\n      /* true */\n      );\n    }\n  }\n  /**\n   * Push a watcher into the watcher queue.\n   * Jobs with duplicate IDs will be skipped unless it's\n   * pushed when the queue is being flushed.\n   */\n\n\n  function queueWatcher(watcher) {\n    var id = watcher.id;\n\n    if (has[id] == null) {\n      has[id] = true;\n\n      if (!flushing) {\n        queue.push(watcher);\n      } else {\n        // if already flushing, splice the watcher based on its id\n        // if already past its id, it will be run next immediately.\n        var i = queue.length - 1;\n\n        while (i > index && queue[i].id > watcher.id) {\n          i--;\n        }\n\n        queue.splice(i + 1, 0, watcher);\n      } // queue the flush\n\n\n      if (!waiting) {\n        waiting = true;\n\n        if (!config.async) {\n          flushSchedulerQueue();\n          return;\n        }\n\n        nextTick(flushSchedulerQueue);\n      }\n    }\n  }\n  /*  */\n\n\n  var uid$2 = 0;\n  /**\n   * A watcher parses an expression, collects dependencies,\n   * and fires callback when the expression value changes.\n   * This is used for both the $watch() api and directives.\n   */\n\n  var Watcher = function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {\n    this.vm = vm;\n\n    if (isRenderWatcher) {\n      vm._watcher = this;\n    }\n\n    vm._watchers.push(this); // options\n\n\n    if (options) {\n      this.deep = !!options.deep;\n      this.user = !!options.user;\n      this.lazy = !!options.lazy;\n      this.sync = !!options.sync;\n      this.before = options.before;\n    } else {\n      this.deep = this.user = this.lazy = this.sync = false;\n    }\n\n    this.cb = cb;\n    this.id = ++uid$2; // uid for batching\n\n    this.active = true;\n    this.dirty = this.lazy; // for lazy watchers\n\n    this.deps = [];\n    this.newDeps = [];\n    this.depIds = new _Set();\n    this.newDepIds = new _Set();\n    this.expression = expOrFn.toString(); // parse expression for getter\n\n    if (typeof expOrFn === 'function') {\n      this.getter = expOrFn;\n    } else {\n      this.getter = parsePath(expOrFn);\n\n      if (!this.getter) {\n        this.getter = noop;\n        warn(\"Failed watching path: \\\"\" + expOrFn + \"\\\" \" + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);\n      }\n    }\n\n    this.value = this.lazy ? undefined : this.get();\n  };\n  /**\n   * Evaluate the getter, and re-collect dependencies.\n   */\n\n\n  Watcher.prototype.get = function get() {\n    pushTarget(this);\n    var value;\n    var vm = this.vm;\n\n    try {\n      value = this.getter.call(vm, vm);\n    } catch (e) {\n      if (this.user) {\n        handleError(e, vm, \"getter for watcher \\\"\" + this.expression + \"\\\"\");\n      } else {\n        throw e;\n      }\n    } finally {\n      // \"touch\" every property so they are all tracked as\n      // dependencies for deep watching\n      if (this.deep) {\n        traverse(value);\n      }\n\n      popTarget();\n      this.cleanupDeps();\n    }\n\n    return value;\n  };\n  /**\n   * Add a dependency to this directive.\n   */\n\n\n  Watcher.prototype.addDep = function addDep(dep) {\n    var id = dep.id;\n\n    if (!this.newDepIds.has(id)) {\n      this.newDepIds.add(id);\n      this.newDeps.push(dep);\n\n      if (!this.depIds.has(id)) {\n        dep.addSub(this);\n      }\n    }\n  };\n  /**\n   * Clean up for dependency collection.\n   */\n\n\n  Watcher.prototype.cleanupDeps = function cleanupDeps() {\n    var i = this.deps.length;\n\n    while (i--) {\n      var dep = this.deps[i];\n\n      if (!this.newDepIds.has(dep.id)) {\n        dep.removeSub(this);\n      }\n    }\n\n    var tmp = this.depIds;\n    this.depIds = this.newDepIds;\n    this.newDepIds = tmp;\n    this.newDepIds.clear();\n    tmp = this.deps;\n    this.deps = this.newDeps;\n    this.newDeps = tmp;\n    this.newDeps.length = 0;\n  };\n  /**\n   * Subscriber interface.\n   * Will be called when a dependency changes.\n   */\n\n\n  Watcher.prototype.update = function update() {\n    /* istanbul ignore else */\n    if (this.lazy) {\n      this.dirty = true;\n    } else if (this.sync) {\n      this.run();\n    } else {\n      queueWatcher(this);\n    }\n  };\n  /**\n   * Scheduler job interface.\n   * Will be called by the scheduler.\n   */\n\n\n  Watcher.prototype.run = function run() {\n    if (this.active) {\n      var value = this.get();\n\n      if (value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) || this.deep) {\n        // set new value\n        var oldValue = this.value;\n        this.value = value;\n\n        if (this.user) {\n          try {\n            this.cb.call(this.vm, value, oldValue);\n          } catch (e) {\n            handleError(e, this.vm, \"callback for watcher \\\"\" + this.expression + \"\\\"\");\n          }\n        } else {\n          this.cb.call(this.vm, value, oldValue);\n        }\n      }\n    }\n  };\n  /**\n   * Evaluate the value of the watcher.\n   * This only gets called for lazy watchers.\n   */\n\n\n  Watcher.prototype.evaluate = function evaluate() {\n    this.value = this.get();\n    this.dirty = false;\n  };\n  /**\n   * Depend on all deps collected by this watcher.\n   */\n\n\n  Watcher.prototype.depend = function depend() {\n    var i = this.deps.length;\n\n    while (i--) {\n      this.deps[i].depend();\n    }\n  };\n  /**\n   * Remove self from all dependencies' subscriber list.\n   */\n\n\n  Watcher.prototype.teardown = function teardown() {\n    if (this.active) {\n      // remove self from vm's watcher list\n      // this is a somewhat expensive operation so we skip it\n      // if the vm is being destroyed.\n      if (!this.vm._isBeingDestroyed) {\n        remove(this.vm._watchers, this);\n      }\n\n      var i = this.deps.length;\n\n      while (i--) {\n        this.deps[i].removeSub(this);\n      }\n\n      this.active = false;\n    }\n  };\n  /*  */\n\n\n  var sharedPropertyDefinition = {\n    enumerable: true,\n    configurable: true,\n    get: noop,\n    set: noop\n  };\n\n  function proxy(target, sourceKey, key) {\n    sharedPropertyDefinition.get = function proxyGetter() {\n      return this[sourceKey][key];\n    };\n\n    sharedPropertyDefinition.set = function proxySetter(val) {\n      this[sourceKey][key] = val;\n    };\n\n    Object.defineProperty(target, key, sharedPropertyDefinition);\n  }\n\n  function initState(vm) {\n    vm._watchers = [];\n    var opts = vm.$options;\n\n    if (opts.props) {\n      initProps(vm, opts.props);\n    }\n\n    if (opts.methods) {\n      initMethods(vm, opts.methods);\n    }\n\n    if (opts.data) {\n      initData(vm);\n    } else {\n      observe(vm._data = {}, true\n      /* asRootData */\n      );\n    }\n\n    if (opts.computed) {\n      initComputed(vm, opts.computed);\n    }\n\n    if (opts.watch && opts.watch !== nativeWatch) {\n      initWatch(vm, opts.watch);\n    }\n  }\n\n  function initProps(vm, propsOptions) {\n    var propsData = vm.$options.propsData || {};\n    var props = vm._props = {}; // cache prop keys so that future props updates can iterate using Array\n    // instead of dynamic object key enumeration.\n\n    var keys = vm.$options._propKeys = [];\n    var isRoot = !vm.$parent; // root instance props should be converted\n\n    if (!isRoot) {\n      toggleObserving(false);\n    }\n\n    var loop = function loop(key) {\n      keys.push(key);\n      var value = validateProp(key, propsOptions, propsData, vm);\n      /* istanbul ignore else */\n\n      {\n        var hyphenatedKey = hyphenate(key);\n\n        if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {\n          warn(\"\\\"\" + hyphenatedKey + \"\\\" is a reserved attribute and cannot be used as component prop.\", vm);\n        }\n\n        defineReactive$$1(props, key, value, function () {\n          if (!isRoot && !isUpdatingChildComponent) {\n            warn(\"Avoid mutating a prop directly since the value will be \" + \"overwritten whenever the parent component re-renders. \" + \"Instead, use a data or computed property based on the prop's \" + \"value. Prop being mutated: \\\"\" + key + \"\\\"\", vm);\n          }\n        });\n      } // static props are already proxied on the component's prototype\n      // during Vue.extend(). We only need to proxy props defined at\n      // instantiation here.\n\n      if (!(key in vm)) {\n        proxy(vm, \"_props\", key);\n      }\n    };\n\n    for (var key in propsOptions) {\n      loop(key);\n    }\n\n    toggleObserving(true);\n  }\n\n  function initData(vm) {\n    var data = vm.$options.data;\n    data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};\n\n    if (!isPlainObject(data)) {\n      data = {};\n      warn('data functions should return an object:\\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);\n    } // proxy data on instance\n\n\n    var keys = Object.keys(data);\n    var props = vm.$options.props;\n    var methods = vm.$options.methods;\n    var i = keys.length;\n\n    while (i--) {\n      var key = keys[i];\n      {\n        if (methods && hasOwn(methods, key)) {\n          warn(\"Method \\\"\" + key + \"\\\" has already been defined as a data property.\", vm);\n        }\n      }\n\n      if (props && hasOwn(props, key)) {\n        warn(\"The data property \\\"\" + key + \"\\\" is already declared as a prop. \" + \"Use prop default value instead.\", vm);\n      } else if (!isReserved(key)) {\n        proxy(vm, \"_data\", key);\n      }\n    } // observe data\n\n\n    observe(data, true\n    /* asRootData */\n    );\n  }\n\n  function getData(data, vm) {\n    // #7573 disable dep collection when invoking data getters\n    pushTarget();\n\n    try {\n      return data.call(vm, vm);\n    } catch (e) {\n      handleError(e, vm, \"data()\");\n      return {};\n    } finally {\n      popTarget();\n    }\n  }\n\n  var computedWatcherOptions = {\n    lazy: true\n  };\n\n  function initComputed(vm, computed) {\n    // $flow-disable-line\n    var watchers = vm._computedWatchers = Object.create(null); // computed properties are just getters during SSR\n\n    var isSSR = isServerRendering();\n\n    for (var key in computed) {\n      var userDef = computed[key];\n      var getter = typeof userDef === 'function' ? userDef : userDef.get;\n\n      if (getter == null) {\n        warn(\"Getter is missing for computed property \\\"\" + key + \"\\\".\", vm);\n      }\n\n      if (!isSSR) {\n        // create internal watcher for the computed property.\n        watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);\n      } // component-defined computed properties are already defined on the\n      // component prototype. We only need to define computed properties defined\n      // at instantiation here.\n\n\n      if (!(key in vm)) {\n        defineComputed(vm, key, userDef);\n      } else {\n        if (key in vm.$data) {\n          warn(\"The computed property \\\"\" + key + \"\\\" is already defined in data.\", vm);\n        } else if (vm.$options.props && key in vm.$options.props) {\n          warn(\"The computed property \\\"\" + key + \"\\\" is already defined as a prop.\", vm);\n        }\n      }\n    }\n  }\n\n  function defineComputed(target, key, userDef) {\n    var shouldCache = !isServerRendering();\n\n    if (typeof userDef === 'function') {\n      sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : createGetterInvoker(userDef);\n      sharedPropertyDefinition.set = noop;\n    } else {\n      sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : createGetterInvoker(userDef.get) : noop;\n      sharedPropertyDefinition.set = userDef.set || noop;\n    }\n\n    if (sharedPropertyDefinition.set === noop) {\n      sharedPropertyDefinition.set = function () {\n        warn(\"Computed property \\\"\" + key + \"\\\" was assigned to but it has no setter.\", this);\n      };\n    }\n\n    Object.defineProperty(target, key, sharedPropertyDefinition);\n  }\n\n  function createComputedGetter(key) {\n    return function computedGetter() {\n      var watcher = this._computedWatchers && this._computedWatchers[key];\n\n      if (watcher) {\n        if (watcher.dirty) {\n          watcher.evaluate();\n        }\n\n        if (Dep.target) {\n          watcher.depend();\n        }\n\n        return watcher.value;\n      }\n    };\n  }\n\n  function createGetterInvoker(fn) {\n    return function computedGetter() {\n      return fn.call(this, this);\n    };\n  }\n\n  function initMethods(vm, methods) {\n    var props = vm.$options.props;\n\n    for (var key in methods) {\n      {\n        if (typeof methods[key] !== 'function') {\n          warn(\"Method \\\"\" + key + \"\\\" has type \\\"\" + _typeof(methods[key]) + \"\\\" in the component definition. \" + \"Did you reference the function correctly?\", vm);\n        }\n\n        if (props && hasOwn(props, key)) {\n          warn(\"Method \\\"\" + key + \"\\\" has already been defined as a prop.\", vm);\n        }\n\n        if (key in vm && isReserved(key)) {\n          warn(\"Method \\\"\" + key + \"\\\" conflicts with an existing Vue instance method. \" + \"Avoid defining component methods that start with _ or $.\");\n        }\n      }\n      vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);\n    }\n  }\n\n  function initWatch(vm, watch) {\n    for (var key in watch) {\n      var handler = watch[key];\n\n      if (Array.isArray(handler)) {\n        for (var i = 0; i < handler.length; i++) {\n          createWatcher(vm, key, handler[i]);\n        }\n      } else {\n        createWatcher(vm, key, handler);\n      }\n    }\n  }\n\n  function createWatcher(vm, expOrFn, handler, options) {\n    if (isPlainObject(handler)) {\n      options = handler;\n      handler = handler.handler;\n    }\n\n    if (typeof handler === 'string') {\n      handler = vm[handler];\n    }\n\n    return vm.$watch(expOrFn, handler, options);\n  }\n\n  function stateMixin(Vue) {\n    // flow somehow has problems with directly declared definition object\n    // when using Object.defineProperty, so we have to procedurally build up\n    // the object here.\n    var dataDef = {};\n\n    dataDef.get = function () {\n      return this._data;\n    };\n\n    var propsDef = {};\n\n    propsDef.get = function () {\n      return this._props;\n    };\n\n    {\n      dataDef.set = function () {\n        warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);\n      };\n\n      propsDef.set = function () {\n        warn(\"$props is readonly.\", this);\n      };\n    }\n    Object.defineProperty(Vue.prototype, '$data', dataDef);\n    Object.defineProperty(Vue.prototype, '$props', propsDef);\n    Vue.prototype.$set = set;\n    Vue.prototype.$delete = del;\n\n    Vue.prototype.$watch = function (expOrFn, cb, options) {\n      var vm = this;\n\n      if (isPlainObject(cb)) {\n        return createWatcher(vm, expOrFn, cb, options);\n      }\n\n      options = options || {};\n      options.user = true;\n      var watcher = new Watcher(vm, expOrFn, cb, options);\n\n      if (options.immediate) {\n        try {\n          cb.call(vm, watcher.value);\n        } catch (error) {\n          handleError(error, vm, \"callback for immediate watcher \\\"\" + watcher.expression + \"\\\"\");\n        }\n      }\n\n      return function unwatchFn() {\n        watcher.teardown();\n      };\n    };\n  }\n  /*  */\n\n\n  var uid$3 = 0;\n\n  function initMixin(Vue) {\n    Vue.prototype._init = function (options) {\n      var vm = this; // a uid\n\n      vm._uid = uid$3++;\n      var startTag, endTag;\n      /* istanbul ignore if */\n\n      if (config.performance && mark) {\n        startTag = \"vue-perf-start:\" + vm._uid;\n        endTag = \"vue-perf-end:\" + vm._uid;\n        mark(startTag);\n      } // a flag to avoid this being observed\n\n\n      vm._isVue = true; // merge options\n\n      if (options && options._isComponent) {\n        // optimize internal component instantiation\n        // since dynamic options merging is pretty slow, and none of the\n        // internal component options needs special treatment.\n        initInternalComponent(vm, options);\n      } else {\n        vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);\n      }\n      /* istanbul ignore else */\n\n\n      {\n        initProxy(vm);\n      } // expose real self\n\n      vm._self = vm;\n      initLifecycle(vm);\n      initEvents(vm);\n      initRender(vm);\n      callHook(vm, 'beforeCreate');\n      initInjections(vm); // resolve injections before data/props\n\n      initState(vm);\n      initProvide(vm); // resolve provide after data/props\n\n      callHook(vm, 'created');\n      /* istanbul ignore if */\n\n      if (config.performance && mark) {\n        vm._name = formatComponentName(vm, false);\n        mark(endTag);\n        measure(\"vue \" + vm._name + \" init\", startTag, endTag);\n      }\n\n      if (vm.$options.el) {\n        vm.$mount(vm.$options.el);\n      }\n    };\n  }\n\n  function initInternalComponent(vm, options) {\n    var opts = vm.$options = Object.create(vm.constructor.options); // doing this because it's faster than dynamic enumeration.\n\n    var parentVnode = options._parentVnode;\n    opts.parent = options.parent;\n    opts._parentVnode = parentVnode;\n    var vnodeComponentOptions = parentVnode.componentOptions;\n    opts.propsData = vnodeComponentOptions.propsData;\n    opts._parentListeners = vnodeComponentOptions.listeners;\n    opts._renderChildren = vnodeComponentOptions.children;\n    opts._componentTag = vnodeComponentOptions.tag;\n\n    if (options.render) {\n      opts.render = options.render;\n      opts.staticRenderFns = options.staticRenderFns;\n    }\n  }\n\n  function resolveConstructorOptions(Ctor) {\n    var options = Ctor.options;\n\n    if (Ctor.super) {\n      var superOptions = resolveConstructorOptions(Ctor.super);\n      var cachedSuperOptions = Ctor.superOptions;\n\n      if (superOptions !== cachedSuperOptions) {\n        // super option changed,\n        // need to resolve new options.\n        Ctor.superOptions = superOptions; // check if there are any late-modified/attached options (#4976)\n\n        var modifiedOptions = resolveModifiedOptions(Ctor); // update base extend options\n\n        if (modifiedOptions) {\n          extend(Ctor.extendOptions, modifiedOptions);\n        }\n\n        options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n\n        if (options.name) {\n          options.components[options.name] = Ctor;\n        }\n      }\n    }\n\n    return options;\n  }\n\n  function resolveModifiedOptions(Ctor) {\n    var modified;\n    var latest = Ctor.options;\n    var sealed = Ctor.sealedOptions;\n\n    for (var key in latest) {\n      if (latest[key] !== sealed[key]) {\n        if (!modified) {\n          modified = {};\n        }\n\n        modified[key] = latest[key];\n      }\n    }\n\n    return modified;\n  }\n\n  function Vue(options) {\n    if (!(this instanceof Vue)) {\n      warn('Vue is a constructor and should be called with the `new` keyword');\n    }\n\n    this._init(options);\n  }\n\n  initMixin(Vue);\n  stateMixin(Vue);\n  eventsMixin(Vue);\n  lifecycleMixin(Vue);\n  renderMixin(Vue);\n  /*  */\n\n  function initUse(Vue) {\n    Vue.use = function (plugin) {\n      var installedPlugins = this._installedPlugins || (this._installedPlugins = []);\n\n      if (installedPlugins.indexOf(plugin) > -1) {\n        return this;\n      } // additional parameters\n\n\n      var args = toArray(arguments, 1);\n      args.unshift(this);\n\n      if (typeof plugin.install === 'function') {\n        plugin.install.apply(plugin, args);\n      } else if (typeof plugin === 'function') {\n        plugin.apply(null, args);\n      }\n\n      installedPlugins.push(plugin);\n      return this;\n    };\n  }\n  /*  */\n\n\n  function initMixin$1(Vue) {\n    Vue.mixin = function (mixin) {\n      this.options = mergeOptions(this.options, mixin);\n      return this;\n    };\n  }\n  /*  */\n\n\n  function initExtend(Vue) {\n    /**\n     * Each instance constructor, including Vue, has a unique\n     * cid. This enables us to create wrapped \"child\n     * constructors\" for prototypal inheritance and cache them.\n     */\n    Vue.cid = 0;\n    var cid = 1;\n    /**\n     * Class inheritance\n     */\n\n    Vue.extend = function (extendOptions) {\n      extendOptions = extendOptions || {};\n      var Super = this;\n      var SuperId = Super.cid;\n      var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n\n      if (cachedCtors[SuperId]) {\n        return cachedCtors[SuperId];\n      }\n\n      var name = extendOptions.name || Super.options.name;\n\n      if (name) {\n        validateComponentName(name);\n      }\n\n      var Sub = function VueComponent(options) {\n        this._init(options);\n      };\n\n      Sub.prototype = Object.create(Super.prototype);\n      Sub.prototype.constructor = Sub;\n      Sub.cid = cid++;\n      Sub.options = mergeOptions(Super.options, extendOptions);\n      Sub['super'] = Super; // For props and computed properties, we define the proxy getters on\n      // the Vue instances at extension time, on the extended prototype. This\n      // avoids Object.defineProperty calls for each instance created.\n\n      if (Sub.options.props) {\n        initProps$1(Sub);\n      }\n\n      if (Sub.options.computed) {\n        initComputed$1(Sub);\n      } // allow further extension/mixin/plugin usage\n\n\n      Sub.extend = Super.extend;\n      Sub.mixin = Super.mixin;\n      Sub.use = Super.use; // create asset registers, so extended classes\n      // can have their private assets too.\n\n      ASSET_TYPES.forEach(function (type) {\n        Sub[type] = Super[type];\n      }); // enable recursive self-lookup\n\n      if (name) {\n        Sub.options.components[name] = Sub;\n      } // keep a reference to the super options at extension time.\n      // later at instantiation we can check if Super's options have\n      // been updated.\n\n\n      Sub.superOptions = Super.options;\n      Sub.extendOptions = extendOptions;\n      Sub.sealedOptions = extend({}, Sub.options); // cache constructor\n\n      cachedCtors[SuperId] = Sub;\n      return Sub;\n    };\n  }\n\n  function initProps$1(Comp) {\n    var props = Comp.options.props;\n\n    for (var key in props) {\n      proxy(Comp.prototype, \"_props\", key);\n    }\n  }\n\n  function initComputed$1(Comp) {\n    var computed = Comp.options.computed;\n\n    for (var key in computed) {\n      defineComputed(Comp.prototype, key, computed[key]);\n    }\n  }\n  /*  */\n\n\n  function initAssetRegisters(Vue) {\n    /**\n     * Create asset registration methods.\n     */\n    ASSET_TYPES.forEach(function (type) {\n      Vue[type] = function (id, definition) {\n        if (!definition) {\n          return this.options[type + 's'][id];\n        } else {\n          /* istanbul ignore if */\n          if (type === 'component') {\n            validateComponentName(id);\n          }\n\n          if (type === 'component' && isPlainObject(definition)) {\n            definition.name = definition.name || id;\n            definition = this.options._base.extend(definition);\n          }\n\n          if (type === 'directive' && typeof definition === 'function') {\n            definition = {\n              bind: definition,\n              update: definition\n            };\n          }\n\n          this.options[type + 's'][id] = definition;\n          return definition;\n        }\n      };\n    });\n  }\n  /*  */\n\n\n  function getComponentName(opts) {\n    return opts && (opts.Ctor.options.name || opts.tag);\n  }\n\n  function matches(pattern, name) {\n    if (Array.isArray(pattern)) {\n      return pattern.indexOf(name) > -1;\n    } else if (typeof pattern === 'string') {\n      return pattern.split(',').indexOf(name) > -1;\n    } else if (isRegExp(pattern)) {\n      return pattern.test(name);\n    }\n    /* istanbul ignore next */\n\n\n    return false;\n  }\n\n  function pruneCache(keepAliveInstance, filter) {\n    var cache = keepAliveInstance.cache;\n    var keys = keepAliveInstance.keys;\n    var _vnode = keepAliveInstance._vnode;\n\n    for (var key in cache) {\n      var cachedNode = cache[key];\n\n      if (cachedNode) {\n        var name = getComponentName(cachedNode.componentOptions);\n\n        if (name && !filter(name)) {\n          pruneCacheEntry(cache, key, keys, _vnode);\n        }\n      }\n    }\n  }\n\n  function pruneCacheEntry(cache, key, keys, current) {\n    var cached$$1 = cache[key];\n\n    if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {\n      cached$$1.componentInstance.$destroy();\n    }\n\n    cache[key] = null;\n    remove(keys, key);\n  }\n\n  var patternTypes = [String, RegExp, Array];\n  var KeepAlive = {\n    name: 'keep-alive',\n    abstract: true,\n    props: {\n      include: patternTypes,\n      exclude: patternTypes,\n      max: [String, Number]\n    },\n    created: function created() {\n      this.cache = Object.create(null);\n      this.keys = [];\n    },\n    destroyed: function destroyed() {\n      for (var key in this.cache) {\n        pruneCacheEntry(this.cache, key, this.keys);\n      }\n    },\n    mounted: function mounted() {\n      var this$1 = this;\n      this.$watch('include', function (val) {\n        pruneCache(this$1, function (name) {\n          return matches(val, name);\n        });\n      });\n      this.$watch('exclude', function (val) {\n        pruneCache(this$1, function (name) {\n          return !matches(val, name);\n        });\n      });\n    },\n    render: function render() {\n      var slot = this.$slots.default;\n      var vnode = getFirstComponentChild(slot);\n      var componentOptions = vnode && vnode.componentOptions;\n\n      if (componentOptions) {\n        // check pattern\n        var name = getComponentName(componentOptions);\n        var ref = this;\n        var include = ref.include;\n        var exclude = ref.exclude;\n\n        if ( // not included\n        include && (!name || !matches(include, name)) || // excluded\n        exclude && name && matches(exclude, name)) {\n          return vnode;\n        }\n\n        var ref$1 = this;\n        var cache = ref$1.cache;\n        var keys = ref$1.keys;\n        var key = vnode.key == null // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? \"::\" + componentOptions.tag : '') : vnode.key;\n\n        if (cache[key]) {\n          vnode.componentInstance = cache[key].componentInstance; // make current key freshest\n\n          remove(keys, key);\n          keys.push(key);\n        } else {\n          cache[key] = vnode;\n          keys.push(key); // prune oldest entry\n\n          if (this.max && keys.length > parseInt(this.max)) {\n            pruneCacheEntry(cache, keys[0], keys, this._vnode);\n          }\n        }\n\n        vnode.data.keepAlive = true;\n      }\n\n      return vnode || slot && slot[0];\n    }\n  };\n  var builtInComponents = {\n    KeepAlive: KeepAlive\n  };\n  /*  */\n\n  function initGlobalAPI(Vue) {\n    // config\n    var configDef = {};\n\n    configDef.get = function () {\n      return config;\n    };\n\n    {\n      configDef.set = function () {\n        warn('Do not replace the Vue.config object, set individual fields instead.');\n      };\n    }\n    Object.defineProperty(Vue, 'config', configDef); // exposed util methods.\n    // NOTE: these are not considered part of the public API - avoid relying on\n    // them unless you are aware of the risk.\n\n    Vue.util = {\n      warn: warn,\n      extend: extend,\n      mergeOptions: mergeOptions,\n      defineReactive: defineReactive$$1\n    };\n    Vue.set = set;\n    Vue.delete = del;\n    Vue.nextTick = nextTick; // 2.6 explicit observable API\n\n    Vue.observable = function (obj) {\n      observe(obj);\n      return obj;\n    };\n\n    Vue.options = Object.create(null);\n    ASSET_TYPES.forEach(function (type) {\n      Vue.options[type + 's'] = Object.create(null);\n    }); // this is used to identify the \"base\" constructor to extend all plain-object\n    // components with in Weex's multi-instance scenarios.\n\n    Vue.options._base = Vue;\n    extend(Vue.options.components, builtInComponents);\n    initUse(Vue);\n    initMixin$1(Vue);\n    initExtend(Vue);\n    initAssetRegisters(Vue);\n  }\n\n  initGlobalAPI(Vue);\n  Object.defineProperty(Vue.prototype, '$isServer', {\n    get: isServerRendering\n  });\n  Object.defineProperty(Vue.prototype, '$ssrContext', {\n    get: function get() {\n      /* istanbul ignore next */\n      return this.$vnode && this.$vnode.ssrContext;\n    }\n  }); // expose FunctionalRenderContext for ssr runtime helper installation\n\n  Object.defineProperty(Vue, 'FunctionalRenderContext', {\n    value: FunctionalRenderContext\n  });\n  Vue.version = '2.6.10';\n  /*  */\n  // these are reserved for web because they are directly compiled away\n  // during template compilation\n\n  var isReservedAttr = makeMap('style,class'); // attributes that should be using props for binding\n\n  var acceptValue = makeMap('input,textarea,option,select,progress');\n\n  var mustUseProp = function mustUseProp(tag, type, attr) {\n    return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';\n  };\n\n  var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n  var isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');\n\n  var convertEnumeratedValue = function convertEnumeratedValue(key, value) {\n    return isFalsyAttrValue(value) || value === 'false' ? 'false' // allow arbitrary string value for contenteditable\n    : key === 'contenteditable' && isValidContentEditableValue(value) ? value : 'true';\n  };\n\n  var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');\n  var xlinkNS = 'http://www.w3.org/1999/xlink';\n\n  var isXlink = function isXlink(name) {\n    return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';\n  };\n\n  var getXlinkProp = function getXlinkProp(name) {\n    return isXlink(name) ? name.slice(6, name.length) : '';\n  };\n\n  var isFalsyAttrValue = function isFalsyAttrValue(val) {\n    return val == null || val === false;\n  };\n  /*  */\n\n\n  function genClassForVnode(vnode) {\n    var data = vnode.data;\n    var parentNode = vnode;\n    var childNode = vnode;\n\n    while (isDef(childNode.componentInstance)) {\n      childNode = childNode.componentInstance._vnode;\n\n      if (childNode && childNode.data) {\n        data = mergeClassData(childNode.data, data);\n      }\n    }\n\n    while (isDef(parentNode = parentNode.parent)) {\n      if (parentNode && parentNode.data) {\n        data = mergeClassData(data, parentNode.data);\n      }\n    }\n\n    return renderClass(data.staticClass, data.class);\n  }\n\n  function mergeClassData(child, parent) {\n    return {\n      staticClass: concat(child.staticClass, parent.staticClass),\n      class: isDef(child.class) ? [child.class, parent.class] : parent.class\n    };\n  }\n\n  function renderClass(staticClass, dynamicClass) {\n    if (isDef(staticClass) || isDef(dynamicClass)) {\n      return concat(staticClass, stringifyClass(dynamicClass));\n    }\n    /* istanbul ignore next */\n\n\n    return '';\n  }\n\n  function concat(a, b) {\n    return a ? b ? a + ' ' + b : a : b || '';\n  }\n\n  function stringifyClass(value) {\n    if (Array.isArray(value)) {\n      return stringifyArray(value);\n    }\n\n    if (isObject(value)) {\n      return stringifyObject(value);\n    }\n\n    if (typeof value === 'string') {\n      return value;\n    }\n    /* istanbul ignore next */\n\n\n    return '';\n  }\n\n  function stringifyArray(value) {\n    var res = '';\n    var stringified;\n\n    for (var i = 0, l = value.length; i < l; i++) {\n      if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n        if (res) {\n          res += ' ';\n        }\n\n        res += stringified;\n      }\n    }\n\n    return res;\n  }\n\n  function stringifyObject(value) {\n    var res = '';\n\n    for (var key in value) {\n      if (value[key]) {\n        if (res) {\n          res += ' ';\n        }\n\n        res += key;\n      }\n    }\n\n    return res;\n  }\n  /*  */\n\n\n  var namespaceMap = {\n    svg: 'http://www.w3.org/2000/svg',\n    math: 'http://www.w3.org/1998/Math/MathML'\n  };\n  var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot'); // this map is intentionally selective, only covering SVG elements that may\n  // contain child elements.\n\n  var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);\n\n  var isPreTag = function isPreTag(tag) {\n    return tag === 'pre';\n  };\n\n  var isReservedTag = function isReservedTag(tag) {\n    return isHTMLTag(tag) || isSVG(tag);\n  };\n\n  function getTagNamespace(tag) {\n    if (isSVG(tag)) {\n      return 'svg';\n    } // basic support for MathML\n    // note it doesn't support other MathML elements being component roots\n\n\n    if (tag === 'math') {\n      return 'math';\n    }\n  }\n\n  var unknownElementCache = Object.create(null);\n\n  function isUnknownElement(tag) {\n    /* istanbul ignore if */\n    if (!inBrowser) {\n      return true;\n    }\n\n    if (isReservedTag(tag)) {\n      return false;\n    }\n\n    tag = tag.toLowerCase();\n    /* istanbul ignore if */\n\n    if (unknownElementCache[tag] != null) {\n      return unknownElementCache[tag];\n    }\n\n    var el = document.createElement(tag);\n\n    if (tag.indexOf('-') > -1) {\n      // http://stackoverflow.com/a/28210364/1070244\n      return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;\n    } else {\n      return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());\n    }\n  }\n\n  var isTextInputType = makeMap('text,number,password,search,email,tel,url');\n  /*  */\n\n  /**\n   * Query an element selector if it's not an element already.\n   */\n\n  function query(el) {\n    if (typeof el === 'string') {\n      var selected = document.querySelector(el);\n\n      if (!selected) {\n        warn('Cannot find element: ' + el);\n        return document.createElement('div');\n      }\n\n      return selected;\n    } else {\n      return el;\n    }\n  }\n  /*  */\n\n\n  function createElement$1(tagName, vnode) {\n    var elm = document.createElement(tagName);\n\n    if (tagName !== 'select') {\n      return elm;\n    } // false or null will remove the attribute but undefined will not\n\n\n    if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n      elm.setAttribute('multiple', 'multiple');\n    }\n\n    return elm;\n  }\n\n  function createElementNS(namespace, tagName) {\n    return document.createElementNS(namespaceMap[namespace], tagName);\n  }\n\n  function createTextNode(text) {\n    return document.createTextNode(text);\n  }\n\n  function createComment(text) {\n    return document.createComment(text);\n  }\n\n  function insertBefore(parentNode, newNode, referenceNode) {\n    parentNode.insertBefore(newNode, referenceNode);\n  }\n\n  function removeChild(node, child) {\n    node.removeChild(child);\n  }\n\n  function appendChild(node, child) {\n    node.appendChild(child);\n  }\n\n  function parentNode(node) {\n    return node.parentNode;\n  }\n\n  function nextSibling(node) {\n    return node.nextSibling;\n  }\n\n  function tagName(node) {\n    return node.tagName;\n  }\n\n  function setTextContent(node, text) {\n    node.textContent = text;\n  }\n\n  function setStyleScope(node, scopeId) {\n    node.setAttribute(scopeId, '');\n  }\n\n  var nodeOps =\n  /*#__PURE__*/\n  Object.freeze({\n    createElement: createElement$1,\n    createElementNS: createElementNS,\n    createTextNode: createTextNode,\n    createComment: createComment,\n    insertBefore: insertBefore,\n    removeChild: removeChild,\n    appendChild: appendChild,\n    parentNode: parentNode,\n    nextSibling: nextSibling,\n    tagName: tagName,\n    setTextContent: setTextContent,\n    setStyleScope: setStyleScope\n  });\n  /*  */\n\n  var ref = {\n    create: function create(_, vnode) {\n      registerRef(vnode);\n    },\n    update: function update(oldVnode, vnode) {\n      if (oldVnode.data.ref !== vnode.data.ref) {\n        registerRef(oldVnode, true);\n        registerRef(vnode);\n      }\n    },\n    destroy: function destroy(vnode) {\n      registerRef(vnode, true);\n    }\n  };\n\n  function registerRef(vnode, isRemoval) {\n    var key = vnode.data.ref;\n\n    if (!isDef(key)) {\n      return;\n    }\n\n    var vm = vnode.context;\n    var ref = vnode.componentInstance || vnode.elm;\n    var refs = vm.$refs;\n\n    if (isRemoval) {\n      if (Array.isArray(refs[key])) {\n        remove(refs[key], ref);\n      } else if (refs[key] === ref) {\n        refs[key] = undefined;\n      }\n    } else {\n      if (vnode.data.refInFor) {\n        if (!Array.isArray(refs[key])) {\n          refs[key] = [ref];\n        } else if (refs[key].indexOf(ref) < 0) {\n          // $flow-disable-line\n          refs[key].push(ref);\n        }\n      } else {\n        refs[key] = ref;\n      }\n    }\n  }\n  /**\n   * Virtual DOM patching algorithm based on Snabbdom by\n   * Simon Friis Vindum (@paldepind)\n   * Licensed under the MIT License\n   * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n   *\n   * modified by Evan You (@yyx990803)\n   *\n   * Not type-checking this because this file is perf-critical and the cost\n   * of making flow understand it is not worth it.\n   */\n\n\n  var emptyNode = new VNode('', {}, []);\n  var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\n  function sameVnode(a, b) {\n    return a.key === b.key && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && a.asyncFactory === b.asyncFactory && isUndef(b.asyncFactory.error));\n  }\n\n  function sameInputType(a, b) {\n    if (a.tag !== 'input') {\n      return true;\n    }\n\n    var i;\n    var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n    var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n    return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);\n  }\n\n  function createKeyToOldIdx(children, beginIdx, endIdx) {\n    var i, key;\n    var map = {};\n\n    for (i = beginIdx; i <= endIdx; ++i) {\n      key = children[i].key;\n\n      if (isDef(key)) {\n        map[key] = i;\n      }\n    }\n\n    return map;\n  }\n\n  function createPatchFunction(backend) {\n    var i, j;\n    var cbs = {};\n    var modules = backend.modules;\n    var nodeOps = backend.nodeOps;\n\n    for (i = 0; i < hooks.length; ++i) {\n      cbs[hooks[i]] = [];\n\n      for (j = 0; j < modules.length; ++j) {\n        if (isDef(modules[j][hooks[i]])) {\n          cbs[hooks[i]].push(modules[j][hooks[i]]);\n        }\n      }\n    }\n\n    function emptyNodeAt(elm) {\n      return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);\n    }\n\n    function createRmCb(childElm, listeners) {\n      function remove$$1() {\n        if (--remove$$1.listeners === 0) {\n          removeNode(childElm);\n        }\n      }\n\n      remove$$1.listeners = listeners;\n      return remove$$1;\n    }\n\n    function removeNode(el) {\n      var parent = nodeOps.parentNode(el); // element may have already been removed due to v-html / v-text\n\n      if (isDef(parent)) {\n        nodeOps.removeChild(parent, el);\n      }\n    }\n\n    function isUnknownElement$$1(vnode, inVPre) {\n      return !inVPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.some(function (ignore) {\n        return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag;\n      })) && config.isUnknownElement(vnode.tag);\n    }\n\n    var creatingElmInVPre = 0;\n\n    function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {\n      if (isDef(vnode.elm) && isDef(ownerArray)) {\n        // This vnode was used in a previous render!\n        // now it's used as a new node, overwriting its elm would cause\n        // potential patch errors down the road when it's used as an insertion\n        // reference node. Instead, we clone the node on-demand before creating\n        // associated DOM element for it.\n        vnode = ownerArray[index] = cloneVNode(vnode);\n      }\n\n      vnode.isRootInsert = !nested; // for transition enter check\n\n      if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n        return;\n      }\n\n      var data = vnode.data;\n      var children = vnode.children;\n      var tag = vnode.tag;\n\n      if (isDef(tag)) {\n        {\n          if (data && data.pre) {\n            creatingElmInVPre++;\n          }\n\n          if (isUnknownElement$$1(vnode, creatingElmInVPre)) {\n            warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the \"name\" option.', vnode.context);\n          }\n        }\n        vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);\n        setScope(vnode);\n        /* istanbul ignore if */\n\n        {\n          createChildren(vnode, children, insertedVnodeQueue);\n\n          if (isDef(data)) {\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n          }\n\n          insert(parentElm, vnode.elm, refElm);\n        }\n\n        if (data && data.pre) {\n          creatingElmInVPre--;\n        }\n      } else if (isTrue(vnode.isComment)) {\n        vnode.elm = nodeOps.createComment(vnode.text);\n        insert(parentElm, vnode.elm, refElm);\n      } else {\n        vnode.elm = nodeOps.createTextNode(vnode.text);\n        insert(parentElm, vnode.elm, refElm);\n      }\n    }\n\n    function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\n      var i = vnode.data;\n\n      if (isDef(i)) {\n        var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n\n        if (isDef(i = i.hook) && isDef(i = i.init)) {\n          i(vnode, false\n          /* hydrating */\n          );\n        } // after calling the init hook, if the vnode is a child component\n        // it should've created a child instance and mounted it. the child\n        // component also has set the placeholder vnode's elm.\n        // in that case we can just return the element and be done.\n\n\n        if (isDef(vnode.componentInstance)) {\n          initComponent(vnode, insertedVnodeQueue);\n          insert(parentElm, vnode.elm, refElm);\n\n          if (isTrue(isReactivated)) {\n            reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n          }\n\n          return true;\n        }\n      }\n    }\n\n    function initComponent(vnode, insertedVnodeQueue) {\n      if (isDef(vnode.data.pendingInsert)) {\n        insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n        vnode.data.pendingInsert = null;\n      }\n\n      vnode.elm = vnode.componentInstance.$el;\n\n      if (isPatchable(vnode)) {\n        invokeCreateHooks(vnode, insertedVnodeQueue);\n        setScope(vnode);\n      } else {\n        // empty component root.\n        // skip all element-related modules except for ref (#3455)\n        registerRef(vnode); // make sure to invoke the insert hook\n\n        insertedVnodeQueue.push(vnode);\n      }\n    }\n\n    function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\n      var i; // hack for #4339: a reactivated component with inner transition\n      // does not trigger because the inner node's created hooks are not called\n      // again. It's not ideal to involve module-specific logic in here but\n      // there doesn't seem to be a better way to do it.\n\n      var innerNode = vnode;\n\n      while (innerNode.componentInstance) {\n        innerNode = innerNode.componentInstance._vnode;\n\n        if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n          for (i = 0; i < cbs.activate.length; ++i) {\n            cbs.activate[i](emptyNode, innerNode);\n          }\n\n          insertedVnodeQueue.push(innerNode);\n          break;\n        }\n      } // unlike a newly created component,\n      // a reactivated keep-alive component doesn't insert itself\n\n\n      insert(parentElm, vnode.elm, refElm);\n    }\n\n    function insert(parent, elm, ref$$1) {\n      if (isDef(parent)) {\n        if (isDef(ref$$1)) {\n          if (nodeOps.parentNode(ref$$1) === parent) {\n            nodeOps.insertBefore(parent, elm, ref$$1);\n          }\n        } else {\n          nodeOps.appendChild(parent, elm);\n        }\n      }\n    }\n\n    function createChildren(vnode, children, insertedVnodeQueue) {\n      if (Array.isArray(children)) {\n        {\n          checkDuplicateKeys(children);\n        }\n\n        for (var i = 0; i < children.length; ++i) {\n          createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);\n        }\n      } else if (isPrimitive(vnode.text)) {\n        nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));\n      }\n    }\n\n    function isPatchable(vnode) {\n      while (vnode.componentInstance) {\n        vnode = vnode.componentInstance._vnode;\n      }\n\n      return isDef(vnode.tag);\n    }\n\n    function invokeCreateHooks(vnode, insertedVnodeQueue) {\n      for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n        cbs.create[i$1](emptyNode, vnode);\n      }\n\n      i = vnode.data.hook; // Reuse variable\n\n      if (isDef(i)) {\n        if (isDef(i.create)) {\n          i.create(emptyNode, vnode);\n        }\n\n        if (isDef(i.insert)) {\n          insertedVnodeQueue.push(vnode);\n        }\n      }\n    } // set scope id attribute for scoped CSS.\n    // this is implemented as a special case to avoid the overhead\n    // of going through the normal attribute patching process.\n\n\n    function setScope(vnode) {\n      var i;\n\n      if (isDef(i = vnode.fnScopeId)) {\n        nodeOps.setStyleScope(vnode.elm, i);\n      } else {\n        var ancestor = vnode;\n\n        while (ancestor) {\n          if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n            nodeOps.setStyleScope(vnode.elm, i);\n          }\n\n          ancestor = ancestor.parent;\n        }\n      } // for slot content they should also get the scopeId from the host instance.\n\n\n      if (isDef(i = activeInstance) && i !== vnode.context && i !== vnode.fnContext && isDef(i = i.$options._scopeId)) {\n        nodeOps.setStyleScope(vnode.elm, i);\n      }\n    }\n\n    function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n      for (; startIdx <= endIdx; ++startIdx) {\n        createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);\n      }\n    }\n\n    function invokeDestroyHook(vnode) {\n      var i, j;\n      var data = vnode.data;\n\n      if (isDef(data)) {\n        if (isDef(i = data.hook) && isDef(i = i.destroy)) {\n          i(vnode);\n        }\n\n        for (i = 0; i < cbs.destroy.length; ++i) {\n          cbs.destroy[i](vnode);\n        }\n      }\n\n      if (isDef(i = vnode.children)) {\n        for (j = 0; j < vnode.children.length; ++j) {\n          invokeDestroyHook(vnode.children[j]);\n        }\n      }\n    }\n\n    function removeVnodes(parentElm, vnodes, startIdx, endIdx) {\n      for (; startIdx <= endIdx; ++startIdx) {\n        var ch = vnodes[startIdx];\n\n        if (isDef(ch)) {\n          if (isDef(ch.tag)) {\n            removeAndInvokeRemoveHook(ch);\n            invokeDestroyHook(ch);\n          } else {\n            // Text node\n            removeNode(ch.elm);\n          }\n        }\n      }\n    }\n\n    function removeAndInvokeRemoveHook(vnode, rm) {\n      if (isDef(rm) || isDef(vnode.data)) {\n        var i;\n        var listeners = cbs.remove.length + 1;\n\n        if (isDef(rm)) {\n          // we have a recursively passed down rm callback\n          // increase the listeners count\n          rm.listeners += listeners;\n        } else {\n          // directly removing\n          rm = createRmCb(vnode.elm, listeners);\n        } // recursively invoke hooks on child component root node\n\n\n        if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n          removeAndInvokeRemoveHook(i, rm);\n        }\n\n        for (i = 0; i < cbs.remove.length; ++i) {\n          cbs.remove[i](vnode, rm);\n        }\n\n        if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n          i(vnode, rm);\n        } else {\n          rm();\n        }\n      } else {\n        removeNode(vnode.elm);\n      }\n    }\n\n    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n      var oldStartIdx = 0;\n      var newStartIdx = 0;\n      var oldEndIdx = oldCh.length - 1;\n      var oldStartVnode = oldCh[0];\n      var oldEndVnode = oldCh[oldEndIdx];\n      var newEndIdx = newCh.length - 1;\n      var newStartVnode = newCh[0];\n      var newEndVnode = newCh[newEndIdx];\n      var oldKeyToIdx, idxInOld, vnodeToMove, refElm; // removeOnly is a special flag used only by <transition-group>\n      // to ensure removed elements stay in correct relative positions\n      // during leaving transitions\n\n      var canMove = !removeOnly;\n      {\n        checkDuplicateKeys(newCh);\n      }\n\n      while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n        if (isUndef(oldStartVnode)) {\n          oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n        } else if (isUndef(oldEndVnode)) {\n          oldEndVnode = oldCh[--oldEndIdx];\n        } else if (sameVnode(oldStartVnode, newStartVnode)) {\n          patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n          oldStartVnode = oldCh[++oldStartIdx];\n          newStartVnode = newCh[++newStartIdx];\n        } else if (sameVnode(oldEndVnode, newEndVnode)) {\n          patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n          oldEndVnode = oldCh[--oldEndIdx];\n          newEndVnode = newCh[--newEndIdx];\n        } else if (sameVnode(oldStartVnode, newEndVnode)) {\n          // Vnode moved right\n          patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n          canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n          oldStartVnode = oldCh[++oldStartIdx];\n          newEndVnode = newCh[--newEndIdx];\n        } else if (sameVnode(oldEndVnode, newStartVnode)) {\n          // Vnode moved left\n          patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n          canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n          oldEndVnode = oldCh[--oldEndIdx];\n          newStartVnode = newCh[++newStartIdx];\n        } else {\n          if (isUndef(oldKeyToIdx)) {\n            oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n          }\n\n          idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\n\n          if (isUndef(idxInOld)) {\n            // New element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n          } else {\n            vnodeToMove = oldCh[idxInOld];\n\n            if (sameVnode(vnodeToMove, newStartVnode)) {\n              patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n              oldCh[idxInOld] = undefined;\n              canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);\n            } else {\n              // same key but different element. treat as new element\n              createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n            }\n          }\n\n          newStartVnode = newCh[++newStartIdx];\n        }\n      }\n\n      if (oldStartIdx > oldEndIdx) {\n        refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n        addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n      } else if (newStartIdx > newEndIdx) {\n        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n      }\n    }\n\n    function checkDuplicateKeys(children) {\n      var seenKeys = {};\n\n      for (var i = 0; i < children.length; i++) {\n        var vnode = children[i];\n        var key = vnode.key;\n\n        if (isDef(key)) {\n          if (seenKeys[key]) {\n            warn(\"Duplicate keys detected: '\" + key + \"'. This may cause an update error.\", vnode.context);\n          } else {\n            seenKeys[key] = true;\n          }\n        }\n      }\n    }\n\n    function findIdxInOld(node, oldCh, start, end) {\n      for (var i = start; i < end; i++) {\n        var c = oldCh[i];\n\n        if (isDef(c) && sameVnode(node, c)) {\n          return i;\n        }\n      }\n    }\n\n    function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) {\n      if (oldVnode === vnode) {\n        return;\n      }\n\n      if (isDef(vnode.elm) && isDef(ownerArray)) {\n        // clone reused vnode\n        vnode = ownerArray[index] = cloneVNode(vnode);\n      }\n\n      var elm = vnode.elm = oldVnode.elm;\n\n      if (isTrue(oldVnode.isAsyncPlaceholder)) {\n        if (isDef(vnode.asyncFactory.resolved)) {\n          hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\n        } else {\n          vnode.isAsyncPlaceholder = true;\n        }\n\n        return;\n      } // reuse element for static trees.\n      // note we only do this if the vnode is cloned -\n      // if the new node is not cloned it means the render functions have been\n      // reset by the hot-reload-api and we need to do a proper re-render.\n\n\n      if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {\n        vnode.componentInstance = oldVnode.componentInstance;\n        return;\n      }\n\n      var i;\n      var data = vnode.data;\n\n      if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n        i(oldVnode, vnode);\n      }\n\n      var oldCh = oldVnode.children;\n      var ch = vnode.children;\n\n      if (isDef(data) && isPatchable(vnode)) {\n        for (i = 0; i < cbs.update.length; ++i) {\n          cbs.update[i](oldVnode, vnode);\n        }\n\n        if (isDef(i = data.hook) && isDef(i = i.update)) {\n          i(oldVnode, vnode);\n        }\n      }\n\n      if (isUndef(vnode.text)) {\n        if (isDef(oldCh) && isDef(ch)) {\n          if (oldCh !== ch) {\n            updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);\n          }\n        } else if (isDef(ch)) {\n          {\n            checkDuplicateKeys(ch);\n          }\n\n          if (isDef(oldVnode.text)) {\n            nodeOps.setTextContent(elm, '');\n          }\n\n          addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n        } else if (isDef(oldCh)) {\n          removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n        } else if (isDef(oldVnode.text)) {\n          nodeOps.setTextContent(elm, '');\n        }\n      } else if (oldVnode.text !== vnode.text) {\n        nodeOps.setTextContent(elm, vnode.text);\n      }\n\n      if (isDef(data)) {\n        if (isDef(i = data.hook) && isDef(i = i.postpatch)) {\n          i(oldVnode, vnode);\n        }\n      }\n    }\n\n    function invokeInsertHook(vnode, queue, initial) {\n      // delay insert hooks for component root nodes, invoke them after the\n      // element is really inserted\n      if (isTrue(initial) && isDef(vnode.parent)) {\n        vnode.parent.data.pendingInsert = queue;\n      } else {\n        for (var i = 0; i < queue.length; ++i) {\n          queue[i].data.hook.insert(queue[i]);\n        }\n      }\n    }\n\n    var hydrationBailed = false; // list of modules that can skip create hook during hydration because they\n    // are already rendered on the client or has no need for initialization\n    // Note: style is excluded because it relies on initial clone for future\n    // deep updates (#7063).\n\n    var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key'); // Note: this is a browser-only function so we can assume elms are DOM nodes.\n\n    function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {\n      var i;\n      var tag = vnode.tag;\n      var data = vnode.data;\n      var children = vnode.children;\n      inVPre = inVPre || data && data.pre;\n      vnode.elm = elm;\n\n      if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\n        vnode.isAsyncPlaceholder = true;\n        return true;\n      } // assert node match\n\n\n      {\n        if (!assertNodeMatch(elm, vnode, inVPre)) {\n          return false;\n        }\n      }\n\n      if (isDef(data)) {\n        if (isDef(i = data.hook) && isDef(i = i.init)) {\n          i(vnode, true\n          /* hydrating */\n          );\n        }\n\n        if (isDef(i = vnode.componentInstance)) {\n          // child component. it should have hydrated its own tree.\n          initComponent(vnode, insertedVnodeQueue);\n          return true;\n        }\n      }\n\n      if (isDef(tag)) {\n        if (isDef(children)) {\n          // empty element, allow client to pick up and populate children\n          if (!elm.hasChildNodes()) {\n            createChildren(vnode, children, insertedVnodeQueue);\n          } else {\n            // v-html and domProps: innerHTML\n            if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {\n              if (i !== elm.innerHTML) {\n                /* istanbul ignore if */\n                if (typeof console !== 'undefined' && !hydrationBailed) {\n                  hydrationBailed = true;\n                  console.warn('Parent: ', elm);\n                  console.warn('server innerHTML: ', i);\n                  console.warn('client innerHTML: ', elm.innerHTML);\n                }\n\n                return false;\n              }\n            } else {\n              // iterate and compare children lists\n              var childrenMatch = true;\n              var childNode = elm.firstChild;\n\n              for (var i$1 = 0; i$1 < children.length; i$1++) {\n                if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {\n                  childrenMatch = false;\n                  break;\n                }\n\n                childNode = childNode.nextSibling;\n              } // if childNode is not null, it means the actual childNodes list is\n              // longer than the virtual children list.\n\n\n              if (!childrenMatch || childNode) {\n                /* istanbul ignore if */\n                if (typeof console !== 'undefined' && !hydrationBailed) {\n                  hydrationBailed = true;\n                  console.warn('Parent: ', elm);\n                  console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n                }\n\n                return false;\n              }\n            }\n          }\n        }\n\n        if (isDef(data)) {\n          var fullInvoke = false;\n\n          for (var key in data) {\n            if (!isRenderedModule(key)) {\n              fullInvoke = true;\n              invokeCreateHooks(vnode, insertedVnodeQueue);\n              break;\n            }\n          }\n\n          if (!fullInvoke && data['class']) {\n            // ensure collecting deps for deep class bindings for future updates\n            traverse(data['class']);\n          }\n        }\n      } else if (elm.data !== vnode.text) {\n        elm.data = vnode.text;\n      }\n\n      return true;\n    }\n\n    function assertNodeMatch(node, vnode, inVPre) {\n      if (isDef(vnode.tag)) {\n        return vnode.tag.indexOf('vue-component') === 0 || !isUnknownElement$$1(vnode, inVPre) && vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());\n      } else {\n        return node.nodeType === (vnode.isComment ? 8 : 3);\n      }\n    }\n\n    return function patch(oldVnode, vnode, hydrating, removeOnly) {\n      if (isUndef(vnode)) {\n        if (isDef(oldVnode)) {\n          invokeDestroyHook(oldVnode);\n        }\n\n        return;\n      }\n\n      var isInitialPatch = false;\n      var insertedVnodeQueue = [];\n\n      if (isUndef(oldVnode)) {\n        // empty mount (likely as component), create new root element\n        isInitialPatch = true;\n        createElm(vnode, insertedVnodeQueue);\n      } else {\n        var isRealElement = isDef(oldVnode.nodeType);\n\n        if (!isRealElement && sameVnode(oldVnode, vnode)) {\n          // patch existing root node\n          patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);\n        } else {\n          if (isRealElement) {\n            // mounting to a real element\n            // check if this is server-rendered content and if we can perform\n            // a successful hydration.\n            if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n              oldVnode.removeAttribute(SSR_ATTR);\n              hydrating = true;\n            }\n\n            if (isTrue(hydrating)) {\n              if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n                invokeInsertHook(vnode, insertedVnodeQueue, true);\n                return oldVnode;\n              } else {\n                warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');\n              }\n            } // either not server-rendered, or hydration failed.\n            // create an empty node and replace it\n\n\n            oldVnode = emptyNodeAt(oldVnode);\n          } // replacing existing element\n\n\n          var oldElm = oldVnode.elm;\n          var parentElm = nodeOps.parentNode(oldElm); // create new node\n\n          createElm(vnode, insertedVnodeQueue, // extremely rare edge case: do not insert if old element is in a\n          // leaving transition. Only happens when combining transition +\n          // keep-alive + HOCs. (#4590)\n          oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm)); // update parent placeholder node element, recursively\n\n          if (isDef(vnode.parent)) {\n            var ancestor = vnode.parent;\n            var patchable = isPatchable(vnode);\n\n            while (ancestor) {\n              for (var i = 0; i < cbs.destroy.length; ++i) {\n                cbs.destroy[i](ancestor);\n              }\n\n              ancestor.elm = vnode.elm;\n\n              if (patchable) {\n                for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n                  cbs.create[i$1](emptyNode, ancestor);\n                } // #6513\n                // invoke insert hooks that may have been merged by create hooks.\n                // e.g. for directives that uses the \"inserted\" hook.\n\n\n                var insert = ancestor.data.hook.insert;\n\n                if (insert.merged) {\n                  // start at index 1 to avoid re-invoking component mounted hook\n                  for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {\n                    insert.fns[i$2]();\n                  }\n                }\n              } else {\n                registerRef(ancestor);\n              }\n\n              ancestor = ancestor.parent;\n            }\n          } // destroy old node\n\n\n          if (isDef(parentElm)) {\n            removeVnodes(parentElm, [oldVnode], 0, 0);\n          } else if (isDef(oldVnode.tag)) {\n            invokeDestroyHook(oldVnode);\n          }\n        }\n      }\n\n      invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n      return vnode.elm;\n    };\n  }\n  /*  */\n\n\n  var directives = {\n    create: updateDirectives,\n    update: updateDirectives,\n    destroy: function unbindDirectives(vnode) {\n      updateDirectives(vnode, emptyNode);\n    }\n  };\n\n  function updateDirectives(oldVnode, vnode) {\n    if (oldVnode.data.directives || vnode.data.directives) {\n      _update(oldVnode, vnode);\n    }\n  }\n\n  function _update(oldVnode, vnode) {\n    var isCreate = oldVnode === emptyNode;\n    var isDestroy = vnode === emptyNode;\n    var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n    var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n    var dirsWithInsert = [];\n    var dirsWithPostpatch = [];\n    var key, oldDir, dir;\n\n    for (key in newDirs) {\n      oldDir = oldDirs[key];\n      dir = newDirs[key];\n\n      if (!oldDir) {\n        // new directive, bind\n        callHook$1(dir, 'bind', vnode, oldVnode);\n\n        if (dir.def && dir.def.inserted) {\n          dirsWithInsert.push(dir);\n        }\n      } else {\n        // existing directive, update\n        dir.oldValue = oldDir.value;\n        dir.oldArg = oldDir.arg;\n        callHook$1(dir, 'update', vnode, oldVnode);\n\n        if (dir.def && dir.def.componentUpdated) {\n          dirsWithPostpatch.push(dir);\n        }\n      }\n    }\n\n    if (dirsWithInsert.length) {\n      var callInsert = function callInsert() {\n        for (var i = 0; i < dirsWithInsert.length; i++) {\n          callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n        }\n      };\n\n      if (isCreate) {\n        mergeVNodeHook(vnode, 'insert', callInsert);\n      } else {\n        callInsert();\n      }\n    }\n\n    if (dirsWithPostpatch.length) {\n      mergeVNodeHook(vnode, 'postpatch', function () {\n        for (var i = 0; i < dirsWithPostpatch.length; i++) {\n          callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n        }\n      });\n    }\n\n    if (!isCreate) {\n      for (key in oldDirs) {\n        if (!newDirs[key]) {\n          // no longer present, unbind\n          callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n        }\n      }\n    }\n  }\n\n  var emptyModifiers = Object.create(null);\n\n  function normalizeDirectives$1(dirs, vm) {\n    var res = Object.create(null);\n\n    if (!dirs) {\n      // $flow-disable-line\n      return res;\n    }\n\n    var i, dir;\n\n    for (i = 0; i < dirs.length; i++) {\n      dir = dirs[i];\n\n      if (!dir.modifiers) {\n        // $flow-disable-line\n        dir.modifiers = emptyModifiers;\n      }\n\n      res[getRawDirName(dir)] = dir;\n      dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n    } // $flow-disable-line\n\n\n    return res;\n  }\n\n  function getRawDirName(dir) {\n    return dir.rawName || dir.name + \".\" + Object.keys(dir.modifiers || {}).join('.');\n  }\n\n  function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {\n    var fn = dir.def && dir.def[hook];\n\n    if (fn) {\n      try {\n        fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n      } catch (e) {\n        handleError(e, vnode.context, \"directive \" + dir.name + \" \" + hook + \" hook\");\n      }\n    }\n  }\n\n  var baseModules = [ref, directives];\n  /*  */\n\n  function updateAttrs(oldVnode, vnode) {\n    var opts = vnode.componentOptions;\n\n    if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\n      return;\n    }\n\n    if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n      return;\n    }\n\n    var key, cur, old;\n    var elm = vnode.elm;\n    var oldAttrs = oldVnode.data.attrs || {};\n    var attrs = vnode.data.attrs || {}; // clone observed objects, as the user probably wants to mutate it\n\n    if (isDef(attrs.__ob__)) {\n      attrs = vnode.data.attrs = extend({}, attrs);\n    }\n\n    for (key in attrs) {\n      cur = attrs[key];\n      old = oldAttrs[key];\n\n      if (old !== cur) {\n        setAttr(elm, key, cur);\n      }\n    } // #4391: in IE9, setting type can reset value for input[type=radio]\n    // #6666: IE/Edge forces progress value down to 1 before setting a max\n\n    /* istanbul ignore if */\n\n\n    if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {\n      setAttr(elm, 'value', attrs.value);\n    }\n\n    for (key in oldAttrs) {\n      if (isUndef(attrs[key])) {\n        if (isXlink(key)) {\n          elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n        } else if (!isEnumeratedAttr(key)) {\n          elm.removeAttribute(key);\n        }\n      }\n    }\n  }\n\n  function setAttr(el, key, value) {\n    if (el.tagName.indexOf('-') > -1) {\n      baseSetAttr(el, key, value);\n    } else if (isBooleanAttr(key)) {\n      // set attribute for blank value\n      // e.g. <option disabled>Select one</option>\n      if (isFalsyAttrValue(value)) {\n        el.removeAttribute(key);\n      } else {\n        // technically allowfullscreen is a boolean attribute for <iframe>,\n        // but Flash expects a value of \"true\" when used on <embed> tag\n        value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;\n        el.setAttribute(key, value);\n      }\n    } else if (isEnumeratedAttr(key)) {\n      el.setAttribute(key, convertEnumeratedValue(key, value));\n    } else if (isXlink(key)) {\n      if (isFalsyAttrValue(value)) {\n        el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else {\n        el.setAttributeNS(xlinkNS, key, value);\n      }\n    } else {\n      baseSetAttr(el, key, value);\n    }\n  }\n\n  function baseSetAttr(el, key, value) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      // #7138: IE10 & 11 fires input event when setting placeholder on\n      // <textarea>... block the first input event and remove the blocker\n      // immediately.\n\n      /* istanbul ignore if */\n      if (isIE && !isIE9 && el.tagName === 'TEXTAREA' && key === 'placeholder' && value !== '' && !el.__ieph) {\n        var blocker = function blocker(e) {\n          e.stopImmediatePropagation();\n          el.removeEventListener('input', blocker);\n        };\n\n        el.addEventListener('input', blocker); // $flow-disable-line\n\n        el.__ieph = true;\n        /* IE placeholder patched */\n      }\n\n      el.setAttribute(key, value);\n    }\n  }\n\n  var attrs = {\n    create: updateAttrs,\n    update: updateAttrs\n  };\n  /*  */\n\n  function updateClass(oldVnode, vnode) {\n    var el = vnode.elm;\n    var data = vnode.data;\n    var oldData = oldVnode.data;\n\n    if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {\n      return;\n    }\n\n    var cls = genClassForVnode(vnode); // handle transition classes\n\n    var transitionClass = el._transitionClasses;\n\n    if (isDef(transitionClass)) {\n      cls = concat(cls, stringifyClass(transitionClass));\n    } // set the class\n\n\n    if (cls !== el._prevClass) {\n      el.setAttribute('class', cls);\n      el._prevClass = cls;\n    }\n  }\n\n  var klass = {\n    create: updateClass,\n    update: updateClass\n  };\n  /*  */\n\n  var validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\n  function parseFilters(exp) {\n    var inSingle = false;\n    var inDouble = false;\n    var inTemplateString = false;\n    var inRegex = false;\n    var curly = 0;\n    var square = 0;\n    var paren = 0;\n    var lastFilterIndex = 0;\n    var c, prev, i, expression, filters;\n\n    for (i = 0; i < exp.length; i++) {\n      prev = c;\n      c = exp.charCodeAt(i);\n\n      if (inSingle) {\n        if (c === 0x27 && prev !== 0x5C) {\n          inSingle = false;\n        }\n      } else if (inDouble) {\n        if (c === 0x22 && prev !== 0x5C) {\n          inDouble = false;\n        }\n      } else if (inTemplateString) {\n        if (c === 0x60 && prev !== 0x5C) {\n          inTemplateString = false;\n        }\n      } else if (inRegex) {\n        if (c === 0x2f && prev !== 0x5C) {\n          inRegex = false;\n        }\n      } else if (c === 0x7C && // pipe\n      exp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C && !curly && !square && !paren) {\n        if (expression === undefined) {\n          // first filter, end of expression\n          lastFilterIndex = i + 1;\n          expression = exp.slice(0, i).trim();\n        } else {\n          pushFilter();\n        }\n      } else {\n        switch (c) {\n          case 0x22:\n            inDouble = true;\n            break;\n          // \"\n\n          case 0x27:\n            inSingle = true;\n            break;\n          // '\n\n          case 0x60:\n            inTemplateString = true;\n            break;\n          // `\n\n          case 0x28:\n            paren++;\n            break;\n          // (\n\n          case 0x29:\n            paren--;\n            break;\n          // )\n\n          case 0x5B:\n            square++;\n            break;\n          // [\n\n          case 0x5D:\n            square--;\n            break;\n          // ]\n\n          case 0x7B:\n            curly++;\n            break;\n          // {\n\n          case 0x7D:\n            curly--;\n            break;\n          // }\n        }\n\n        if (c === 0x2f) {\n          // /\n          var j = i - 1;\n          var p = void 0; // find first non-whitespace prev char\n\n          for (; j >= 0; j--) {\n            p = exp.charAt(j);\n\n            if (p !== ' ') {\n              break;\n            }\n          }\n\n          if (!p || !validDivisionCharRE.test(p)) {\n            inRegex = true;\n          }\n        }\n      }\n    }\n\n    if (expression === undefined) {\n      expression = exp.slice(0, i).trim();\n    } else if (lastFilterIndex !== 0) {\n      pushFilter();\n    }\n\n    function pushFilter() {\n      (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n      lastFilterIndex = i + 1;\n    }\n\n    if (filters) {\n      for (i = 0; i < filters.length; i++) {\n        expression = wrapFilter(expression, filters[i]);\n      }\n    }\n\n    return expression;\n  }\n\n  function wrapFilter(exp, filter) {\n    var i = filter.indexOf('(');\n\n    if (i < 0) {\n      // _f: resolveFilter\n      return \"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\";\n    } else {\n      var name = filter.slice(0, i);\n      var args = filter.slice(i + 1);\n      return \"_f(\\\"\" + name + \"\\\")(\" + exp + (args !== ')' ? ',' + args : args);\n    }\n  }\n  /*  */\n\n  /* eslint-disable no-unused-vars */\n\n\n  function baseWarn(msg, range) {\n    console.error(\"[Vue compiler]: \" + msg);\n  }\n  /* eslint-enable no-unused-vars */\n\n\n  function pluckModuleFunction(modules, key) {\n    return modules ? modules.map(function (m) {\n      return m[key];\n    }).filter(function (_) {\n      return _;\n    }) : [];\n  }\n\n  function addProp(el, name, value, range, dynamic) {\n    (el.props || (el.props = [])).push(rangeSetItem({\n      name: name,\n      value: value,\n      dynamic: dynamic\n    }, range));\n    el.plain = false;\n  }\n\n  function addAttr(el, name, value, range, dynamic) {\n    var attrs = dynamic ? el.dynamicAttrs || (el.dynamicAttrs = []) : el.attrs || (el.attrs = []);\n    attrs.push(rangeSetItem({\n      name: name,\n      value: value,\n      dynamic: dynamic\n    }, range));\n    el.plain = false;\n  } // add a raw attr (use this in preTransforms)\n\n\n  function addRawAttr(el, name, value, range) {\n    el.attrsMap[name] = value;\n    el.attrsList.push(rangeSetItem({\n      name: name,\n      value: value\n    }, range));\n  }\n\n  function addDirective(el, name, rawName, value, arg, isDynamicArg, modifiers, range) {\n    (el.directives || (el.directives = [])).push(rangeSetItem({\n      name: name,\n      rawName: rawName,\n      value: value,\n      arg: arg,\n      isDynamicArg: isDynamicArg,\n      modifiers: modifiers\n    }, range));\n    el.plain = false;\n  }\n\n  function prependModifierMarker(symbol, name, dynamic) {\n    return dynamic ? \"_p(\" + name + \",\\\"\" + symbol + \"\\\")\" : symbol + name; // mark the event as captured\n  }\n\n  function addHandler(el, name, value, modifiers, important, warn, range, dynamic) {\n    modifiers = modifiers || emptyObject; // warn prevent and passive modifier\n\n    /* istanbul ignore if */\n\n    if (warn && modifiers.prevent && modifiers.passive) {\n      warn('passive and prevent can\\'t be used together. ' + 'Passive handler can\\'t prevent default event.', range);\n    } // normalize click.right and click.middle since they don't actually fire\n    // this is technically browser-specific, but at least for now browsers are\n    // the only target envs that have right/middle clicks.\n\n\n    if (modifiers.right) {\n      if (dynamic) {\n        name = \"(\" + name + \")==='click'?'contextmenu':(\" + name + \")\";\n      } else if (name === 'click') {\n        name = 'contextmenu';\n        delete modifiers.right;\n      }\n    } else if (modifiers.middle) {\n      if (dynamic) {\n        name = \"(\" + name + \")==='click'?'mouseup':(\" + name + \")\";\n      } else if (name === 'click') {\n        name = 'mouseup';\n      }\n    } // check capture modifier\n\n\n    if (modifiers.capture) {\n      delete modifiers.capture;\n      name = prependModifierMarker('!', name, dynamic);\n    }\n\n    if (modifiers.once) {\n      delete modifiers.once;\n      name = prependModifierMarker('~', name, dynamic);\n    }\n    /* istanbul ignore if */\n\n\n    if (modifiers.passive) {\n      delete modifiers.passive;\n      name = prependModifierMarker('&', name, dynamic);\n    }\n\n    var events;\n\n    if (modifiers.native) {\n      delete modifiers.native;\n      events = el.nativeEvents || (el.nativeEvents = {});\n    } else {\n      events = el.events || (el.events = {});\n    }\n\n    var newHandler = rangeSetItem({\n      value: value.trim(),\n      dynamic: dynamic\n    }, range);\n\n    if (modifiers !== emptyObject) {\n      newHandler.modifiers = modifiers;\n    }\n\n    var handlers = events[name];\n    /* istanbul ignore if */\n\n    if (Array.isArray(handlers)) {\n      important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n    } else if (handlers) {\n      events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n    } else {\n      events[name] = newHandler;\n    }\n\n    el.plain = false;\n  }\n\n  function getRawBindingAttr(el, name) {\n    return el.rawAttrsMap[':' + name] || el.rawAttrsMap['v-bind:' + name] || el.rawAttrsMap[name];\n  }\n\n  function getBindingAttr(el, name, getStatic) {\n    var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);\n\n    if (dynamicValue != null) {\n      return parseFilters(dynamicValue);\n    } else if (getStatic !== false) {\n      var staticValue = getAndRemoveAttr(el, name);\n\n      if (staticValue != null) {\n        return JSON.stringify(staticValue);\n      }\n    }\n  } // note: this only removes the attr from the Array (attrsList) so that it\n  // doesn't get processed by processAttrs.\n  // By default it does NOT remove it from the map (attrsMap) because the map is\n  // needed during codegen.\n\n\n  function getAndRemoveAttr(el, name, removeFromMap) {\n    var val;\n\n    if ((val = el.attrsMap[name]) != null) {\n      var list = el.attrsList;\n\n      for (var i = 0, l = list.length; i < l; i++) {\n        if (list[i].name === name) {\n          list.splice(i, 1);\n          break;\n        }\n      }\n    }\n\n    if (removeFromMap) {\n      delete el.attrsMap[name];\n    }\n\n    return val;\n  }\n\n  function getAndRemoveAttrByRegex(el, name) {\n    var list = el.attrsList;\n\n    for (var i = 0, l = list.length; i < l; i++) {\n      var attr = list[i];\n\n      if (name.test(attr.name)) {\n        list.splice(i, 1);\n        return attr;\n      }\n    }\n  }\n\n  function rangeSetItem(item, range) {\n    if (range) {\n      if (range.start != null) {\n        item.start = range.start;\n      }\n\n      if (range.end != null) {\n        item.end = range.end;\n      }\n    }\n\n    return item;\n  }\n  /*  */\n\n  /**\n   * Cross-platform code generation for component v-model\n   */\n\n\n  function genComponentModel(el, value, modifiers) {\n    var ref = modifiers || {};\n    var number = ref.number;\n    var trim = ref.trim;\n    var baseValueExpression = '$$v';\n    var valueExpression = baseValueExpression;\n\n    if (trim) {\n      valueExpression = \"(typeof \" + baseValueExpression + \" === 'string'\" + \"? \" + baseValueExpression + \".trim()\" + \": \" + baseValueExpression + \")\";\n    }\n\n    if (number) {\n      valueExpression = \"_n(\" + valueExpression + \")\";\n    }\n\n    var assignment = genAssignmentCode(value, valueExpression);\n    el.model = {\n      value: \"(\" + value + \")\",\n      expression: JSON.stringify(value),\n      callback: \"function (\" + baseValueExpression + \") {\" + assignment + \"}\"\n    };\n  }\n  /**\n   * Cross-platform codegen helper for generating v-model value assignment code.\n   */\n\n\n  function genAssignmentCode(value, assignment) {\n    var res = parseModel(value);\n\n    if (res.key === null) {\n      return value + \"=\" + assignment;\n    } else {\n      return \"$set(\" + res.exp + \", \" + res.key + \", \" + assignment + \")\";\n    }\n  }\n  /**\n   * Parse a v-model expression into a base path and a final key segment.\n   * Handles both dot-path and possible square brackets.\n   *\n   * Possible cases:\n   *\n   * - test\n   * - test[key]\n   * - test[test1[key]]\n   * - test[\"a\"][key]\n   * - xxx.test[a[a].test1[key]]\n   * - test.xxx.a[\"asa\"][test1[key]]\n   *\n   */\n\n\n  var len, str, chr, index$1, expressionPos, expressionEndPos;\n\n  function parseModel(val) {\n    // Fix https://github.com/vuejs/vue/pull/7730\n    // allow v-model=\"obj.val \" (trailing whitespace)\n    val = val.trim();\n    len = val.length;\n\n    if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n      index$1 = val.lastIndexOf('.');\n\n      if (index$1 > -1) {\n        return {\n          exp: val.slice(0, index$1),\n          key: '\"' + val.slice(index$1 + 1) + '\"'\n        };\n      } else {\n        return {\n          exp: val,\n          key: null\n        };\n      }\n    }\n\n    str = val;\n    index$1 = expressionPos = expressionEndPos = 0;\n\n    while (!eof()) {\n      chr = next();\n      /* istanbul ignore if */\n\n      if (isStringStart(chr)) {\n        parseString(chr);\n      } else if (chr === 0x5B) {\n        parseBracket(chr);\n      }\n    }\n\n    return {\n      exp: val.slice(0, expressionPos),\n      key: val.slice(expressionPos + 1, expressionEndPos)\n    };\n  }\n\n  function next() {\n    return str.charCodeAt(++index$1);\n  }\n\n  function eof() {\n    return index$1 >= len;\n  }\n\n  function isStringStart(chr) {\n    return chr === 0x22 || chr === 0x27;\n  }\n\n  function parseBracket(chr) {\n    var inBracket = 1;\n    expressionPos = index$1;\n\n    while (!eof()) {\n      chr = next();\n\n      if (isStringStart(chr)) {\n        parseString(chr);\n        continue;\n      }\n\n      if (chr === 0x5B) {\n        inBracket++;\n      }\n\n      if (chr === 0x5D) {\n        inBracket--;\n      }\n\n      if (inBracket === 0) {\n        expressionEndPos = index$1;\n        break;\n      }\n    }\n  }\n\n  function parseString(chr) {\n    var stringQuote = chr;\n\n    while (!eof()) {\n      chr = next();\n\n      if (chr === stringQuote) {\n        break;\n      }\n    }\n  }\n  /*  */\n\n\n  var warn$1; // in some cases, the event used has to be determined at runtime\n  // so we used some reserved tokens during compile.\n\n  var RANGE_TOKEN = '__r';\n  var CHECKBOX_RADIO_TOKEN = '__c';\n\n  function model(el, dir, _warn) {\n    warn$1 = _warn;\n    var value = dir.value;\n    var modifiers = dir.modifiers;\n    var tag = el.tag;\n    var type = el.attrsMap.type;\n    {\n      // inputs with type=\"file\" are read only and setting the input's\n      // value will throw an error.\n      if (tag === 'input' && type === 'file') {\n        warn$1(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" + \"File inputs are read only. Use a v-on:change listener instead.\", el.rawAttrsMap['v-model']);\n      }\n    }\n\n    if (el.component) {\n      genComponentModel(el, value, modifiers); // component v-model doesn't need extra runtime\n\n      return false;\n    } else if (tag === 'select') {\n      genSelect(el, value, modifiers);\n    } else if (tag === 'input' && type === 'checkbox') {\n      genCheckboxModel(el, value, modifiers);\n    } else if (tag === 'input' && type === 'radio') {\n      genRadioModel(el, value, modifiers);\n    } else if (tag === 'input' || tag === 'textarea') {\n      genDefaultModel(el, value, modifiers);\n    } else if (!config.isReservedTag(tag)) {\n      genComponentModel(el, value, modifiers); // component v-model doesn't need extra runtime\n\n      return false;\n    } else {\n      warn$1(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\">: \" + \"v-model is not supported on this element type. \" + 'If you are working with contenteditable, it\\'s recommended to ' + 'wrap a library dedicated for that purpose inside a custom component.', el.rawAttrsMap['v-model']);\n    } // ensure runtime directive metadata\n\n\n    return true;\n  }\n\n  function genCheckboxModel(el, value, modifiers) {\n    var number = modifiers && modifiers.number;\n    var valueBinding = getBindingAttr(el, 'value') || 'null';\n    var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n    var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n    addProp(el, 'checked', \"Array.isArray(\" + value + \")\" + \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (trueValueBinding === 'true' ? \":(\" + value + \")\" : \":_q(\" + value + \",\" + trueValueBinding + \")\"));\n    addHandler(el, 'change', \"var $$a=\" + value + \",\" + '$$el=$event.target,' + \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" + 'if(Array.isArray($$a)){' + \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" + '$$i=_i($$a,$$v);' + \"if($$el.checked){$$i<0&&(\" + genAssignmentCode(value, '$$a.concat([$$v])') + \")}\" + \"else{$$i>-1&&(\" + genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))') + \")}\" + \"}else{\" + genAssignmentCode(value, '$$c') + \"}\", null, true);\n  }\n\n  function genRadioModel(el, value, modifiers) {\n    var number = modifiers && modifiers.number;\n    var valueBinding = getBindingAttr(el, 'value') || 'null';\n    valueBinding = number ? \"_n(\" + valueBinding + \")\" : valueBinding;\n    addProp(el, 'checked', \"_q(\" + value + \",\" + valueBinding + \")\");\n    addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);\n  }\n\n  function genSelect(el, value, modifiers) {\n    var number = modifiers && modifiers.number;\n    var selectedVal = \"Array.prototype.filter\" + \".call($event.target.options,function(o){return o.selected})\" + \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" + \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n    var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n    var code = \"var $$selectedVal = \" + selectedVal + \";\";\n    code = code + \" \" + genAssignmentCode(value, assignment);\n    addHandler(el, 'change', code, null, true);\n  }\n\n  function genDefaultModel(el, value, modifiers) {\n    var type = el.attrsMap.type; // warn if v-bind:value conflicts with v-model\n    // except for inputs with v-bind:type\n\n    {\n      var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];\n      var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n\n      if (value$1 && !typeBinding) {\n        var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';\n        warn$1(binding + \"=\\\"\" + value$1 + \"\\\" conflicts with v-model on the same element \" + 'because the latter already expands to a value binding internally', el.rawAttrsMap[binding]);\n      }\n    }\n    var ref = modifiers || {};\n    var lazy = ref.lazy;\n    var number = ref.number;\n    var trim = ref.trim;\n    var needCompositionGuard = !lazy && type !== 'range';\n    var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';\n    var valueExpression = '$event.target.value';\n\n    if (trim) {\n      valueExpression = \"$event.target.value.trim()\";\n    }\n\n    if (number) {\n      valueExpression = \"_n(\" + valueExpression + \")\";\n    }\n\n    var code = genAssignmentCode(value, valueExpression);\n\n    if (needCompositionGuard) {\n      code = \"if($event.target.composing)return;\" + code;\n    }\n\n    addProp(el, 'value', \"(\" + value + \")\");\n    addHandler(el, event, code, null, true);\n\n    if (trim || number) {\n      addHandler(el, 'blur', '$forceUpdate()');\n    }\n  }\n  /*  */\n  // normalize v-model event tokens that can only be determined at runtime.\n  // it's important to place the event as the first in the array because\n  // the whole point is ensuring the v-model callback gets called before\n  // user-attached handlers.\n\n\n  function normalizeEvents(on) {\n    /* istanbul ignore if */\n    if (isDef(on[RANGE_TOKEN])) {\n      // IE input[type=range] only supports `change` event\n      var event = isIE ? 'change' : 'input';\n      on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n      delete on[RANGE_TOKEN];\n    } // This was originally intended to fix #4521 but no longer necessary\n    // after 2.5. Keeping it for backwards compat with generated code from < 2.4\n\n    /* istanbul ignore if */\n\n\n    if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n      on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);\n      delete on[CHECKBOX_RADIO_TOKEN];\n    }\n  }\n\n  var target$1;\n\n  function createOnceHandler$1(event, handler, capture) {\n    var _target = target$1; // save current target element in closure\n\n    return function onceHandler() {\n      var res = handler.apply(null, arguments);\n\n      if (res !== null) {\n        remove$2(event, onceHandler, capture, _target);\n      }\n    };\n  } // #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp\n  // implementation and does not fire microtasks in between event propagation, so\n  // safe to exclude.\n\n\n  var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);\n\n  function add$1(name, handler, capture, passive) {\n    // async edge case #6566: inner click event triggers patch, event handler\n    // attached to outer element during patch, and triggered again. This\n    // happens because browsers fire microtask ticks between event propagation.\n    // the solution is simple: we save the timestamp when a handler is attached,\n    // and the handler would only fire if the event passed to it was fired\n    // AFTER it was attached.\n    if (useMicrotaskFix) {\n      var attachedTimestamp = currentFlushTimestamp;\n      var original = handler;\n\n      handler = original._wrapper = function (e) {\n        if ( // no bubbling, should always fire.\n        // this is just a safety net in case event.timeStamp is unreliable in\n        // certain weird environments...\n        e.target === e.currentTarget || // event is fired after handler attachment\n        e.timeStamp >= attachedTimestamp || // bail for environments that have buggy event.timeStamp implementations\n        // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState\n        // #9681 QtWebEngine event.timeStamp is negative value\n        e.timeStamp <= 0 || // #9448 bail if event is fired in another document in a multi-page\n        // electron/nw.js app, since event.timeStamp will be using a different\n        // starting reference\n        e.target.ownerDocument !== document) {\n          return original.apply(this, arguments);\n        }\n      };\n    }\n\n    target$1.addEventListener(name, handler, supportsPassive ? {\n      capture: capture,\n      passive: passive\n    } : capture);\n  }\n\n  function remove$2(name, handler, capture, _target) {\n    (_target || target$1).removeEventListener(name, handler._wrapper || handler, capture);\n  }\n\n  function updateDOMListeners(oldVnode, vnode) {\n    if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n      return;\n    }\n\n    var on = vnode.data.on || {};\n    var oldOn = oldVnode.data.on || {};\n    target$1 = vnode.elm;\n    normalizeEvents(on);\n    updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);\n    target$1 = undefined;\n  }\n\n  var events = {\n    create: updateDOMListeners,\n    update: updateDOMListeners\n  };\n  /*  */\n\n  var svgContainer;\n\n  function updateDOMProps(oldVnode, vnode) {\n    if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n      return;\n    }\n\n    var key, cur;\n    var elm = vnode.elm;\n    var oldProps = oldVnode.data.domProps || {};\n    var props = vnode.data.domProps || {}; // clone observed objects, as the user probably wants to mutate it\n\n    if (isDef(props.__ob__)) {\n      props = vnode.data.domProps = extend({}, props);\n    }\n\n    for (key in oldProps) {\n      if (!(key in props)) {\n        elm[key] = '';\n      }\n    }\n\n    for (key in props) {\n      cur = props[key]; // ignore children if the node has textContent or innerHTML,\n      // as these will throw away existing DOM nodes and cause removal errors\n      // on subsequent patches (#3360)\n\n      if (key === 'textContent' || key === 'innerHTML') {\n        if (vnode.children) {\n          vnode.children.length = 0;\n        }\n\n        if (cur === oldProps[key]) {\n          continue;\n        } // #6601 work around Chrome version <= 55 bug where single textNode\n        // replaced by innerHTML/textContent retains its parentNode property\n\n\n        if (elm.childNodes.length === 1) {\n          elm.removeChild(elm.childNodes[0]);\n        }\n      }\n\n      if (key === 'value' && elm.tagName !== 'PROGRESS') {\n        // store value as _value as well since\n        // non-string values will be stringified\n        elm._value = cur; // avoid resetting cursor position when value is the same\n\n        var strCur = isUndef(cur) ? '' : String(cur);\n\n        if (shouldUpdateValue(elm, strCur)) {\n          elm.value = strCur;\n        }\n      } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {\n        // IE doesn't support innerHTML for SVG elements\n        svgContainer = svgContainer || document.createElement('div');\n        svgContainer.innerHTML = \"<svg>\" + cur + \"</svg>\";\n        var svg = svgContainer.firstChild;\n\n        while (elm.firstChild) {\n          elm.removeChild(elm.firstChild);\n        }\n\n        while (svg.firstChild) {\n          elm.appendChild(svg.firstChild);\n        }\n      } else if ( // skip the update if old and new VDOM state is the same.\n      // `value` is handled separately because the DOM value may be temporarily\n      // out of sync with VDOM state due to focus, composition and modifiers.\n      // This  #4521 by skipping the unnecesarry `checked` update.\n      cur !== oldProps[key]) {\n        // some property updates can throw\n        // e.g. `value` on <progress> w/ non-finite value\n        try {\n          elm[key] = cur;\n        } catch (e) {}\n      }\n    }\n  } // check platforms/web/util/attrs.js acceptValue\n\n\n  function shouldUpdateValue(elm, checkVal) {\n    return !elm.composing && (elm.tagName === 'OPTION' || isNotInFocusAndDirty(elm, checkVal) || isDirtyWithModifiers(elm, checkVal));\n  }\n\n  function isNotInFocusAndDirty(elm, checkVal) {\n    // return true when textbox (.number and .trim) loses focus and its value is\n    // not equal to the updated value\n    var notInFocus = true; // #6157\n    // work around IE bug when accessing document.activeElement in an iframe\n\n    try {\n      notInFocus = document.activeElement !== elm;\n    } catch (e) {}\n\n    return notInFocus && elm.value !== checkVal;\n  }\n\n  function isDirtyWithModifiers(elm, newVal) {\n    var value = elm.value;\n    var modifiers = elm._vModifiers; // injected by v-model runtime\n\n    if (isDef(modifiers)) {\n      if (modifiers.number) {\n        return toNumber(value) !== toNumber(newVal);\n      }\n\n      if (modifiers.trim) {\n        return value.trim() !== newVal.trim();\n      }\n    }\n\n    return value !== newVal;\n  }\n\n  var domProps = {\n    create: updateDOMProps,\n    update: updateDOMProps\n  };\n  /*  */\n\n  var parseStyleText = cached(function (cssText) {\n    var res = {};\n    var listDelimiter = /;(?![^(]*\\))/g;\n    var propertyDelimiter = /:(.+)/;\n    cssText.split(listDelimiter).forEach(function (item) {\n      if (item) {\n        var tmp = item.split(propertyDelimiter);\n        tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n      }\n    });\n    return res;\n  }); // merge static and dynamic style data on the same vnode\n\n  function normalizeStyleData(data) {\n    var style = normalizeStyleBinding(data.style); // static style is pre-processed into an object during compilation\n    // and is always a fresh object, so it's safe to merge into it\n\n    return data.staticStyle ? extend(data.staticStyle, style) : style;\n  } // normalize possible array / string values into Object\n\n\n  function normalizeStyleBinding(bindingStyle) {\n    if (Array.isArray(bindingStyle)) {\n      return toObject(bindingStyle);\n    }\n\n    if (typeof bindingStyle === 'string') {\n      return parseStyleText(bindingStyle);\n    }\n\n    return bindingStyle;\n  }\n  /**\n   * parent component style should be after child's\n   * so that parent component's style could override it\n   */\n\n\n  function getStyle(vnode, checkChild) {\n    var res = {};\n    var styleData;\n\n    if (checkChild) {\n      var childNode = vnode;\n\n      while (childNode.componentInstance) {\n        childNode = childNode.componentInstance._vnode;\n\n        if (childNode && childNode.data && (styleData = normalizeStyleData(childNode.data))) {\n          extend(res, styleData);\n        }\n      }\n    }\n\n    if (styleData = normalizeStyleData(vnode.data)) {\n      extend(res, styleData);\n    }\n\n    var parentNode = vnode;\n\n    while (parentNode = parentNode.parent) {\n      if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n        extend(res, styleData);\n      }\n    }\n\n    return res;\n  }\n  /*  */\n\n\n  var cssVarRE = /^--/;\n  var importantRE = /\\s*!important$/;\n\n  var setProp = function setProp(el, name, val) {\n    /* istanbul ignore if */\n    if (cssVarRE.test(name)) {\n      el.style.setProperty(name, val);\n    } else if (importantRE.test(val)) {\n      el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');\n    } else {\n      var normalizedName = normalize(name);\n\n      if (Array.isArray(val)) {\n        // Support values array created by autoprefixer, e.g.\n        // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n        // Set them one by one, and the browser will only set those it can recognize\n        for (var i = 0, len = val.length; i < len; i++) {\n          el.style[normalizedName] = val[i];\n        }\n      } else {\n        el.style[normalizedName] = val;\n      }\n    }\n  };\n\n  var vendorNames = ['Webkit', 'Moz', 'ms'];\n  var emptyStyle;\n  var normalize = cached(function (prop) {\n    emptyStyle = emptyStyle || document.createElement('div').style;\n    prop = camelize(prop);\n\n    if (prop !== 'filter' && prop in emptyStyle) {\n      return prop;\n    }\n\n    var capName = prop.charAt(0).toUpperCase() + prop.slice(1);\n\n    for (var i = 0; i < vendorNames.length; i++) {\n      var name = vendorNames[i] + capName;\n\n      if (name in emptyStyle) {\n        return name;\n      }\n    }\n  });\n\n  function updateStyle(oldVnode, vnode) {\n    var data = vnode.data;\n    var oldData = oldVnode.data;\n\n    if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {\n      return;\n    }\n\n    var cur, name;\n    var el = vnode.elm;\n    var oldStaticStyle = oldData.staticStyle;\n    var oldStyleBinding = oldData.normalizedStyle || oldData.style || {}; // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n\n    var oldStyle = oldStaticStyle || oldStyleBinding;\n    var style = normalizeStyleBinding(vnode.data.style) || {}; // store normalized style under a different key for next diff\n    // make sure to clone it if it's reactive, since the user likely wants\n    // to mutate it.\n\n    vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;\n    var newStyle = getStyle(vnode, true);\n\n    for (name in oldStyle) {\n      if (isUndef(newStyle[name])) {\n        setProp(el, name, '');\n      }\n    }\n\n    for (name in newStyle) {\n      cur = newStyle[name];\n\n      if (cur !== oldStyle[name]) {\n        // ie9 setting to null has no effect, must use empty string\n        setProp(el, name, cur == null ? '' : cur);\n      }\n    }\n  }\n\n  var style = {\n    create: updateStyle,\n    update: updateStyle\n  };\n  /*  */\n\n  var whitespaceRE = /\\s+/;\n  /**\n   * Add class with compatibility for SVG since classList is not supported on\n   * SVG elements in IE\n   */\n\n  function addClass(el, cls) {\n    /* istanbul ignore if */\n    if (!cls || !(cls = cls.trim())) {\n      return;\n    }\n    /* istanbul ignore else */\n\n\n    if (el.classList) {\n      if (cls.indexOf(' ') > -1) {\n        cls.split(whitespaceRE).forEach(function (c) {\n          return el.classList.add(c);\n        });\n      } else {\n        el.classList.add(cls);\n      }\n    } else {\n      var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n\n      if (cur.indexOf(' ' + cls + ' ') < 0) {\n        el.setAttribute('class', (cur + cls).trim());\n      }\n    }\n  }\n  /**\n   * Remove class with compatibility for SVG since classList is not supported on\n   * SVG elements in IE\n   */\n\n\n  function removeClass(el, cls) {\n    /* istanbul ignore if */\n    if (!cls || !(cls = cls.trim())) {\n      return;\n    }\n    /* istanbul ignore else */\n\n\n    if (el.classList) {\n      if (cls.indexOf(' ') > -1) {\n        cls.split(whitespaceRE).forEach(function (c) {\n          return el.classList.remove(c);\n        });\n      } else {\n        el.classList.remove(cls);\n      }\n\n      if (!el.classList.length) {\n        el.removeAttribute('class');\n      }\n    } else {\n      var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n      var tar = ' ' + cls + ' ';\n\n      while (cur.indexOf(tar) >= 0) {\n        cur = cur.replace(tar, ' ');\n      }\n\n      cur = cur.trim();\n\n      if (cur) {\n        el.setAttribute('class', cur);\n      } else {\n        el.removeAttribute('class');\n      }\n    }\n  }\n  /*  */\n\n\n  function resolveTransition(def$$1) {\n    if (!def$$1) {\n      return;\n    }\n    /* istanbul ignore else */\n\n\n    if (_typeof(def$$1) === 'object') {\n      var res = {};\n\n      if (def$$1.css !== false) {\n        extend(res, autoCssTransition(def$$1.name || 'v'));\n      }\n\n      extend(res, def$$1);\n      return res;\n    } else if (typeof def$$1 === 'string') {\n      return autoCssTransition(def$$1);\n    }\n  }\n\n  var autoCssTransition = cached(function (name) {\n    return {\n      enterClass: name + \"-enter\",\n      enterToClass: name + \"-enter-to\",\n      enterActiveClass: name + \"-enter-active\",\n      leaveClass: name + \"-leave\",\n      leaveToClass: name + \"-leave-to\",\n      leaveActiveClass: name + \"-leave-active\"\n    };\n  });\n  var hasTransition = inBrowser && !isIE9;\n  var TRANSITION = 'transition';\n  var ANIMATION = 'animation'; // Transition property/event sniffing\n\n  var transitionProp = 'transition';\n  var transitionEndEvent = 'transitionend';\n  var animationProp = 'animation';\n  var animationEndEvent = 'animationend';\n\n  if (hasTransition) {\n    /* istanbul ignore if */\n    if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {\n      transitionProp = 'WebkitTransition';\n      transitionEndEvent = 'webkitTransitionEnd';\n    }\n\n    if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {\n      animationProp = 'WebkitAnimation';\n      animationEndEvent = 'webkitAnimationEnd';\n    }\n  } // binding to window is necessary to make hot reload work in IE in strict mode\n\n\n  var raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout :\n  /* istanbul ignore next */\n  function (fn) {\n    return fn();\n  };\n\n  function nextFrame(fn) {\n    raf(function () {\n      raf(fn);\n    });\n  }\n\n  function addTransitionClass(el, cls) {\n    var transitionClasses = el._transitionClasses || (el._transitionClasses = []);\n\n    if (transitionClasses.indexOf(cls) < 0) {\n      transitionClasses.push(cls);\n      addClass(el, cls);\n    }\n  }\n\n  function removeTransitionClass(el, cls) {\n    if (el._transitionClasses) {\n      remove(el._transitionClasses, cls);\n    }\n\n    removeClass(el, cls);\n  }\n\n  function whenTransitionEnds(el, expectedType, cb) {\n    var ref = getTransitionInfo(el, expectedType);\n    var type = ref.type;\n    var timeout = ref.timeout;\n    var propCount = ref.propCount;\n\n    if (!type) {\n      return cb();\n    }\n\n    var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n    var ended = 0;\n\n    var end = function end() {\n      el.removeEventListener(event, onEnd);\n      cb();\n    };\n\n    var onEnd = function onEnd(e) {\n      if (e.target === el) {\n        if (++ended >= propCount) {\n          end();\n        }\n      }\n    };\n\n    setTimeout(function () {\n      if (ended < propCount) {\n        end();\n      }\n    }, timeout + 1);\n    el.addEventListener(event, onEnd);\n  }\n\n  var transformRE = /\\b(transform|all)(,|$)/;\n\n  function getTransitionInfo(el, expectedType) {\n    var styles = window.getComputedStyle(el); // JSDOM may return undefined for transition properties\n\n    var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');\n    var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');\n    var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n    var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');\n    var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');\n    var animationTimeout = getTimeout(animationDelays, animationDurations);\n    var type;\n    var timeout = 0;\n    var propCount = 0;\n    /* istanbul ignore if */\n\n    if (expectedType === TRANSITION) {\n      if (transitionTimeout > 0) {\n        type = TRANSITION;\n        timeout = transitionTimeout;\n        propCount = transitionDurations.length;\n      }\n    } else if (expectedType === ANIMATION) {\n      if (animationTimeout > 0) {\n        type = ANIMATION;\n        timeout = animationTimeout;\n        propCount = animationDurations.length;\n      }\n    } else {\n      timeout = Math.max(transitionTimeout, animationTimeout);\n      type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;\n      propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;\n    }\n\n    var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);\n    return {\n      type: type,\n      timeout: timeout,\n      propCount: propCount,\n      hasTransform: hasTransform\n    };\n  }\n\n  function getTimeout(delays, durations) {\n    /* istanbul ignore next */\n    while (delays.length < durations.length) {\n      delays = delays.concat(delays);\n    }\n\n    return Math.max.apply(null, durations.map(function (d, i) {\n      return toMs(d) + toMs(delays[i]);\n    }));\n  } // Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers\n  // in a locale-dependent way, using a comma instead of a dot.\n  // If comma is not replaced with a dot, the input will be rounded down (i.e. acting\n  // as a floor function) causing unexpected behaviors\n\n\n  function toMs(s) {\n    return Number(s.slice(0, -1).replace(',', '.')) * 1000;\n  }\n  /*  */\n\n\n  function enter(vnode, toggleDisplay) {\n    var el = vnode.elm; // call leave callback now\n\n    if (isDef(el._leaveCb)) {\n      el._leaveCb.cancelled = true;\n\n      el._leaveCb();\n    }\n\n    var data = resolveTransition(vnode.data.transition);\n\n    if (isUndef(data)) {\n      return;\n    }\n    /* istanbul ignore if */\n\n\n    if (isDef(el._enterCb) || el.nodeType !== 1) {\n      return;\n    }\n\n    var css = data.css;\n    var type = data.type;\n    var enterClass = data.enterClass;\n    var enterToClass = data.enterToClass;\n    var enterActiveClass = data.enterActiveClass;\n    var appearClass = data.appearClass;\n    var appearToClass = data.appearToClass;\n    var appearActiveClass = data.appearActiveClass;\n    var beforeEnter = data.beforeEnter;\n    var enter = data.enter;\n    var afterEnter = data.afterEnter;\n    var enterCancelled = data.enterCancelled;\n    var beforeAppear = data.beforeAppear;\n    var appear = data.appear;\n    var afterAppear = data.afterAppear;\n    var appearCancelled = data.appearCancelled;\n    var duration = data.duration; // activeInstance will always be the <transition> component managing this\n    // transition. One edge case to check is when the <transition> is placed\n    // as the root node of a child component. In that case we need to check\n    // <transition>'s parent for appear check.\n\n    var context = activeInstance;\n    var transitionNode = activeInstance.$vnode;\n\n    while (transitionNode && transitionNode.parent) {\n      context = transitionNode.context;\n      transitionNode = transitionNode.parent;\n    }\n\n    var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n    if (isAppear && !appear && appear !== '') {\n      return;\n    }\n\n    var startClass = isAppear && appearClass ? appearClass : enterClass;\n    var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;\n    var toClass = isAppear && appearToClass ? appearToClass : enterToClass;\n    var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;\n    var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;\n    var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;\n    var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;\n    var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);\n\n    if (explicitEnterDuration != null) {\n      checkDuration(explicitEnterDuration, 'enter', vnode);\n    }\n\n    var expectsCSS = css !== false && !isIE9;\n    var userWantsControl = getHookArgumentsLength(enterHook);\n    var cb = el._enterCb = once(function () {\n      if (expectsCSS) {\n        removeTransitionClass(el, toClass);\n        removeTransitionClass(el, activeClass);\n      }\n\n      if (cb.cancelled) {\n        if (expectsCSS) {\n          removeTransitionClass(el, startClass);\n        }\n\n        enterCancelledHook && enterCancelledHook(el);\n      } else {\n        afterEnterHook && afterEnterHook(el);\n      }\n\n      el._enterCb = null;\n    });\n\n    if (!vnode.data.show) {\n      // remove pending leave element on enter by injecting an insert hook\n      mergeVNodeHook(vnode, 'insert', function () {\n        var parent = el.parentNode;\n        var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n\n        if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {\n          pendingNode.elm._leaveCb();\n        }\n\n        enterHook && enterHook(el, cb);\n      });\n    } // start enter transition\n\n\n    beforeEnterHook && beforeEnterHook(el);\n\n    if (expectsCSS) {\n      addTransitionClass(el, startClass);\n      addTransitionClass(el, activeClass);\n      nextFrame(function () {\n        removeTransitionClass(el, startClass);\n\n        if (!cb.cancelled) {\n          addTransitionClass(el, toClass);\n\n          if (!userWantsControl) {\n            if (isValidDuration(explicitEnterDuration)) {\n              setTimeout(cb, explicitEnterDuration);\n            } else {\n              whenTransitionEnds(el, type, cb);\n            }\n          }\n        }\n      });\n    }\n\n    if (vnode.data.show) {\n      toggleDisplay && toggleDisplay();\n      enterHook && enterHook(el, cb);\n    }\n\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n\n  function leave(vnode, rm) {\n    var el = vnode.elm; // call enter callback now\n\n    if (isDef(el._enterCb)) {\n      el._enterCb.cancelled = true;\n\n      el._enterCb();\n    }\n\n    var data = resolveTransition(vnode.data.transition);\n\n    if (isUndef(data) || el.nodeType !== 1) {\n      return rm();\n    }\n    /* istanbul ignore if */\n\n\n    if (isDef(el._leaveCb)) {\n      return;\n    }\n\n    var css = data.css;\n    var type = data.type;\n    var leaveClass = data.leaveClass;\n    var leaveToClass = data.leaveToClass;\n    var leaveActiveClass = data.leaveActiveClass;\n    var beforeLeave = data.beforeLeave;\n    var leave = data.leave;\n    var afterLeave = data.afterLeave;\n    var leaveCancelled = data.leaveCancelled;\n    var delayLeave = data.delayLeave;\n    var duration = data.duration;\n    var expectsCSS = css !== false && !isIE9;\n    var userWantsControl = getHookArgumentsLength(leave);\n    var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);\n\n    if (isDef(explicitLeaveDuration)) {\n      checkDuration(explicitLeaveDuration, 'leave', vnode);\n    }\n\n    var cb = el._leaveCb = once(function () {\n      if (el.parentNode && el.parentNode._pending) {\n        el.parentNode._pending[vnode.key] = null;\n      }\n\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveToClass);\n        removeTransitionClass(el, leaveActiveClass);\n      }\n\n      if (cb.cancelled) {\n        if (expectsCSS) {\n          removeTransitionClass(el, leaveClass);\n        }\n\n        leaveCancelled && leaveCancelled(el);\n      } else {\n        rm();\n        afterLeave && afterLeave(el);\n      }\n\n      el._leaveCb = null;\n    });\n\n    if (delayLeave) {\n      delayLeave(performLeave);\n    } else {\n      performLeave();\n    }\n\n    function performLeave() {\n      // the delayed leave may have already been cancelled\n      if (cb.cancelled) {\n        return;\n      } // record leaving element\n\n\n      if (!vnode.data.show && el.parentNode) {\n        (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;\n      }\n\n      beforeLeave && beforeLeave(el);\n\n      if (expectsCSS) {\n        addTransitionClass(el, leaveClass);\n        addTransitionClass(el, leaveActiveClass);\n        nextFrame(function () {\n          removeTransitionClass(el, leaveClass);\n\n          if (!cb.cancelled) {\n            addTransitionClass(el, leaveToClass);\n\n            if (!userWantsControl) {\n              if (isValidDuration(explicitLeaveDuration)) {\n                setTimeout(cb, explicitLeaveDuration);\n              } else {\n                whenTransitionEnds(el, type, cb);\n              }\n            }\n          }\n        });\n      }\n\n      leave && leave(el, cb);\n\n      if (!expectsCSS && !userWantsControl) {\n        cb();\n      }\n    }\n  } // only used in dev mode\n\n\n  function checkDuration(val, name, vnode) {\n    if (typeof val !== 'number') {\n      warn(\"<transition> explicit \" + name + \" duration is not a valid number - \" + \"got \" + JSON.stringify(val) + \".\", vnode.context);\n    } else if (isNaN(val)) {\n      warn(\"<transition> explicit \" + name + \" duration is NaN - \" + 'the duration expression might be incorrect.', vnode.context);\n    }\n  }\n\n  function isValidDuration(val) {\n    return typeof val === 'number' && !isNaN(val);\n  }\n  /**\n   * Normalize a transition hook's argument length. The hook may be:\n   * - a merged hook (invoker) with the original in .fns\n   * - a wrapped component method (check ._length)\n   * - a plain function (.length)\n   */\n\n\n  function getHookArgumentsLength(fn) {\n    if (isUndef(fn)) {\n      return false;\n    }\n\n    var invokerFns = fn.fns;\n\n    if (isDef(invokerFns)) {\n      // invoker\n      return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);\n    } else {\n      return (fn._length || fn.length) > 1;\n    }\n  }\n\n  function _enter(_, vnode) {\n    if (vnode.data.show !== true) {\n      enter(vnode);\n    }\n  }\n\n  var transition = inBrowser ? {\n    create: _enter,\n    activate: _enter,\n    remove: function remove$$1(vnode, rm) {\n      /* istanbul ignore else */\n      if (vnode.data.show !== true) {\n        leave(vnode, rm);\n      } else {\n        rm();\n      }\n    }\n  } : {};\n  var platformModules = [attrs, klass, events, domProps, style, transition];\n  /*  */\n  // the directive module should be applied last, after all\n  // built-in modules have been applied.\n\n  var modules = platformModules.concat(baseModules);\n  var patch = createPatchFunction({\n    nodeOps: nodeOps,\n    modules: modules\n  });\n  /**\n   * Not type checking this file because flow doesn't like attaching\n   * properties to Elements.\n   */\n\n  /* istanbul ignore if */\n\n  if (isIE9) {\n    // http://www.matts411.com/post/internet-explorer-9-oninput/\n    document.addEventListener('selectionchange', function () {\n      var el = document.activeElement;\n\n      if (el && el.vmodel) {\n        trigger(el, 'input');\n      }\n    });\n  }\n\n  var directive = {\n    inserted: function inserted(el, binding, vnode, oldVnode) {\n      if (vnode.tag === 'select') {\n        // #6903\n        if (oldVnode.elm && !oldVnode.elm._vOptions) {\n          mergeVNodeHook(vnode, 'postpatch', function () {\n            directive.componentUpdated(el, binding, vnode);\n          });\n        } else {\n          setSelected(el, binding, vnode.context);\n        }\n\n        el._vOptions = [].map.call(el.options, getValue);\n      } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\n        el._vModifiers = binding.modifiers;\n\n        if (!binding.modifiers.lazy) {\n          el.addEventListener('compositionstart', onCompositionStart);\n          el.addEventListener('compositionend', onCompositionEnd); // Safari < 10.2 & UIWebView doesn't fire compositionend when\n          // switching focus before confirming composition choice\n          // this also fixes the issue where some browsers e.g. iOS Chrome\n          // fires \"change\" instead of \"input\" on autocomplete.\n\n          el.addEventListener('change', onCompositionEnd);\n          /* istanbul ignore if */\n\n          if (isIE9) {\n            el.vmodel = true;\n          }\n        }\n      }\n    },\n    componentUpdated: function componentUpdated(el, binding, vnode) {\n      if (vnode.tag === 'select') {\n        setSelected(el, binding, vnode.context); // in case the options rendered by v-for have changed,\n        // it's possible that the value is out-of-sync with the rendered options.\n        // detect such cases and filter out values that no longer has a matching\n        // option in the DOM.\n\n        var prevOptions = el._vOptions;\n        var curOptions = el._vOptions = [].map.call(el.options, getValue);\n\n        if (curOptions.some(function (o, i) {\n          return !looseEqual(o, prevOptions[i]);\n        })) {\n          // trigger change event if\n          // no matching option found for at least one value\n          var needReset = el.multiple ? binding.value.some(function (v) {\n            return hasNoMatchingOption(v, curOptions);\n          }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);\n\n          if (needReset) {\n            trigger(el, 'change');\n          }\n        }\n      }\n    }\n  };\n\n  function setSelected(el, binding, vm) {\n    actuallySetSelected(el, binding, vm);\n    /* istanbul ignore if */\n\n    if (isIE || isEdge) {\n      setTimeout(function () {\n        actuallySetSelected(el, binding, vm);\n      }, 0);\n    }\n  }\n\n  function actuallySetSelected(el, binding, vm) {\n    var value = binding.value;\n    var isMultiple = el.multiple;\n\n    if (isMultiple && !Array.isArray(value)) {\n      warn(\"<select multiple v-model=\\\"\" + binding.expression + \"\\\"> \" + \"expects an Array value for its binding, but got \" + Object.prototype.toString.call(value).slice(8, -1), vm);\n      return;\n    }\n\n    var selected, option;\n\n    for (var i = 0, l = el.options.length; i < l; i++) {\n      option = el.options[i];\n\n      if (isMultiple) {\n        selected = looseIndexOf(value, getValue(option)) > -1;\n\n        if (option.selected !== selected) {\n          option.selected = selected;\n        }\n      } else {\n        if (looseEqual(getValue(option), value)) {\n          if (el.selectedIndex !== i) {\n            el.selectedIndex = i;\n          }\n\n          return;\n        }\n      }\n    }\n\n    if (!isMultiple) {\n      el.selectedIndex = -1;\n    }\n  }\n\n  function hasNoMatchingOption(value, options) {\n    return options.every(function (o) {\n      return !looseEqual(o, value);\n    });\n  }\n\n  function getValue(option) {\n    return '_value' in option ? option._value : option.value;\n  }\n\n  function onCompositionStart(e) {\n    e.target.composing = true;\n  }\n\n  function onCompositionEnd(e) {\n    // prevent triggering an input event for no reason\n    if (!e.target.composing) {\n      return;\n    }\n\n    e.target.composing = false;\n    trigger(e.target, 'input');\n  }\n\n  function trigger(el, type) {\n    var e = document.createEvent('HTMLEvents');\n    e.initEvent(type, true, true);\n    el.dispatchEvent(e);\n  }\n  /*  */\n  // recursively search for possible transition defined inside the component root\n\n\n  function locateNode(vnode) {\n    return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;\n  }\n\n  var show = {\n    bind: function bind(el, ref, vnode) {\n      var value = ref.value;\n      vnode = locateNode(vnode);\n      var transition$$1 = vnode.data && vnode.data.transition;\n      var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;\n\n      if (value && transition$$1) {\n        vnode.data.show = true;\n        enter(vnode, function () {\n          el.style.display = originalDisplay;\n        });\n      } else {\n        el.style.display = value ? originalDisplay : 'none';\n      }\n    },\n    update: function update(el, ref, vnode) {\n      var value = ref.value;\n      var oldValue = ref.oldValue;\n      /* istanbul ignore if */\n\n      if (!value === !oldValue) {\n        return;\n      }\n\n      vnode = locateNode(vnode);\n      var transition$$1 = vnode.data && vnode.data.transition;\n\n      if (transition$$1) {\n        vnode.data.show = true;\n\n        if (value) {\n          enter(vnode, function () {\n            el.style.display = el.__vOriginalDisplay;\n          });\n        } else {\n          leave(vnode, function () {\n            el.style.display = 'none';\n          });\n        }\n      } else {\n        el.style.display = value ? el.__vOriginalDisplay : 'none';\n      }\n    },\n    unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {\n      if (!isDestroy) {\n        el.style.display = el.__vOriginalDisplay;\n      }\n    }\n  };\n  var platformDirectives = {\n    model: directive,\n    show: show\n  };\n  /*  */\n\n  var transitionProps = {\n    name: String,\n    appear: Boolean,\n    css: Boolean,\n    mode: String,\n    type: String,\n    enterClass: String,\n    leaveClass: String,\n    enterToClass: String,\n    leaveToClass: String,\n    enterActiveClass: String,\n    leaveActiveClass: String,\n    appearClass: String,\n    appearActiveClass: String,\n    appearToClass: String,\n    duration: [Number, String, Object]\n  }; // in case the child is also an abstract component, e.g. <keep-alive>\n  // we want to recursively retrieve the real component to be rendered\n\n  function getRealChild(vnode) {\n    var compOptions = vnode && vnode.componentOptions;\n\n    if (compOptions && compOptions.Ctor.options.abstract) {\n      return getRealChild(getFirstComponentChild(compOptions.children));\n    } else {\n      return vnode;\n    }\n  }\n\n  function extractTransitionData(comp) {\n    var data = {};\n    var options = comp.$options; // props\n\n    for (var key in options.propsData) {\n      data[key] = comp[key];\n    } // events.\n    // extract listeners and pass them directly to the transition methods\n\n\n    var listeners = options._parentListeners;\n\n    for (var key$1 in listeners) {\n      data[camelize(key$1)] = listeners[key$1];\n    }\n\n    return data;\n  }\n\n  function placeholder(h, rawChild) {\n    if (/\\d-keep-alive$/.test(rawChild.tag)) {\n      return h('keep-alive', {\n        props: rawChild.componentOptions.propsData\n      });\n    }\n  }\n\n  function hasParentTransition(vnode) {\n    while (vnode = vnode.parent) {\n      if (vnode.data.transition) {\n        return true;\n      }\n    }\n  }\n\n  function isSameChild(child, oldChild) {\n    return oldChild.key === child.key && oldChild.tag === child.tag;\n  }\n\n  var isNotTextNode = function isNotTextNode(c) {\n    return c.tag || isAsyncPlaceholder(c);\n  };\n\n  var isVShowDirective = function isVShowDirective(d) {\n    return d.name === 'show';\n  };\n\n  var Transition = {\n    name: 'transition',\n    props: transitionProps,\n    abstract: true,\n    render: function render(h) {\n      var this$1 = this;\n      var children = this.$slots.default;\n\n      if (!children) {\n        return;\n      } // filter out text nodes (possible whitespaces)\n\n\n      children = children.filter(isNotTextNode);\n      /* istanbul ignore if */\n\n      if (!children.length) {\n        return;\n      } // warn multiple elements\n\n\n      if (children.length > 1) {\n        warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);\n      }\n\n      var mode = this.mode; // warn invalid mode\n\n      if (mode && mode !== 'in-out' && mode !== 'out-in') {\n        warn('invalid <transition> mode: ' + mode, this.$parent);\n      }\n\n      var rawChild = children[0]; // if this is a component root node and the component's\n      // parent container node also has transition, skip.\n\n      if (hasParentTransition(this.$vnode)) {\n        return rawChild;\n      } // apply transition data to child\n      // use getRealChild() to ignore abstract components e.g. keep-alive\n\n\n      var child = getRealChild(rawChild);\n      /* istanbul ignore if */\n\n      if (!child) {\n        return rawChild;\n      }\n\n      if (this._leaving) {\n        return placeholder(h, rawChild);\n      } // ensure a key that is unique to the vnode type and to this transition\n      // component instance. This key will be used to remove pending leaving nodes\n      // during entering.\n\n\n      var id = \"__transition-\" + this._uid + \"-\";\n      child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;\n      var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n      var oldRawChild = this._vnode;\n      var oldChild = getRealChild(oldRawChild); // mark v-show\n      // so that the transition module can hand over the control to the directive\n\n      if (child.data.directives && child.data.directives.some(isVShowDirective)) {\n        child.data.show = true;\n      }\n\n      if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild) && // #6687 component root is a comment node\n      !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)) {\n        // replace old child transition data with fresh one\n        // important for dynamic transitions!\n        var oldData = oldChild.data.transition = extend({}, data); // handle transition mode\n\n        if (mode === 'out-in') {\n          // return placeholder node and queue update when leave finishes\n          this._leaving = true;\n          mergeVNodeHook(oldData, 'afterLeave', function () {\n            this$1._leaving = false;\n            this$1.$forceUpdate();\n          });\n          return placeholder(h, rawChild);\n        } else if (mode === 'in-out') {\n          if (isAsyncPlaceholder(child)) {\n            return oldRawChild;\n          }\n\n          var delayedLeave;\n\n          var performLeave = function performLeave() {\n            delayedLeave();\n          };\n\n          mergeVNodeHook(data, 'afterEnter', performLeave);\n          mergeVNodeHook(data, 'enterCancelled', performLeave);\n          mergeVNodeHook(oldData, 'delayLeave', function (leave) {\n            delayedLeave = leave;\n          });\n        }\n      }\n\n      return rawChild;\n    }\n  };\n  /*  */\n\n  var props = extend({\n    tag: String,\n    moveClass: String\n  }, transitionProps);\n  delete props.mode;\n  var TransitionGroup = {\n    props: props,\n    beforeMount: function beforeMount() {\n      var this$1 = this;\n      var update = this._update;\n\n      this._update = function (vnode, hydrating) {\n        var restoreActiveInstance = setActiveInstance(this$1); // force removing pass\n\n        this$1.__patch__(this$1._vnode, this$1.kept, false, // hydrating\n        true // removeOnly (!important, avoids unnecessary moves)\n        );\n\n        this$1._vnode = this$1.kept;\n        restoreActiveInstance();\n        update.call(this$1, vnode, hydrating);\n      };\n    },\n    render: function render(h) {\n      var tag = this.tag || this.$vnode.data.tag || 'span';\n      var map = Object.create(null);\n      var prevChildren = this.prevChildren = this.children;\n      var rawChildren = this.$slots.default || [];\n      var children = this.children = [];\n      var transitionData = extractTransitionData(this);\n\n      for (var i = 0; i < rawChildren.length; i++) {\n        var c = rawChildren[i];\n\n        if (c.tag) {\n          if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n            children.push(c);\n            map[c.key] = c;\n            (c.data || (c.data = {})).transition = transitionData;\n          } else {\n            var opts = c.componentOptions;\n            var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;\n            warn(\"<transition-group> children must be keyed: <\" + name + \">\");\n          }\n        }\n      }\n\n      if (prevChildren) {\n        var kept = [];\n        var removed = [];\n\n        for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n          var c$1 = prevChildren[i$1];\n          c$1.data.transition = transitionData;\n          c$1.data.pos = c$1.elm.getBoundingClientRect();\n\n          if (map[c$1.key]) {\n            kept.push(c$1);\n          } else {\n            removed.push(c$1);\n          }\n        }\n\n        this.kept = h(tag, null, kept);\n        this.removed = removed;\n      }\n\n      return h(tag, null, children);\n    },\n    updated: function updated() {\n      var children = this.prevChildren;\n      var moveClass = this.moveClass || (this.name || 'v') + '-move';\n\n      if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n        return;\n      } // we divide the work into three loops to avoid mixing DOM reads and writes\n      // in each iteration - which helps prevent layout thrashing.\n\n\n      children.forEach(callPendingCbs);\n      children.forEach(recordPosition);\n      children.forEach(applyTranslation); // force reflow to put everything in position\n      // assign to this to avoid being removed in tree-shaking\n      // $flow-disable-line\n\n      this._reflow = document.body.offsetHeight;\n      children.forEach(function (c) {\n        if (c.data.moved) {\n          var el = c.elm;\n          var s = el.style;\n          addTransitionClass(el, moveClass);\n          s.transform = s.WebkitTransform = s.transitionDuration = '';\n          el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {\n            if (e && e.target !== el) {\n              return;\n            }\n\n            if (!e || /transform$/.test(e.propertyName)) {\n              el.removeEventListener(transitionEndEvent, cb);\n              el._moveCb = null;\n              removeTransitionClass(el, moveClass);\n            }\n          });\n        }\n      });\n    },\n    methods: {\n      hasMove: function hasMove(el, moveClass) {\n        /* istanbul ignore if */\n        if (!hasTransition) {\n          return false;\n        }\n        /* istanbul ignore if */\n\n\n        if (this._hasMove) {\n          return this._hasMove;\n        } // Detect whether an element with the move class applied has\n        // CSS transitions. Since the element may be inside an entering\n        // transition at this very moment, we make a clone of it and remove\n        // all other transition classes applied to ensure only the move class\n        // is applied.\n\n\n        var clone = el.cloneNode();\n\n        if (el._transitionClasses) {\n          el._transitionClasses.forEach(function (cls) {\n            removeClass(clone, cls);\n          });\n        }\n\n        addClass(clone, moveClass);\n        clone.style.display = 'none';\n        this.$el.appendChild(clone);\n        var info = getTransitionInfo(clone);\n        this.$el.removeChild(clone);\n        return this._hasMove = info.hasTransform;\n      }\n    }\n  };\n\n  function callPendingCbs(c) {\n    /* istanbul ignore if */\n    if (c.elm._moveCb) {\n      c.elm._moveCb();\n    }\n    /* istanbul ignore if */\n\n\n    if (c.elm._enterCb) {\n      c.elm._enterCb();\n    }\n  }\n\n  function recordPosition(c) {\n    c.data.newPos = c.elm.getBoundingClientRect();\n  }\n\n  function applyTranslation(c) {\n    var oldPos = c.data.pos;\n    var newPos = c.data.newPos;\n    var dx = oldPos.left - newPos.left;\n    var dy = oldPos.top - newPos.top;\n\n    if (dx || dy) {\n      c.data.moved = true;\n      var s = c.elm.style;\n      s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n      s.transitionDuration = '0s';\n    }\n  }\n\n  var platformComponents = {\n    Transition: Transition,\n    TransitionGroup: TransitionGroup\n  };\n  /*  */\n  // install platform specific utils\n\n  Vue.config.mustUseProp = mustUseProp;\n  Vue.config.isReservedTag = isReservedTag;\n  Vue.config.isReservedAttr = isReservedAttr;\n  Vue.config.getTagNamespace = getTagNamespace;\n  Vue.config.isUnknownElement = isUnknownElement; // install platform runtime directives & components\n\n  extend(Vue.options.directives, platformDirectives);\n  extend(Vue.options.components, platformComponents); // install platform patch function\n\n  Vue.prototype.__patch__ = inBrowser ? patch : noop; // public mount method\n\n  Vue.prototype.$mount = function (el, hydrating) {\n    el = el && inBrowser ? query(el) : undefined;\n    return mountComponent(this, el, hydrating);\n  }; // devtools global hook\n\n  /* istanbul ignore next */\n\n\n  if (inBrowser) {\n    setTimeout(function () {\n      if (config.devtools) {\n        if (devtools) {\n          devtools.emit('init', Vue);\n        } else {\n          console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\\n' + 'https://github.com/vuejs/vue-devtools');\n        }\n      }\n\n      if (config.productionTip !== false && typeof console !== 'undefined') {\n        console[console.info ? 'info' : 'log'](\"You are running Vue in development mode.\\n\" + \"Make sure to turn on production mode when deploying for production.\\n\" + \"See more tips at https://vuejs.org/guide/deployment.html\");\n      }\n    }, 0);\n  }\n  /*  */\n\n\n  var defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g;\n  var regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n  var buildRegex = cached(function (delimiters) {\n    var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n    var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n    return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g');\n  });\n\n  function parseText(text, delimiters) {\n    var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n\n    if (!tagRE.test(text)) {\n      return;\n    }\n\n    var tokens = [];\n    var rawTokens = [];\n    var lastIndex = tagRE.lastIndex = 0;\n    var match, index, tokenValue;\n\n    while (match = tagRE.exec(text)) {\n      index = match.index; // push text token\n\n      if (index > lastIndex) {\n        rawTokens.push(tokenValue = text.slice(lastIndex, index));\n        tokens.push(JSON.stringify(tokenValue));\n      } // tag token\n\n\n      var exp = parseFilters(match[1].trim());\n      tokens.push(\"_s(\" + exp + \")\");\n      rawTokens.push({\n        '@binding': exp\n      });\n      lastIndex = index + match[0].length;\n    }\n\n    if (lastIndex < text.length) {\n      rawTokens.push(tokenValue = text.slice(lastIndex));\n      tokens.push(JSON.stringify(tokenValue));\n    }\n\n    return {\n      expression: tokens.join('+'),\n      tokens: rawTokens\n    };\n  }\n  /*  */\n\n\n  function transformNode(el, options) {\n    var warn = options.warn || baseWarn;\n    var staticClass = getAndRemoveAttr(el, 'class');\n\n    if (staticClass) {\n      var res = parseText(staticClass, options.delimiters);\n\n      if (res) {\n        warn(\"class=\\\"\" + staticClass + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.', el.rawAttrsMap['class']);\n      }\n    }\n\n    if (staticClass) {\n      el.staticClass = JSON.stringify(staticClass);\n    }\n\n    var classBinding = getBindingAttr(el, 'class', false\n    /* getStatic */\n    );\n\n    if (classBinding) {\n      el.classBinding = classBinding;\n    }\n  }\n\n  function genData(el) {\n    var data = '';\n\n    if (el.staticClass) {\n      data += \"staticClass:\" + el.staticClass + \",\";\n    }\n\n    if (el.classBinding) {\n      data += \"class:\" + el.classBinding + \",\";\n    }\n\n    return data;\n  }\n\n  var klass$1 = {\n    staticKeys: ['staticClass'],\n    transformNode: transformNode,\n    genData: genData\n  };\n  /*  */\n\n  function transformNode$1(el, options) {\n    var warn = options.warn || baseWarn;\n    var staticStyle = getAndRemoveAttr(el, 'style');\n\n    if (staticStyle) {\n      /* istanbul ignore if */\n      {\n        var res = parseText(staticStyle, options.delimiters);\n\n        if (res) {\n          warn(\"style=\\\"\" + staticStyle + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.', el.rawAttrsMap['style']);\n        }\n      }\n      el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n    }\n\n    var styleBinding = getBindingAttr(el, 'style', false\n    /* getStatic */\n    );\n\n    if (styleBinding) {\n      el.styleBinding = styleBinding;\n    }\n  }\n\n  function genData$1(el) {\n    var data = '';\n\n    if (el.staticStyle) {\n      data += \"staticStyle:\" + el.staticStyle + \",\";\n    }\n\n    if (el.styleBinding) {\n      data += \"style:(\" + el.styleBinding + \"),\";\n    }\n\n    return data;\n  }\n\n  var style$1 = {\n    staticKeys: ['staticStyle'],\n    transformNode: transformNode$1,\n    genData: genData$1\n  };\n  /*  */\n\n  var decoder;\n  var he = {\n    decode: function decode(html) {\n      decoder = decoder || document.createElement('div');\n      decoder.innerHTML = html;\n      return decoder.textContent;\n    }\n  };\n  /*  */\n\n  var isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' + 'link,meta,param,source,track,wbr'); // Elements that you can, intentionally, leave open\n  // (and which close themselves)\n\n  var canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'); // HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n  // Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\n\n  var isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' + 'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' + 'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' + 'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' + 'title,tr,track');\n  /**\n   * Not type-checking this file because it's mostly vendor code.\n   */\n  // Regular Expressions for parsing tags and attributes\n\n  var attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\n  var dynamicArgAttribute = /^\\s*((?:v-[\\w-]+:|@|:|#)\\[[^=]+\\][^\\s\"'<>\\/=]*)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\n  var ncname = \"[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z\" + unicodeRegExp.source + \"]*\";\n  var qnameCapture = \"((?:\" + ncname + \"\\\\:)?\" + ncname + \")\";\n  var startTagOpen = new RegExp(\"^<\" + qnameCapture);\n  var startTagClose = /^\\s*(\\/?)>/;\n  var endTag = new RegExp(\"^<\\\\/\" + qnameCapture + \"[^>]*>\");\n  var doctype = /^<!DOCTYPE [^>]+>/i; // #7298: escape - to avoid being pased as HTML comment when inlined in page\n\n  var comment = /^<!\\--/;\n  var conditionalComment = /^<!\\[/; // Special Elements (can contain anything)\n\n  var isPlainTextElement = makeMap('script,style,textarea', true);\n  var reCache = {};\n  var decodingMap = {\n    '&lt;': '<',\n    '&gt;': '>',\n    '&quot;': '\"',\n    '&amp;': '&',\n    '&#10;': '\\n',\n    '&#9;': '\\t',\n    '&#39;': \"'\"\n  };\n  var encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;\n  var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g; // #5992\n\n  var isIgnoreNewlineTag = makeMap('pre,textarea', true);\n\n  var shouldIgnoreFirstNewline = function shouldIgnoreFirstNewline(tag, html) {\n    return tag && isIgnoreNewlineTag(tag) && html[0] === '\\n';\n  };\n\n  function decodeAttr(value, shouldDecodeNewlines) {\n    var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n    return value.replace(re, function (match) {\n      return decodingMap[match];\n    });\n  }\n\n  function parseHTML(html, options) {\n    var stack = [];\n    var expectHTML = options.expectHTML;\n    var isUnaryTag$$1 = options.isUnaryTag || no;\n    var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n    var index = 0;\n    var last, lastTag;\n\n    while (html) {\n      last = html; // Make sure we're not in a plaintext content element like script/style\n\n      if (!lastTag || !isPlainTextElement(lastTag)) {\n        var textEnd = html.indexOf('<');\n\n        if (textEnd === 0) {\n          // Comment:\n          if (comment.test(html)) {\n            var commentEnd = html.indexOf('-->');\n\n            if (commentEnd >= 0) {\n              if (options.shouldKeepComment) {\n                options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);\n              }\n\n              advance(commentEnd + 3);\n              continue;\n            }\n          } // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n\n\n          if (conditionalComment.test(html)) {\n            var conditionalEnd = html.indexOf(']>');\n\n            if (conditionalEnd >= 0) {\n              advance(conditionalEnd + 2);\n              continue;\n            }\n          } // Doctype:\n\n\n          var doctypeMatch = html.match(doctype);\n\n          if (doctypeMatch) {\n            advance(doctypeMatch[0].length);\n            continue;\n          } // End tag:\n\n\n          var endTagMatch = html.match(endTag);\n\n          if (endTagMatch) {\n            var curIndex = index;\n            advance(endTagMatch[0].length);\n            parseEndTag(endTagMatch[1], curIndex, index);\n            continue;\n          } // Start tag:\n\n\n          var startTagMatch = parseStartTag();\n\n          if (startTagMatch) {\n            handleStartTag(startTagMatch);\n\n            if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {\n              advance(1);\n            }\n\n            continue;\n          }\n        }\n\n        var text = void 0,\n            rest = void 0,\n            next = void 0;\n\n        if (textEnd >= 0) {\n          rest = html.slice(textEnd);\n\n          while (!endTag.test(rest) && !startTagOpen.test(rest) && !comment.test(rest) && !conditionalComment.test(rest)) {\n            // < in plain text, be forgiving and treat it as text\n            next = rest.indexOf('<', 1);\n\n            if (next < 0) {\n              break;\n            }\n\n            textEnd += next;\n            rest = html.slice(textEnd);\n          }\n\n          text = html.substring(0, textEnd);\n        }\n\n        if (textEnd < 0) {\n          text = html;\n        }\n\n        if (text) {\n          advance(text.length);\n        }\n\n        if (options.chars && text) {\n          options.chars(text, index - text.length, index);\n        }\n      } else {\n        var endTagLength = 0;\n        var stackedTag = lastTag.toLowerCase();\n        var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n        var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {\n          endTagLength = endTag.length;\n\n          if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n            text = text.replace(/<!\\--([\\s\\S]*?)-->/g, '$1') // #7298\n            .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n          }\n\n          if (shouldIgnoreFirstNewline(stackedTag, text)) {\n            text = text.slice(1);\n          }\n\n          if (options.chars) {\n            options.chars(text);\n          }\n\n          return '';\n        });\n        index += html.length - rest$1.length;\n        html = rest$1;\n        parseEndTag(stackedTag, index - endTagLength, index);\n      }\n\n      if (html === last) {\n        options.chars && options.chars(html);\n\n        if (!stack.length && options.warn) {\n          options.warn(\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\", {\n            start: index + html.length\n          });\n        }\n\n        break;\n      }\n    } // Clean up any remaining tags\n\n\n    parseEndTag();\n\n    function advance(n) {\n      index += n;\n      html = html.substring(n);\n    }\n\n    function parseStartTag() {\n      var start = html.match(startTagOpen);\n\n      if (start) {\n        var match = {\n          tagName: start[1],\n          attrs: [],\n          start: index\n        };\n        advance(start[0].length);\n        var end, attr;\n\n        while (!(end = html.match(startTagClose)) && (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {\n          attr.start = index;\n          advance(attr[0].length);\n          attr.end = index;\n          match.attrs.push(attr);\n        }\n\n        if (end) {\n          match.unarySlash = end[1];\n          advance(end[0].length);\n          match.end = index;\n          return match;\n        }\n      }\n    }\n\n    function handleStartTag(match) {\n      var tagName = match.tagName;\n      var unarySlash = match.unarySlash;\n\n      if (expectHTML) {\n        if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n          parseEndTag(lastTag);\n        }\n\n        if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n          parseEndTag(tagName);\n        }\n      }\n\n      var unary = isUnaryTag$$1(tagName) || !!unarySlash;\n      var l = match.attrs.length;\n      var attrs = new Array(l);\n\n      for (var i = 0; i < l; i++) {\n        var args = match.attrs[i];\n        var value = args[3] || args[4] || args[5] || '';\n        var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href' ? options.shouldDecodeNewlinesForHref : options.shouldDecodeNewlines;\n        attrs[i] = {\n          name: args[1],\n          value: decodeAttr(value, shouldDecodeNewlines)\n        };\n\n        if (options.outputSourceRange) {\n          attrs[i].start = args.start + args[0].match(/^\\s*/).length;\n          attrs[i].end = args.end;\n        }\n      }\n\n      if (!unary) {\n        stack.push({\n          tag: tagName,\n          lowerCasedTag: tagName.toLowerCase(),\n          attrs: attrs,\n          start: match.start,\n          end: match.end\n        });\n        lastTag = tagName;\n      }\n\n      if (options.start) {\n        options.start(tagName, attrs, unary, match.start, match.end);\n      }\n    }\n\n    function parseEndTag(tagName, start, end) {\n      var pos, lowerCasedTagName;\n\n      if (start == null) {\n        start = index;\n      }\n\n      if (end == null) {\n        end = index;\n      } // Find the closest opened tag of the same type\n\n\n      if (tagName) {\n        lowerCasedTagName = tagName.toLowerCase();\n\n        for (pos = stack.length - 1; pos >= 0; pos--) {\n          if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n            break;\n          }\n        }\n      } else {\n        // If no tag name is provided, clean shop\n        pos = 0;\n      }\n\n      if (pos >= 0) {\n        // Close all the open elements, up the stack\n        for (var i = stack.length - 1; i >= pos; i--) {\n          if (i > pos || !tagName && options.warn) {\n            options.warn(\"tag <\" + stack[i].tag + \"> has no matching end tag.\", {\n              start: stack[i].start,\n              end: stack[i].end\n            });\n          }\n\n          if (options.end) {\n            options.end(stack[i].tag, start, end);\n          }\n        } // Remove the open elements from the stack\n\n\n        stack.length = pos;\n        lastTag = pos && stack[pos - 1].tag;\n      } else if (lowerCasedTagName === 'br') {\n        if (options.start) {\n          options.start(tagName, [], true, start, end);\n        }\n      } else if (lowerCasedTagName === 'p') {\n        if (options.start) {\n          options.start(tagName, [], false, start, end);\n        }\n\n        if (options.end) {\n          options.end(tagName, start, end);\n        }\n      }\n    }\n  }\n  /*  */\n\n\n  var onRE = /^@|^v-on:/;\n  var dirRE = /^v-|^@|^:/;\n  var forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\n  var forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\n  var stripParensRE = /^\\(|\\)$/g;\n  var dynamicArgRE = /^\\[.*\\]$/;\n  var argRE = /:(.*)$/;\n  var bindRE = /^:|^\\.|^v-bind:/;\n  var modifierRE = /\\.[^.\\]]+(?=[^\\]]*$)/g;\n  var slotRE = /^v-slot(:|$)|^#/;\n  var lineBreakRE = /[\\r\\n]/;\n  var whitespaceRE$1 = /\\s+/g;\n  var invalidAttributeRE = /[\\s\"'<>\\/=]/;\n  var decodeHTMLCached = cached(he.decode);\n  var emptySlotScopeToken = \"_empty_\"; // configurable state\n\n  var warn$2;\n  var delimiters;\n  var transforms;\n  var preTransforms;\n  var postTransforms;\n  var platformIsPreTag;\n  var platformMustUseProp;\n  var platformGetTagNamespace;\n  var maybeComponent;\n\n  function createASTElement(tag, attrs, parent) {\n    return {\n      type: 1,\n      tag: tag,\n      attrsList: attrs,\n      attrsMap: makeAttrsMap(attrs),\n      rawAttrsMap: {},\n      parent: parent,\n      children: []\n    };\n  }\n  /**\n   * Convert HTML string to AST.\n   */\n\n\n  function parse(template, options) {\n    warn$2 = options.warn || baseWarn;\n    platformIsPreTag = options.isPreTag || no;\n    platformMustUseProp = options.mustUseProp || no;\n    platformGetTagNamespace = options.getTagNamespace || no;\n    var isReservedTag = options.isReservedTag || no;\n\n    maybeComponent = function maybeComponent(el) {\n      return !!el.component || !isReservedTag(el.tag);\n    };\n\n    transforms = pluckModuleFunction(options.modules, 'transformNode');\n    preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n    postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n    delimiters = options.delimiters;\n    var stack = [];\n    var preserveWhitespace = options.preserveWhitespace !== false;\n    var whitespaceOption = options.whitespace;\n    var root;\n    var currentParent;\n    var inVPre = false;\n    var inPre = false;\n    var warned = false;\n\n    function warnOnce(msg, range) {\n      if (!warned) {\n        warned = true;\n        warn$2(msg, range);\n      }\n    }\n\n    function closeElement(element) {\n      trimEndingWhitespace(element);\n\n      if (!inVPre && !element.processed) {\n        element = processElement(element, options);\n      } // tree management\n\n\n      if (!stack.length && element !== root) {\n        // allow root elements with v-if, v-else-if and v-else\n        if (root.if && (element.elseif || element.else)) {\n          {\n            checkRootConstraints(element);\n          }\n          addIfCondition(root, {\n            exp: element.elseif,\n            block: element\n          });\n        } else {\n          warnOnce(\"Component template should contain exactly one root element. \" + \"If you are using v-if on multiple elements, \" + \"use v-else-if to chain them instead.\", {\n            start: element.start\n          });\n        }\n      }\n\n      if (currentParent && !element.forbidden) {\n        if (element.elseif || element.else) {\n          processIfConditions(element, currentParent);\n        } else {\n          if (element.slotScope) {\n            // scoped slot\n            // keep it in the children list so that v-else(-if) conditions can\n            // find it as the prev node.\n            var name = element.slotTarget || '\"default\"';\n            (currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n          }\n\n          currentParent.children.push(element);\n          element.parent = currentParent;\n        }\n      } // final children cleanup\n      // filter out scoped slots\n\n\n      element.children = element.children.filter(function (c) {\n        return !c.slotScope;\n      }); // remove trailing whitespace node again\n\n      trimEndingWhitespace(element); // check pre state\n\n      if (element.pre) {\n        inVPre = false;\n      }\n\n      if (platformIsPreTag(element.tag)) {\n        inPre = false;\n      } // apply post-transforms\n\n\n      for (var i = 0; i < postTransforms.length; i++) {\n        postTransforms[i](element, options);\n      }\n    }\n\n    function trimEndingWhitespace(el) {\n      // remove trailing whitespace node\n      if (!inPre) {\n        var lastNode;\n\n        while ((lastNode = el.children[el.children.length - 1]) && lastNode.type === 3 && lastNode.text === ' ') {\n          el.children.pop();\n        }\n      }\n    }\n\n    function checkRootConstraints(el) {\n      if (el.tag === 'slot' || el.tag === 'template') {\n        warnOnce(\"Cannot use <\" + el.tag + \"> as component root element because it may \" + 'contain multiple nodes.', {\n          start: el.start\n        });\n      }\n\n      if (el.attrsMap.hasOwnProperty('v-for')) {\n        warnOnce('Cannot use v-for on stateful component root element because ' + 'it renders multiple elements.', el.rawAttrsMap['v-for']);\n      }\n    }\n\n    parseHTML(template, {\n      warn: warn$2,\n      expectHTML: options.expectHTML,\n      isUnaryTag: options.isUnaryTag,\n      canBeLeftOpenTag: options.canBeLeftOpenTag,\n      shouldDecodeNewlines: options.shouldDecodeNewlines,\n      shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,\n      shouldKeepComment: options.comments,\n      outputSourceRange: options.outputSourceRange,\n      start: function start(tag, attrs, unary, start$1, end) {\n        // check namespace.\n        // inherit parent ns if there is one\n        var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag); // handle IE svg bug\n\n        /* istanbul ignore if */\n\n        if (isIE && ns === 'svg') {\n          attrs = guardIESVGBug(attrs);\n        }\n\n        var element = createASTElement(tag, attrs, currentParent);\n\n        if (ns) {\n          element.ns = ns;\n        }\n\n        {\n          if (options.outputSourceRange) {\n            element.start = start$1;\n            element.end = end;\n            element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) {\n              cumulated[attr.name] = attr;\n              return cumulated;\n            }, {});\n          }\n\n          attrs.forEach(function (attr) {\n            if (invalidAttributeRE.test(attr.name)) {\n              warn$2(\"Invalid dynamic argument expression: attribute names cannot contain \" + \"spaces, quotes, <, >, / or =.\", {\n                start: attr.start + attr.name.indexOf(\"[\"),\n                end: attr.start + attr.name.length\n              });\n            }\n          });\n        }\n\n        if (isForbiddenTag(element) && !isServerRendering()) {\n          element.forbidden = true;\n          warn$2('Templates should only be responsible for mapping the state to the ' + 'UI. Avoid placing tags with side-effects in your templates, such as ' + \"<\" + tag + \">\" + ', as they will not be parsed.', {\n            start: element.start\n          });\n        } // apply pre-transforms\n\n\n        for (var i = 0; i < preTransforms.length; i++) {\n          element = preTransforms[i](element, options) || element;\n        }\n\n        if (!inVPre) {\n          processPre(element);\n\n          if (element.pre) {\n            inVPre = true;\n          }\n        }\n\n        if (platformIsPreTag(element.tag)) {\n          inPre = true;\n        }\n\n        if (inVPre) {\n          processRawAttrs(element);\n        } else if (!element.processed) {\n          // structural directives\n          processFor(element);\n          processIf(element);\n          processOnce(element);\n        }\n\n        if (!root) {\n          root = element;\n          {\n            checkRootConstraints(root);\n          }\n        }\n\n        if (!unary) {\n          currentParent = element;\n          stack.push(element);\n        } else {\n          closeElement(element);\n        }\n      },\n      end: function end(tag, start, end$1) {\n        var element = stack[stack.length - 1]; // pop stack\n\n        stack.length -= 1;\n        currentParent = stack[stack.length - 1];\n\n        if (options.outputSourceRange) {\n          element.end = end$1;\n        }\n\n        closeElement(element);\n      },\n      chars: function chars(text, start, end) {\n        if (!currentParent) {\n          {\n            if (text === template) {\n              warnOnce('Component template requires a root element, rather than just text.', {\n                start: start\n              });\n            } else if (text = text.trim()) {\n              warnOnce(\"text \\\"\" + text + \"\\\" outside root element will be ignored.\", {\n                start: start\n              });\n            }\n          }\n          return;\n        } // IE textarea placeholder bug\n\n        /* istanbul ignore if */\n\n\n        if (isIE && currentParent.tag === 'textarea' && currentParent.attrsMap.placeholder === text) {\n          return;\n        }\n\n        var children = currentParent.children;\n\n        if (inPre || text.trim()) {\n          text = isTextTag(currentParent) ? text : decodeHTMLCached(text);\n        } else if (!children.length) {\n          // remove the whitespace-only node right after an opening tag\n          text = '';\n        } else if (whitespaceOption) {\n          if (whitespaceOption === 'condense') {\n            // in condense mode, remove the whitespace node if it contains\n            // line break, otherwise condense to a single space\n            text = lineBreakRE.test(text) ? '' : ' ';\n          } else {\n            text = ' ';\n          }\n        } else {\n          text = preserveWhitespace ? ' ' : '';\n        }\n\n        if (text) {\n          if (!inPre && whitespaceOption === 'condense') {\n            // condense consecutive whitespaces into single space\n            text = text.replace(whitespaceRE$1, ' ');\n          }\n\n          var res;\n          var child;\n\n          if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {\n            child = {\n              type: 2,\n              expression: res.expression,\n              tokens: res.tokens,\n              text: text\n            };\n          } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n            child = {\n              type: 3,\n              text: text\n            };\n          }\n\n          if (child) {\n            if (options.outputSourceRange) {\n              child.start = start;\n              child.end = end;\n            }\n\n            children.push(child);\n          }\n        }\n      },\n      comment: function comment(text, start, end) {\n        // adding anyting as a sibling to the root node is forbidden\n        // comments should still be allowed, but ignored\n        if (currentParent) {\n          var child = {\n            type: 3,\n            text: text,\n            isComment: true\n          };\n\n          if (options.outputSourceRange) {\n            child.start = start;\n            child.end = end;\n          }\n\n          currentParent.children.push(child);\n        }\n      }\n    });\n    return root;\n  }\n\n  function processPre(el) {\n    if (getAndRemoveAttr(el, 'v-pre') != null) {\n      el.pre = true;\n    }\n  }\n\n  function processRawAttrs(el) {\n    var list = el.attrsList;\n    var len = list.length;\n\n    if (len) {\n      var attrs = el.attrs = new Array(len);\n\n      for (var i = 0; i < len; i++) {\n        attrs[i] = {\n          name: list[i].name,\n          value: JSON.stringify(list[i].value)\n        };\n\n        if (list[i].start != null) {\n          attrs[i].start = list[i].start;\n          attrs[i].end = list[i].end;\n        }\n      }\n    } else if (!el.pre) {\n      // non root node in pre blocks with no attributes\n      el.plain = true;\n    }\n  }\n\n  function processElement(element, options) {\n    processKey(element); // determine whether this is a plain element after\n    // removing structural attributes\n\n    element.plain = !element.key && !element.scopedSlots && !element.attrsList.length;\n    processRef(element);\n    processSlotContent(element);\n    processSlotOutlet(element);\n    processComponent(element);\n\n    for (var i = 0; i < transforms.length; i++) {\n      element = transforms[i](element, options) || element;\n    }\n\n    processAttrs(element);\n    return element;\n  }\n\n  function processKey(el) {\n    var exp = getBindingAttr(el, 'key');\n\n    if (exp) {\n      {\n        if (el.tag === 'template') {\n          warn$2(\"<template> cannot be keyed. Place the key on real elements instead.\", getRawBindingAttr(el, 'key'));\n        }\n\n        if (el.for) {\n          var iterator = el.iterator2 || el.iterator1;\n          var parent = el.parent;\n\n          if (iterator && iterator === exp && parent && parent.tag === 'transition-group') {\n            warn$2(\"Do not use v-for index as key on <transition-group> children, \" + \"this is the same as not using keys.\", getRawBindingAttr(el, 'key'), true\n            /* tip */\n            );\n          }\n        }\n      }\n      el.key = exp;\n    }\n  }\n\n  function processRef(el) {\n    var ref = getBindingAttr(el, 'ref');\n\n    if (ref) {\n      el.ref = ref;\n      el.refInFor = checkInFor(el);\n    }\n  }\n\n  function processFor(el) {\n    var exp;\n\n    if (exp = getAndRemoveAttr(el, 'v-for')) {\n      var res = parseFor(exp);\n\n      if (res) {\n        extend(el, res);\n      } else {\n        warn$2(\"Invalid v-for expression: \" + exp, el.rawAttrsMap['v-for']);\n      }\n    }\n  }\n\n  function parseFor(exp) {\n    var inMatch = exp.match(forAliasRE);\n\n    if (!inMatch) {\n      return;\n    }\n\n    var res = {};\n    res.for = inMatch[2].trim();\n    var alias = inMatch[1].trim().replace(stripParensRE, '');\n    var iteratorMatch = alias.match(forIteratorRE);\n\n    if (iteratorMatch) {\n      res.alias = alias.replace(forIteratorRE, '').trim();\n      res.iterator1 = iteratorMatch[1].trim();\n\n      if (iteratorMatch[2]) {\n        res.iterator2 = iteratorMatch[2].trim();\n      }\n    } else {\n      res.alias = alias;\n    }\n\n    return res;\n  }\n\n  function processIf(el) {\n    var exp = getAndRemoveAttr(el, 'v-if');\n\n    if (exp) {\n      el.if = exp;\n      addIfCondition(el, {\n        exp: exp,\n        block: el\n      });\n    } else {\n      if (getAndRemoveAttr(el, 'v-else') != null) {\n        el.else = true;\n      }\n\n      var elseif = getAndRemoveAttr(el, 'v-else-if');\n\n      if (elseif) {\n        el.elseif = elseif;\n      }\n    }\n  }\n\n  function processIfConditions(el, parent) {\n    var prev = findPrevElement(parent.children);\n\n    if (prev && prev.if) {\n      addIfCondition(prev, {\n        exp: el.elseif,\n        block: el\n      });\n    } else {\n      warn$2(\"v-\" + (el.elseif ? 'else-if=\"' + el.elseif + '\"' : 'else') + \" \" + \"used on element <\" + el.tag + \"> without corresponding v-if.\", el.rawAttrsMap[el.elseif ? 'v-else-if' : 'v-else']);\n    }\n  }\n\n  function findPrevElement(children) {\n    var i = children.length;\n\n    while (i--) {\n      if (children[i].type === 1) {\n        return children[i];\n      } else {\n        if (children[i].text !== ' ') {\n          warn$2(\"text \\\"\" + children[i].text.trim() + \"\\\" between v-if and v-else(-if) \" + \"will be ignored.\", children[i]);\n        }\n\n        children.pop();\n      }\n    }\n  }\n\n  function addIfCondition(el, condition) {\n    if (!el.ifConditions) {\n      el.ifConditions = [];\n    }\n\n    el.ifConditions.push(condition);\n  }\n\n  function processOnce(el) {\n    var once$$1 = getAndRemoveAttr(el, 'v-once');\n\n    if (once$$1 != null) {\n      el.once = true;\n    }\n  } // handle content being passed to a component as slot,\n  // e.g. <template slot=\"xxx\">, <div slot-scope=\"xxx\">\n\n\n  function processSlotContent(el) {\n    var slotScope;\n\n    if (el.tag === 'template') {\n      slotScope = getAndRemoveAttr(el, 'scope');\n      /* istanbul ignore if */\n\n      if (slotScope) {\n        warn$2(\"the \\\"scope\\\" attribute for scoped slots have been deprecated and \" + \"replaced by \\\"slot-scope\\\" since 2.5. The new \\\"slot-scope\\\" attribute \" + \"can also be used on plain elements in addition to <template> to \" + \"denote scoped slots.\", el.rawAttrsMap['scope'], true);\n      }\n\n      el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');\n    } else if (slotScope = getAndRemoveAttr(el, 'slot-scope')) {\n      /* istanbul ignore if */\n      if (el.attrsMap['v-for']) {\n        warn$2(\"Ambiguous combined usage of slot-scope and v-for on <\" + el.tag + \"> \" + \"(v-for takes higher priority). Use a wrapper <template> for the \" + \"scoped slot to make it clearer.\", el.rawAttrsMap['slot-scope'], true);\n      }\n\n      el.slotScope = slotScope;\n    } // slot=\"xxx\"\n\n\n    var slotTarget = getBindingAttr(el, 'slot');\n\n    if (slotTarget) {\n      el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n      el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']); // preserve slot as an attribute for native shadow DOM compat\n      // only for non-scoped slots.\n\n      if (el.tag !== 'template' && !el.slotScope) {\n        addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));\n      }\n    } // 2.6 v-slot syntax\n\n\n    {\n      if (el.tag === 'template') {\n        // v-slot on <template>\n        var slotBinding = getAndRemoveAttrByRegex(el, slotRE);\n\n        if (slotBinding) {\n          {\n            if (el.slotTarget || el.slotScope) {\n              warn$2(\"Unexpected mixed usage of different slot syntaxes.\", el);\n            }\n\n            if (el.parent && !maybeComponent(el.parent)) {\n              warn$2(\"<template v-slot> can only appear at the root level inside \" + \"the receiving the component\", el);\n            }\n          }\n          var ref = getSlotName(slotBinding);\n          var name = ref.name;\n          var dynamic = ref.dynamic;\n          el.slotTarget = name;\n          el.slotTargetDynamic = dynamic;\n          el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf\n        }\n      } else {\n        // v-slot on component, denotes default slot\n        var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE);\n\n        if (slotBinding$1) {\n          {\n            if (!maybeComponent(el)) {\n              warn$2(\"v-slot can only be used on components or <template>.\", slotBinding$1);\n            }\n\n            if (el.slotScope || el.slotTarget) {\n              warn$2(\"Unexpected mixed usage of different slot syntaxes.\", el);\n            }\n\n            if (el.scopedSlots) {\n              warn$2(\"To avoid scope ambiguity, the default slot should also use \" + \"<template> syntax when there are other named slots.\", slotBinding$1);\n            }\n          } // add the component's children to its default slot\n\n          var slots = el.scopedSlots || (el.scopedSlots = {});\n          var ref$1 = getSlotName(slotBinding$1);\n          var name$1 = ref$1.name;\n          var dynamic$1 = ref$1.dynamic;\n          var slotContainer = slots[name$1] = createASTElement('template', [], el);\n          slotContainer.slotTarget = name$1;\n          slotContainer.slotTargetDynamic = dynamic$1;\n          slotContainer.children = el.children.filter(function (c) {\n            if (!c.slotScope) {\n              c.parent = slotContainer;\n              return true;\n            }\n          });\n          slotContainer.slotScope = slotBinding$1.value || emptySlotScopeToken; // remove children as they are returned from scopedSlots now\n\n          el.children = []; // mark el non-plain so data gets generated\n\n          el.plain = false;\n        }\n      }\n    }\n  }\n\n  function getSlotName(binding) {\n    var name = binding.name.replace(slotRE, '');\n\n    if (!name) {\n      if (binding.name[0] !== '#') {\n        name = 'default';\n      } else {\n        warn$2(\"v-slot shorthand syntax requires a slot name.\", binding);\n      }\n    }\n\n    return dynamicArgRE.test(name) // dynamic [name]\n    ? {\n      name: name.slice(1, -1),\n      dynamic: true // static name\n\n    } : {\n      name: \"\\\"\" + name + \"\\\"\",\n      dynamic: false\n    };\n  } // handle <slot/> outlets\n\n\n  function processSlotOutlet(el) {\n    if (el.tag === 'slot') {\n      el.slotName = getBindingAttr(el, 'name');\n\n      if (el.key) {\n        warn$2(\"`key` does not work on <slot> because slots are abstract outlets \" + \"and can possibly expand into multiple elements. \" + \"Use the key on a wrapping element instead.\", getRawBindingAttr(el, 'key'));\n      }\n    }\n  }\n\n  function processComponent(el) {\n    var binding;\n\n    if (binding = getBindingAttr(el, 'is')) {\n      el.component = binding;\n    }\n\n    if (getAndRemoveAttr(el, 'inline-template') != null) {\n      el.inlineTemplate = true;\n    }\n  }\n\n  function processAttrs(el) {\n    var list = el.attrsList;\n    var i, l, name, rawName, value, modifiers, syncGen, isDynamic;\n\n    for (i = 0, l = list.length; i < l; i++) {\n      name = rawName = list[i].name;\n      value = list[i].value;\n\n      if (dirRE.test(name)) {\n        // mark element as dynamic\n        el.hasBindings = true; // modifiers\n\n        modifiers = parseModifiers(name.replace(dirRE, '')); // support .foo shorthand syntax for the .prop modifier\n\n        if (modifiers) {\n          name = name.replace(modifierRE, '');\n        }\n\n        if (bindRE.test(name)) {\n          // v-bind\n          name = name.replace(bindRE, '');\n          value = parseFilters(value);\n          isDynamic = dynamicArgRE.test(name);\n\n          if (isDynamic) {\n            name = name.slice(1, -1);\n          }\n\n          if (value.trim().length === 0) {\n            warn$2(\"The value for a v-bind expression cannot be empty. Found in \\\"v-bind:\" + name + \"\\\"\");\n          }\n\n          if (modifiers) {\n            if (modifiers.prop && !isDynamic) {\n              name = camelize(name);\n\n              if (name === 'innerHtml') {\n                name = 'innerHTML';\n              }\n            }\n\n            if (modifiers.camel && !isDynamic) {\n              name = camelize(name);\n            }\n\n            if (modifiers.sync) {\n              syncGen = genAssignmentCode(value, \"$event\");\n\n              if (!isDynamic) {\n                addHandler(el, \"update:\" + camelize(name), syncGen, null, false, warn$2, list[i]);\n\n                if (hyphenate(name) !== camelize(name)) {\n                  addHandler(el, \"update:\" + hyphenate(name), syncGen, null, false, warn$2, list[i]);\n                }\n              } else {\n                // handler w/ dynamic event name\n                addHandler(el, \"\\\"update:\\\"+(\" + name + \")\", syncGen, null, false, warn$2, list[i], true // dynamic\n                );\n              }\n            }\n          }\n\n          if (modifiers && modifiers.prop || !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n            addProp(el, name, value, list[i], isDynamic);\n          } else {\n            addAttr(el, name, value, list[i], isDynamic);\n          }\n        } else if (onRE.test(name)) {\n          // v-on\n          name = name.replace(onRE, '');\n          isDynamic = dynamicArgRE.test(name);\n\n          if (isDynamic) {\n            name = name.slice(1, -1);\n          }\n\n          addHandler(el, name, value, modifiers, false, warn$2, list[i], isDynamic);\n        } else {\n          // normal directives\n          name = name.replace(dirRE, ''); // parse arg\n\n          var argMatch = name.match(argRE);\n          var arg = argMatch && argMatch[1];\n          isDynamic = false;\n\n          if (arg) {\n            name = name.slice(0, -(arg.length + 1));\n\n            if (dynamicArgRE.test(arg)) {\n              arg = arg.slice(1, -1);\n              isDynamic = true;\n            }\n          }\n\n          addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);\n\n          if (name === 'model') {\n            checkForAliasModel(el, value);\n          }\n        }\n      } else {\n        // literal attribute\n        {\n          var res = parseText(value, delimiters);\n\n          if (res) {\n            warn$2(name + \"=\\\"\" + value + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.', list[i]);\n          }\n        }\n        addAttr(el, name, JSON.stringify(value), list[i]); // #6887 firefox doesn't update muted state if set via attribute\n        // even immediately after element creation\n\n        if (!el.component && name === 'muted' && platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n          addProp(el, name, 'true', list[i]);\n        }\n      }\n    }\n  }\n\n  function checkInFor(el) {\n    var parent = el;\n\n    while (parent) {\n      if (parent.for !== undefined) {\n        return true;\n      }\n\n      parent = parent.parent;\n    }\n\n    return false;\n  }\n\n  function parseModifiers(name) {\n    var match = name.match(modifierRE);\n\n    if (match) {\n      var ret = {};\n      match.forEach(function (m) {\n        ret[m.slice(1)] = true;\n      });\n      return ret;\n    }\n  }\n\n  function makeAttrsMap(attrs) {\n    var map = {};\n\n    for (var i = 0, l = attrs.length; i < l; i++) {\n      if (map[attrs[i].name] && !isIE && !isEdge) {\n        warn$2('duplicate attribute: ' + attrs[i].name, attrs[i]);\n      }\n\n      map[attrs[i].name] = attrs[i].value;\n    }\n\n    return map;\n  } // for script (e.g. type=\"x/template\") or style, do not decode content\n\n\n  function isTextTag(el) {\n    return el.tag === 'script' || el.tag === 'style';\n  }\n\n  function isForbiddenTag(el) {\n    return el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');\n  }\n\n  var ieNSBug = /^xmlns:NS\\d+/;\n  var ieNSPrefix = /^NS\\d+:/;\n  /* istanbul ignore next */\n\n  function guardIESVGBug(attrs) {\n    var res = [];\n\n    for (var i = 0; i < attrs.length; i++) {\n      var attr = attrs[i];\n\n      if (!ieNSBug.test(attr.name)) {\n        attr.name = attr.name.replace(ieNSPrefix, '');\n        res.push(attr);\n      }\n    }\n\n    return res;\n  }\n\n  function checkForAliasModel(el, value) {\n    var _el = el;\n\n    while (_el) {\n      if (_el.for && _el.alias === value) {\n        warn$2(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\">: \" + \"You are binding v-model directly to a v-for iteration alias. \" + \"This will not be able to modify the v-for source array because \" + \"writing to the alias is like modifying a function local variable. \" + \"Consider using an array of objects and use v-model on an object property instead.\", el.rawAttrsMap['v-model']);\n      }\n\n      _el = _el.parent;\n    }\n  }\n  /*  */\n\n\n  function preTransformNode(el, options) {\n    if (el.tag === 'input') {\n      var map = el.attrsMap;\n\n      if (!map['v-model']) {\n        return;\n      }\n\n      var typeBinding;\n\n      if (map[':type'] || map['v-bind:type']) {\n        typeBinding = getBindingAttr(el, 'type');\n      }\n\n      if (!map.type && !typeBinding && map['v-bind']) {\n        typeBinding = \"(\" + map['v-bind'] + \").type\";\n      }\n\n      if (typeBinding) {\n        var ifCondition = getAndRemoveAttr(el, 'v-if', true);\n        var ifConditionExtra = ifCondition ? \"&&(\" + ifCondition + \")\" : \"\";\n        var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;\n        var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true); // 1. checkbox\n\n        var branch0 = cloneASTElement(el); // process for on the main node\n\n        processFor(branch0);\n        addRawAttr(branch0, 'type', 'checkbox');\n        processElement(branch0, options);\n        branch0.processed = true; // prevent it from double-processed\n\n        branch0.if = \"(\" + typeBinding + \")==='checkbox'\" + ifConditionExtra;\n        addIfCondition(branch0, {\n          exp: branch0.if,\n          block: branch0\n        }); // 2. add radio else-if condition\n\n        var branch1 = cloneASTElement(el);\n        getAndRemoveAttr(branch1, 'v-for', true);\n        addRawAttr(branch1, 'type', 'radio');\n        processElement(branch1, options);\n        addIfCondition(branch0, {\n          exp: \"(\" + typeBinding + \")==='radio'\" + ifConditionExtra,\n          block: branch1\n        }); // 3. other\n\n        var branch2 = cloneASTElement(el);\n        getAndRemoveAttr(branch2, 'v-for', true);\n        addRawAttr(branch2, ':type', typeBinding);\n        processElement(branch2, options);\n        addIfCondition(branch0, {\n          exp: ifCondition,\n          block: branch2\n        });\n\n        if (hasElse) {\n          branch0.else = true;\n        } else if (elseIfCondition) {\n          branch0.elseif = elseIfCondition;\n        }\n\n        return branch0;\n      }\n    }\n  }\n\n  function cloneASTElement(el) {\n    return createASTElement(el.tag, el.attrsList.slice(), el.parent);\n  }\n\n  var model$1 = {\n    preTransformNode: preTransformNode\n  };\n  var modules$1 = [klass$1, style$1, model$1];\n  /*  */\n\n  function text(el, dir) {\n    if (dir.value) {\n      addProp(el, 'textContent', \"_s(\" + dir.value + \")\", dir);\n    }\n  }\n  /*  */\n\n\n  function html(el, dir) {\n    if (dir.value) {\n      addProp(el, 'innerHTML', \"_s(\" + dir.value + \")\", dir);\n    }\n  }\n\n  var directives$1 = {\n    model: model,\n    text: text,\n    html: html\n  };\n  /*  */\n\n  var baseOptions = {\n    expectHTML: true,\n    modules: modules$1,\n    directives: directives$1,\n    isPreTag: isPreTag,\n    isUnaryTag: isUnaryTag,\n    mustUseProp: mustUseProp,\n    canBeLeftOpenTag: canBeLeftOpenTag,\n    isReservedTag: isReservedTag,\n    getTagNamespace: getTagNamespace,\n    staticKeys: genStaticKeys(modules$1)\n  };\n  /*  */\n\n  var isStaticKey;\n  var isPlatformReservedTag;\n  var genStaticKeysCached = cached(genStaticKeys$1);\n  /**\n   * Goal of the optimizer: walk the generated template AST tree\n   * and detect sub-trees that are purely static, i.e. parts of\n   * the DOM that never needs to change.\n   *\n   * Once we detect these sub-trees, we can:\n   *\n   * 1. Hoist them into constants, so that we no longer need to\n   *    create fresh nodes for them on each re-render;\n   * 2. Completely skip them in the patching process.\n   */\n\n  function optimize(root, options) {\n    if (!root) {\n      return;\n    }\n\n    isStaticKey = genStaticKeysCached(options.staticKeys || '');\n    isPlatformReservedTag = options.isReservedTag || no; // first pass: mark all non-static nodes.\n\n    markStatic$1(root); // second pass: mark static roots.\n\n    markStaticRoots(root, false);\n  }\n\n  function genStaticKeys$1(keys) {\n    return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' + (keys ? ',' + keys : ''));\n  }\n\n  function markStatic$1(node) {\n    node.static = isStatic(node);\n\n    if (node.type === 1) {\n      // do not make component slot content static. this avoids\n      // 1. components not able to mutate slot nodes\n      // 2. static slot content fails for hot-reloading\n      if (!isPlatformReservedTag(node.tag) && node.tag !== 'slot' && node.attrsMap['inline-template'] == null) {\n        return;\n      }\n\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        var child = node.children[i];\n        markStatic$1(child);\n\n        if (!child.static) {\n          node.static = false;\n        }\n      }\n\n      if (node.ifConditions) {\n        for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n          var block = node.ifConditions[i$1].block;\n          markStatic$1(block);\n\n          if (!block.static) {\n            node.static = false;\n          }\n        }\n      }\n    }\n  }\n\n  function markStaticRoots(node, isInFor) {\n    if (node.type === 1) {\n      if (node.static || node.once) {\n        node.staticInFor = isInFor;\n      } // For a node to qualify as a static root, it should have children that\n      // are not just static text. Otherwise the cost of hoisting out will\n      // outweigh the benefits and it's better off to just always render it fresh.\n\n\n      if (node.static && node.children.length && !(node.children.length === 1 && node.children[0].type === 3)) {\n        node.staticRoot = true;\n        return;\n      } else {\n        node.staticRoot = false;\n      }\n\n      if (node.children) {\n        for (var i = 0, l = node.children.length; i < l; i++) {\n          markStaticRoots(node.children[i], isInFor || !!node.for);\n        }\n      }\n\n      if (node.ifConditions) {\n        for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n          markStaticRoots(node.ifConditions[i$1].block, isInFor);\n        }\n      }\n    }\n  }\n\n  function isStatic(node) {\n    if (node.type === 2) {\n      // expression\n      return false;\n    }\n\n    if (node.type === 3) {\n      // text\n      return true;\n    }\n\n    return !!(node.pre || !node.hasBindings && // no dynamic bindings\n    !node.if && !node.for && // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) && // not a built-in\n    isPlatformReservedTag(node.tag) && // not a component\n    !isDirectChildOfTemplateFor(node) && Object.keys(node).every(isStaticKey));\n  }\n\n  function isDirectChildOfTemplateFor(node) {\n    while (node.parent) {\n      node = node.parent;\n\n      if (node.tag !== 'template') {\n        return false;\n      }\n\n      if (node.for) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /*  */\n\n\n  var fnExpRE = /^([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*(?:[\\w$]+)?\\s*\\(/;\n  var fnInvokeRE = /\\([^)]*?\\);*$/;\n  var simplePathRE = /^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['[^']*?']|\\[\"[^\"]*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*$/; // KeyboardEvent.keyCode aliases\n\n  var keyCodes = {\n    esc: 27,\n    tab: 9,\n    enter: 13,\n    space: 32,\n    up: 38,\n    left: 37,\n    right: 39,\n    down: 40,\n    'delete': [8, 46]\n  }; // KeyboardEvent.key aliases\n\n  var keyNames = {\n    // #7880: IE11 and Edge use `Esc` for Escape key name.\n    esc: ['Esc', 'Escape'],\n    tab: 'Tab',\n    enter: 'Enter',\n    // #9112: IE11 uses `Spacebar` for Space key name.\n    space: [' ', 'Spacebar'],\n    // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.\n    up: ['Up', 'ArrowUp'],\n    left: ['Left', 'ArrowLeft'],\n    right: ['Right', 'ArrowRight'],\n    down: ['Down', 'ArrowDown'],\n    // #9112: IE11 uses `Del` for Delete key name.\n    'delete': ['Backspace', 'Delete', 'Del']\n  }; // #4868: modifiers that prevent the execution of the listener\n  // need to explicitly return null so that we can determine whether to remove\n  // the listener for .once\n\n  var genGuard = function genGuard(condition) {\n    return \"if(\" + condition + \")return null;\";\n  };\n\n  var modifierCode = {\n    stop: '$event.stopPropagation();',\n    prevent: '$event.preventDefault();',\n    self: genGuard(\"$event.target !== $event.currentTarget\"),\n    ctrl: genGuard(\"!$event.ctrlKey\"),\n    shift: genGuard(\"!$event.shiftKey\"),\n    alt: genGuard(\"!$event.altKey\"),\n    meta: genGuard(\"!$event.metaKey\"),\n    left: genGuard(\"'button' in $event && $event.button !== 0\"),\n    middle: genGuard(\"'button' in $event && $event.button !== 1\"),\n    right: genGuard(\"'button' in $event && $event.button !== 2\")\n  };\n\n  function genHandlers(events, isNative) {\n    var prefix = isNative ? 'nativeOn:' : 'on:';\n    var staticHandlers = \"\";\n    var dynamicHandlers = \"\";\n\n    for (var name in events) {\n      var handlerCode = genHandler(events[name]);\n\n      if (events[name] && events[name].dynamic) {\n        dynamicHandlers += name + \",\" + handlerCode + \",\";\n      } else {\n        staticHandlers += \"\\\"\" + name + \"\\\":\" + handlerCode + \",\";\n      }\n    }\n\n    staticHandlers = \"{\" + staticHandlers.slice(0, -1) + \"}\";\n\n    if (dynamicHandlers) {\n      return prefix + \"_d(\" + staticHandlers + \",[\" + dynamicHandlers.slice(0, -1) + \"])\";\n    } else {\n      return prefix + staticHandlers;\n    }\n  }\n\n  function genHandler(handler) {\n    if (!handler) {\n      return 'function(){}';\n    }\n\n    if (Array.isArray(handler)) {\n      return \"[\" + handler.map(function (handler) {\n        return genHandler(handler);\n      }).join(',') + \"]\";\n    }\n\n    var isMethodPath = simplePathRE.test(handler.value);\n    var isFunctionExpression = fnExpRE.test(handler.value);\n    var isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));\n\n    if (!handler.modifiers) {\n      if (isMethodPath || isFunctionExpression) {\n        return handler.value;\n      }\n\n      return \"function($event){\" + (isFunctionInvocation ? \"return \" + handler.value : handler.value) + \"}\"; // inline statement\n    } else {\n      var code = '';\n      var genModifierCode = '';\n      var keys = [];\n\n      for (var key in handler.modifiers) {\n        if (modifierCode[key]) {\n          genModifierCode += modifierCode[key]; // left/right\n\n          if (keyCodes[key]) {\n            keys.push(key);\n          }\n        } else if (key === 'exact') {\n          var modifiers = handler.modifiers;\n          genModifierCode += genGuard(['ctrl', 'shift', 'alt', 'meta'].filter(function (keyModifier) {\n            return !modifiers[keyModifier];\n          }).map(function (keyModifier) {\n            return \"$event.\" + keyModifier + \"Key\";\n          }).join('||'));\n        } else {\n          keys.push(key);\n        }\n      }\n\n      if (keys.length) {\n        code += genKeyFilter(keys);\n      } // Make sure modifiers like prevent and stop get executed after key filtering\n\n\n      if (genModifierCode) {\n        code += genModifierCode;\n      }\n\n      var handlerCode = isMethodPath ? \"return \" + handler.value + \"($event)\" : isFunctionExpression ? \"return (\" + handler.value + \")($event)\" : isFunctionInvocation ? \"return \" + handler.value : handler.value;\n      return \"function($event){\" + code + handlerCode + \"}\";\n    }\n  }\n\n  function genKeyFilter(keys) {\n    return (// make sure the key filters only apply to KeyboardEvents\n      // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake\n      // key events that do not have keyCode property...\n      \"if(!$event.type.indexOf('key')&&\" + keys.map(genFilterCode).join('&&') + \")return null;\"\n    );\n  }\n\n  function genFilterCode(key) {\n    var keyVal = parseInt(key, 10);\n\n    if (keyVal) {\n      return \"$event.keyCode!==\" + keyVal;\n    }\n\n    var keyCode = keyCodes[key];\n    var keyName = keyNames[key];\n    return \"_k($event.keyCode,\" + JSON.stringify(key) + \",\" + JSON.stringify(keyCode) + \",\" + \"$event.key,\" + \"\" + JSON.stringify(keyName) + \")\";\n  }\n  /*  */\n\n\n  function on(el, dir) {\n    if (dir.modifiers) {\n      warn(\"v-on without argument does not support modifiers.\");\n    }\n\n    el.wrapListeners = function (code) {\n      return \"_g(\" + code + \",\" + dir.value + \")\";\n    };\n  }\n  /*  */\n\n\n  function bind$1(el, dir) {\n    el.wrapData = function (code) {\n      return \"_b(\" + code + \",'\" + el.tag + \"',\" + dir.value + \",\" + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + \")\";\n    };\n  }\n  /*  */\n\n\n  var baseDirectives = {\n    on: on,\n    bind: bind$1,\n    cloak: noop\n  };\n  /*  */\n\n  var CodegenState = function CodegenState(options) {\n    this.options = options;\n    this.warn = options.warn || baseWarn;\n    this.transforms = pluckModuleFunction(options.modules, 'transformCode');\n    this.dataGenFns = pluckModuleFunction(options.modules, 'genData');\n    this.directives = extend(extend({}, baseDirectives), options.directives);\n    var isReservedTag = options.isReservedTag || no;\n\n    this.maybeComponent = function (el) {\n      return !!el.component || !isReservedTag(el.tag);\n    };\n\n    this.onceId = 0;\n    this.staticRenderFns = [];\n    this.pre = false;\n  };\n\n  function generate(ast, options) {\n    var state = new CodegenState(options);\n    var code = ast ? genElement(ast, state) : '_c(\"div\")';\n    return {\n      render: \"with(this){return \" + code + \"}\",\n      staticRenderFns: state.staticRenderFns\n    };\n  }\n\n  function genElement(el, state) {\n    if (el.parent) {\n      el.pre = el.pre || el.parent.pre;\n    }\n\n    if (el.staticRoot && !el.staticProcessed) {\n      return genStatic(el, state);\n    } else if (el.once && !el.onceProcessed) {\n      return genOnce(el, state);\n    } else if (el.for && !el.forProcessed) {\n      return genFor(el, state);\n    } else if (el.if && !el.ifProcessed) {\n      return genIf(el, state);\n    } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {\n      return genChildren(el, state) || 'void 0';\n    } else if (el.tag === 'slot') {\n      return genSlot(el, state);\n    } else {\n      // component or element\n      var code;\n\n      if (el.component) {\n        code = genComponent(el.component, el, state);\n      } else {\n        var data;\n\n        if (!el.plain || el.pre && state.maybeComponent(el)) {\n          data = genData$2(el, state);\n        }\n\n        var children = el.inlineTemplate ? null : genChildren(el, state, true);\n        code = \"_c('\" + el.tag + \"'\" + (data ? \",\" + data : '') + (children ? \",\" + children : '') + \")\";\n      } // module transforms\n\n\n      for (var i = 0; i < state.transforms.length; i++) {\n        code = state.transforms[i](el, code);\n      }\n\n      return code;\n    }\n  } // hoist static sub-trees out\n\n\n  function genStatic(el, state) {\n    el.staticProcessed = true; // Some elements (templates) need to behave differently inside of a v-pre\n    // node.  All pre nodes are static roots, so we can use this as a location to\n    // wrap a state change and reset it upon exiting the pre node.\n\n    var originalPreState = state.pre;\n\n    if (el.pre) {\n      state.pre = el.pre;\n    }\n\n    state.staticRenderFns.push(\"with(this){return \" + genElement(el, state) + \"}\");\n    state.pre = originalPreState;\n    return \"_m(\" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\";\n  } // v-once\n\n\n  function genOnce(el, state) {\n    el.onceProcessed = true;\n\n    if (el.if && !el.ifProcessed) {\n      return genIf(el, state);\n    } else if (el.staticInFor) {\n      var key = '';\n      var parent = el.parent;\n\n      while (parent) {\n        if (parent.for) {\n          key = parent.key;\n          break;\n        }\n\n        parent = parent.parent;\n      }\n\n      if (!key) {\n        state.warn(\"v-once can only be used inside v-for that is keyed. \", el.rawAttrsMap['v-once']);\n        return genElement(el, state);\n      }\n\n      return \"_o(\" + genElement(el, state) + \",\" + state.onceId++ + \",\" + key + \")\";\n    } else {\n      return genStatic(el, state);\n    }\n  }\n\n  function genIf(el, state, altGen, altEmpty) {\n    el.ifProcessed = true; // avoid recursion\n\n    return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);\n  }\n\n  function genIfConditions(conditions, state, altGen, altEmpty) {\n    if (!conditions.length) {\n      return altEmpty || '_e()';\n    }\n\n    var condition = conditions.shift();\n\n    if (condition.exp) {\n      return \"(\" + condition.exp + \")?\" + genTernaryExp(condition.block) + \":\" + genIfConditions(conditions, state, altGen, altEmpty);\n    } else {\n      return \"\" + genTernaryExp(condition.block);\n    } // v-if with v-once should generate code like (a)?_m(0):_m(1)\n\n\n    function genTernaryExp(el) {\n      return altGen ? altGen(el, state) : el.once ? genOnce(el, state) : genElement(el, state);\n    }\n  }\n\n  function genFor(el, state, altGen, altHelper) {\n    var exp = el.for;\n    var alias = el.alias;\n    var iterator1 = el.iterator1 ? \",\" + el.iterator1 : '';\n    var iterator2 = el.iterator2 ? \",\" + el.iterator2 : '';\n\n    if (state.maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key) {\n      state.warn(\"<\" + el.tag + \" v-for=\\\"\" + alias + \" in \" + exp + \"\\\">: component lists rendered with \" + \"v-for should have explicit keys. \" + \"See https://vuejs.org/guide/list.html#key for more info.\", el.rawAttrsMap['v-for'], true\n      /* tip */\n      );\n    }\n\n    el.forProcessed = true; // avoid recursion\n\n    return (altHelper || '_l') + \"((\" + exp + \"),\" + \"function(\" + alias + iterator1 + iterator2 + \"){\" + \"return \" + (altGen || genElement)(el, state) + '})';\n  }\n\n  function genData$2(el, state) {\n    var data = '{'; // directives first.\n    // directives may mutate the el's other properties before they are generated.\n\n    var dirs = genDirectives(el, state);\n\n    if (dirs) {\n      data += dirs + ',';\n    } // key\n\n\n    if (el.key) {\n      data += \"key:\" + el.key + \",\";\n    } // ref\n\n\n    if (el.ref) {\n      data += \"ref:\" + el.ref + \",\";\n    }\n\n    if (el.refInFor) {\n      data += \"refInFor:true,\";\n    } // pre\n\n\n    if (el.pre) {\n      data += \"pre:true,\";\n    } // record original tag name for components using \"is\" attribute\n\n\n    if (el.component) {\n      data += \"tag:\\\"\" + el.tag + \"\\\",\";\n    } // module data generation functions\n\n\n    for (var i = 0; i < state.dataGenFns.length; i++) {\n      data += state.dataGenFns[i](el);\n    } // attributes\n\n\n    if (el.attrs) {\n      data += \"attrs:\" + genProps(el.attrs) + \",\";\n    } // DOM props\n\n\n    if (el.props) {\n      data += \"domProps:\" + genProps(el.props) + \",\";\n    } // event handlers\n\n\n    if (el.events) {\n      data += genHandlers(el.events, false) + \",\";\n    }\n\n    if (el.nativeEvents) {\n      data += genHandlers(el.nativeEvents, true) + \",\";\n    } // slot target\n    // only for non-scoped slots\n\n\n    if (el.slotTarget && !el.slotScope) {\n      data += \"slot:\" + el.slotTarget + \",\";\n    } // scoped slots\n\n\n    if (el.scopedSlots) {\n      data += genScopedSlots(el, el.scopedSlots, state) + \",\";\n    } // component v-model\n\n\n    if (el.model) {\n      data += \"model:{value:\" + el.model.value + \",callback:\" + el.model.callback + \",expression:\" + el.model.expression + \"},\";\n    } // inline-template\n\n\n    if (el.inlineTemplate) {\n      var inlineTemplate = genInlineTemplate(el, state);\n\n      if (inlineTemplate) {\n        data += inlineTemplate + \",\";\n      }\n    }\n\n    data = data.replace(/,$/, '') + '}'; // v-bind dynamic argument wrap\n    // v-bind with dynamic arguments must be applied using the same v-bind object\n    // merge helper so that class/style/mustUseProp attrs are handled correctly.\n\n    if (el.dynamicAttrs) {\n      data = \"_b(\" + data + \",\\\"\" + el.tag + \"\\\",\" + genProps(el.dynamicAttrs) + \")\";\n    } // v-bind data wrap\n\n\n    if (el.wrapData) {\n      data = el.wrapData(data);\n    } // v-on data wrap\n\n\n    if (el.wrapListeners) {\n      data = el.wrapListeners(data);\n    }\n\n    return data;\n  }\n\n  function genDirectives(el, state) {\n    var dirs = el.directives;\n\n    if (!dirs) {\n      return;\n    }\n\n    var res = 'directives:[';\n    var hasRuntime = false;\n    var i, l, dir, needRuntime;\n\n    for (i = 0, l = dirs.length; i < l; i++) {\n      dir = dirs[i];\n      needRuntime = true;\n      var gen = state.directives[dir.name];\n\n      if (gen) {\n        // compile-time directive that manipulates AST.\n        // returns true if it also needs a runtime counterpart.\n        needRuntime = !!gen(el, dir, state.warn);\n      }\n\n      if (needRuntime) {\n        hasRuntime = true;\n        res += \"{name:\\\"\" + dir.name + \"\\\",rawName:\\\"\" + dir.rawName + \"\\\"\" + (dir.value ? \",value:(\" + dir.value + \"),expression:\" + JSON.stringify(dir.value) : '') + (dir.arg ? \",arg:\" + (dir.isDynamicArg ? dir.arg : \"\\\"\" + dir.arg + \"\\\"\") : '') + (dir.modifiers ? \",modifiers:\" + JSON.stringify(dir.modifiers) : '') + \"},\";\n      }\n    }\n\n    if (hasRuntime) {\n      return res.slice(0, -1) + ']';\n    }\n  }\n\n  function genInlineTemplate(el, state) {\n    var ast = el.children[0];\n\n    if (el.children.length !== 1 || ast.type !== 1) {\n      state.warn('Inline-template components must have exactly one child element.', {\n        start: el.start\n      });\n    }\n\n    if (ast && ast.type === 1) {\n      var inlineRenderFns = generate(ast, state.options);\n      return \"inlineTemplate:{render:function(){\" + inlineRenderFns.render + \"},staticRenderFns:[\" + inlineRenderFns.staticRenderFns.map(function (code) {\n        return \"function(){\" + code + \"}\";\n      }).join(',') + \"]}\";\n    }\n  }\n\n  function genScopedSlots(el, slots, state) {\n    // by default scoped slots are considered \"stable\", this allows child\n    // components with only scoped slots to skip forced updates from parent.\n    // but in some cases we have to bail-out of this optimization\n    // for example if the slot contains dynamic names, has v-if or v-for on them...\n    var needsForceUpdate = el.for || Object.keys(slots).some(function (key) {\n      var slot = slots[key];\n      return slot.slotTargetDynamic || slot.if || slot.for || containsSlotChild(slot) // is passing down slot from parent which may be dynamic\n      ;\n    }); // #9534: if a component with scoped slots is inside a conditional branch,\n    // it's possible for the same component to be reused but with different\n    // compiled slot content. To avoid that, we generate a unique key based on\n    // the generated code of all the slot contents.\n\n    var needsKey = !!el.if; // OR when it is inside another scoped slot or v-for (the reactivity may be\n    // disconnected due to the intermediate scope variable)\n    // #9438, #9506\n    // TODO: this can be further optimized by properly analyzing in-scope bindings\n    // and skip force updating ones that do not actually use scope variables.\n\n    if (!needsForceUpdate) {\n      var parent = el.parent;\n\n      while (parent) {\n        if (parent.slotScope && parent.slotScope !== emptySlotScopeToken || parent.for) {\n          needsForceUpdate = true;\n          break;\n        }\n\n        if (parent.if) {\n          needsKey = true;\n        }\n\n        parent = parent.parent;\n      }\n    }\n\n    var generatedSlots = Object.keys(slots).map(function (key) {\n      return genScopedSlot(slots[key], state);\n    }).join(',');\n    return \"scopedSlots:_u([\" + generatedSlots + \"]\" + (needsForceUpdate ? \",null,true\" : \"\") + (!needsForceUpdate && needsKey ? \",null,false,\" + hash(generatedSlots) : \"\") + \")\";\n  }\n\n  function hash(str) {\n    var hash = 5381;\n    var i = str.length;\n\n    while (i) {\n      hash = hash * 33 ^ str.charCodeAt(--i);\n    }\n\n    return hash >>> 0;\n  }\n\n  function containsSlotChild(el) {\n    if (el.type === 1) {\n      if (el.tag === 'slot') {\n        return true;\n      }\n\n      return el.children.some(containsSlotChild);\n    }\n\n    return false;\n  }\n\n  function genScopedSlot(el, state) {\n    var isLegacySyntax = el.attrsMap['slot-scope'];\n\n    if (el.if && !el.ifProcessed && !isLegacySyntax) {\n      return genIf(el, state, genScopedSlot, \"null\");\n    }\n\n    if (el.for && !el.forProcessed) {\n      return genFor(el, state, genScopedSlot);\n    }\n\n    var slotScope = el.slotScope === emptySlotScopeToken ? \"\" : String(el.slotScope);\n    var fn = \"function(\" + slotScope + \"){\" + \"return \" + (el.tag === 'template' ? el.if && isLegacySyntax ? \"(\" + el.if + \")?\" + (genChildren(el, state) || 'undefined') + \":undefined\" : genChildren(el, state) || 'undefined' : genElement(el, state)) + \"}\"; // reverse proxy v-slot without scope on this.$slots\n\n    var reverseProxy = slotScope ? \"\" : \",proxy:true\";\n    return \"{key:\" + (el.slotTarget || \"\\\"default\\\"\") + \",fn:\" + fn + reverseProxy + \"}\";\n  }\n\n  function genChildren(el, state, checkSkip, altGenElement, altGenNode) {\n    var children = el.children;\n\n    if (children.length) {\n      var el$1 = children[0]; // optimize single v-for\n\n      if (children.length === 1 && el$1.for && el$1.tag !== 'template' && el$1.tag !== 'slot') {\n        var normalizationType = checkSkip ? state.maybeComponent(el$1) ? \",1\" : \",0\" : \"\";\n        return \"\" + (altGenElement || genElement)(el$1, state) + normalizationType;\n      }\n\n      var normalizationType$1 = checkSkip ? getNormalizationType(children, state.maybeComponent) : 0;\n      var gen = altGenNode || genNode;\n      return \"[\" + children.map(function (c) {\n        return gen(c, state);\n      }).join(',') + \"]\" + (normalizationType$1 ? \",\" + normalizationType$1 : '');\n    }\n  } // determine the normalization needed for the children array.\n  // 0: no normalization needed\n  // 1: simple normalization needed (possible 1-level deep nested array)\n  // 2: full normalization needed\n\n\n  function getNormalizationType(children, maybeComponent) {\n    var res = 0;\n\n    for (var i = 0; i < children.length; i++) {\n      var el = children[i];\n\n      if (el.type !== 1) {\n        continue;\n      }\n\n      if (needsNormalization(el) || el.ifConditions && el.ifConditions.some(function (c) {\n        return needsNormalization(c.block);\n      })) {\n        res = 2;\n        break;\n      }\n\n      if (maybeComponent(el) || el.ifConditions && el.ifConditions.some(function (c) {\n        return maybeComponent(c.block);\n      })) {\n        res = 1;\n      }\n    }\n\n    return res;\n  }\n\n  function needsNormalization(el) {\n    return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';\n  }\n\n  function genNode(node, state) {\n    if (node.type === 1) {\n      return genElement(node, state);\n    } else if (node.type === 3 && node.isComment) {\n      return genComment(node);\n    } else {\n      return genText(node);\n    }\n  }\n\n  function genText(text) {\n    return \"_v(\" + (text.type === 2 ? text.expression // no need for () because already wrapped in _s()\n    : transformSpecialNewlines(JSON.stringify(text.text))) + \")\";\n  }\n\n  function genComment(comment) {\n    return \"_e(\" + JSON.stringify(comment.text) + \")\";\n  }\n\n  function genSlot(el, state) {\n    var slotName = el.slotName || '\"default\"';\n    var children = genChildren(el, state);\n    var res = \"_t(\" + slotName + (children ? \",\" + children : '');\n    var attrs = el.attrs || el.dynamicAttrs ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function (attr) {\n      return {\n        // slot props are camelized\n        name: camelize(attr.name),\n        value: attr.value,\n        dynamic: attr.dynamic\n      };\n    })) : null;\n    var bind$$1 = el.attrsMap['v-bind'];\n\n    if ((attrs || bind$$1) && !children) {\n      res += \",null\";\n    }\n\n    if (attrs) {\n      res += \",\" + attrs;\n    }\n\n    if (bind$$1) {\n      res += (attrs ? '' : ',null') + \",\" + bind$$1;\n    }\n\n    return res + ')';\n  } // componentName is el.component, take it as argument to shun flow's pessimistic refinement\n\n\n  function genComponent(componentName, el, state) {\n    var children = el.inlineTemplate ? null : genChildren(el, state, true);\n    return \"_c(\" + componentName + \",\" + genData$2(el, state) + (children ? \",\" + children : '') + \")\";\n  }\n\n  function genProps(props) {\n    var staticProps = \"\";\n    var dynamicProps = \"\";\n\n    for (var i = 0; i < props.length; i++) {\n      var prop = props[i];\n      var value = transformSpecialNewlines(prop.value);\n\n      if (prop.dynamic) {\n        dynamicProps += prop.name + \",\" + value + \",\";\n      } else {\n        staticProps += \"\\\"\" + prop.name + \"\\\":\" + value + \",\";\n      }\n    }\n\n    staticProps = \"{\" + staticProps.slice(0, -1) + \"}\";\n\n    if (dynamicProps) {\n      return \"_d(\" + staticProps + \",[\" + dynamicProps.slice(0, -1) + \"])\";\n    } else {\n      return staticProps;\n    }\n  } // #3895, #4268\n\n\n  function transformSpecialNewlines(text) {\n    return text.replace(/\\u2028/g, \"\\\\u2028\").replace(/\\u2029/g, \"\\\\u2029\");\n  }\n  /*  */\n  // these keywords should not appear inside expressions, but operators like\n  // typeof, instanceof and in are allowed\n\n\n  var prohibitedKeywordRE = new RegExp('\\\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments').split(',').join('\\\\b|\\\\b') + '\\\\b'); // these unary operators should not be used as property/method names\n\n  var unaryOperatorsRE = new RegExp('\\\\b' + 'delete,typeof,void'.split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)'); // strip strings in expressions\n\n  var stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g; // detect problematic expressions in a template\n\n  function detectErrors(ast, warn) {\n    if (ast) {\n      checkNode(ast, warn);\n    }\n  }\n\n  function checkNode(node, warn) {\n    if (node.type === 1) {\n      for (var name in node.attrsMap) {\n        if (dirRE.test(name)) {\n          var value = node.attrsMap[name];\n\n          if (value) {\n            var range = node.rawAttrsMap[name];\n\n            if (name === 'v-for') {\n              checkFor(node, \"v-for=\\\"\" + value + \"\\\"\", warn, range);\n            } else if (onRE.test(name)) {\n              checkEvent(value, name + \"=\\\"\" + value + \"\\\"\", warn, range);\n            } else {\n              checkExpression(value, name + \"=\\\"\" + value + \"\\\"\", warn, range);\n            }\n          }\n        }\n      }\n\n      if (node.children) {\n        for (var i = 0; i < node.children.length; i++) {\n          checkNode(node.children[i], warn);\n        }\n      }\n    } else if (node.type === 2) {\n      checkExpression(node.expression, node.text, warn, node);\n    }\n  }\n\n  function checkEvent(exp, text, warn, range) {\n    var stipped = exp.replace(stripStringRE, '');\n    var keywordMatch = stipped.match(unaryOperatorsRE);\n\n    if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {\n      warn(\"avoid using JavaScript unary operator as property name: \" + \"\\\"\" + keywordMatch[0] + \"\\\" in expression \" + text.trim(), range);\n    }\n\n    checkExpression(exp, text, warn, range);\n  }\n\n  function checkFor(node, text, warn, range) {\n    checkExpression(node.for || '', text, warn, range);\n    checkIdentifier(node.alias, 'v-for alias', text, warn, range);\n    checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);\n    checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);\n  }\n\n  function checkIdentifier(ident, type, text, warn, range) {\n    if (typeof ident === 'string') {\n      try {\n        new Function(\"var \" + ident + \"=_\");\n      } catch (e) {\n        warn(\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + text.trim(), range);\n      }\n    }\n  }\n\n  function checkExpression(exp, text, warn, range) {\n    try {\n      new Function(\"return \" + exp);\n    } catch (e) {\n      var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n\n      if (keywordMatch) {\n        warn(\"avoid using JavaScript keyword as property name: \" + \"\\\"\" + keywordMatch[0] + \"\\\"\\n  Raw expression: \" + text.trim(), range);\n      } else {\n        warn(\"invalid expression: \" + e.message + \" in\\n\\n\" + \"    \" + exp + \"\\n\\n\" + \"  Raw expression: \" + text.trim() + \"\\n\", range);\n      }\n    }\n  }\n  /*  */\n\n\n  var range = 2;\n\n  function generateCodeFrame(source, start, end) {\n    if (start === void 0) start = 0;\n    if (end === void 0) end = source.length;\n    var lines = source.split(/\\r?\\n/);\n    var count = 0;\n    var res = [];\n\n    for (var i = 0; i < lines.length; i++) {\n      count += lines[i].length + 1;\n\n      if (count >= start) {\n        for (var j = i - range; j <= i + range || end > count; j++) {\n          if (j < 0 || j >= lines.length) {\n            continue;\n          }\n\n          res.push(\"\" + (j + 1) + repeat$1(\" \", 3 - String(j + 1).length) + \"|  \" + lines[j]);\n          var lineLength = lines[j].length;\n\n          if (j === i) {\n            // push underline\n            var pad = start - (count - lineLength) + 1;\n            var length = end > count ? lineLength - pad : end - start;\n            res.push(\"   |  \" + repeat$1(\" \", pad) + repeat$1(\"^\", length));\n          } else if (j > i) {\n            if (end > count) {\n              var length$1 = Math.min(end - count, lineLength);\n              res.push(\"   |  \" + repeat$1(\"^\", length$1));\n            }\n\n            count += lineLength + 1;\n          }\n        }\n\n        break;\n      }\n    }\n\n    return res.join('\\n');\n  }\n\n  function repeat$1(str, n) {\n    var result = '';\n\n    if (n > 0) {\n      while (true) {\n        // eslint-disable-line\n        if (n & 1) {\n          result += str;\n        }\n\n        n >>>= 1;\n\n        if (n <= 0) {\n          break;\n        }\n\n        str += str;\n      }\n    }\n\n    return result;\n  }\n  /*  */\n\n\n  function createFunction(code, errors) {\n    try {\n      return new Function(code);\n    } catch (err) {\n      errors.push({\n        err: err,\n        code: code\n      });\n      return noop;\n    }\n  }\n\n  function createCompileToFunctionFn(compile) {\n    var cache = Object.create(null);\n    return function compileToFunctions(template, options, vm) {\n      options = extend({}, options);\n      var warn$$1 = options.warn || warn;\n      delete options.warn;\n      /* istanbul ignore if */\n\n      {\n        // detect possible CSP restriction\n        try {\n          new Function('return 1');\n        } catch (e) {\n          if (e.toString().match(/unsafe-eval|CSP/)) {\n            warn$$1('It seems you are using the standalone build of Vue.js in an ' + 'environment with Content Security Policy that prohibits unsafe-eval. ' + 'The template compiler cannot work in this environment. Consider ' + 'relaxing the policy to allow unsafe-eval or pre-compiling your ' + 'templates into render functions.');\n          }\n        }\n      } // check cache\n\n      var key = options.delimiters ? String(options.delimiters) + template : template;\n\n      if (cache[key]) {\n        return cache[key];\n      } // compile\n\n\n      var compiled = compile(template, options); // check compilation errors/tips\n\n      {\n        if (compiled.errors && compiled.errors.length) {\n          if (options.outputSourceRange) {\n            compiled.errors.forEach(function (e) {\n              warn$$1(\"Error compiling template:\\n\\n\" + e.msg + \"\\n\\n\" + generateCodeFrame(template, e.start, e.end), vm);\n            });\n          } else {\n            warn$$1(\"Error compiling template:\\n\\n\" + template + \"\\n\\n\" + compiled.errors.map(function (e) {\n              return \"- \" + e;\n            }).join('\\n') + '\\n', vm);\n          }\n        }\n\n        if (compiled.tips && compiled.tips.length) {\n          if (options.outputSourceRange) {\n            compiled.tips.forEach(function (e) {\n              return tip(e.msg, vm);\n            });\n          } else {\n            compiled.tips.forEach(function (msg) {\n              return tip(msg, vm);\n            });\n          }\n        }\n      } // turn code into functions\n\n      var res = {};\n      var fnGenErrors = [];\n      res.render = createFunction(compiled.render, fnGenErrors);\n      res.staticRenderFns = compiled.staticRenderFns.map(function (code) {\n        return createFunction(code, fnGenErrors);\n      }); // check function generation errors.\n      // this should only happen if there is a bug in the compiler itself.\n      // mostly for codegen development use\n\n      /* istanbul ignore if */\n\n      {\n        if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n          warn$$1(\"Failed to generate render function:\\n\\n\" + fnGenErrors.map(function (ref) {\n            var err = ref.err;\n            var code = ref.code;\n            return err.toString() + \" in\\n\\n\" + code + \"\\n\";\n          }).join('\\n'), vm);\n        }\n      }\n      return cache[key] = res;\n    };\n  }\n  /*  */\n\n\n  function createCompilerCreator(baseCompile) {\n    return function createCompiler(baseOptions) {\n      function compile(template, options) {\n        var finalOptions = Object.create(baseOptions);\n        var errors = [];\n        var tips = [];\n\n        var warn = function warn(msg, range, tip) {\n          (tip ? tips : errors).push(msg);\n        };\n\n        if (options) {\n          if (options.outputSourceRange) {\n            // $flow-disable-line\n            var leadingSpaceLength = template.match(/^\\s*/)[0].length;\n\n            warn = function warn(msg, range, tip) {\n              var data = {\n                msg: msg\n              };\n\n              if (range) {\n                if (range.start != null) {\n                  data.start = range.start + leadingSpaceLength;\n                }\n\n                if (range.end != null) {\n                  data.end = range.end + leadingSpaceLength;\n                }\n              }\n\n              (tip ? tips : errors).push(data);\n            };\n          } // merge custom modules\n\n\n          if (options.modules) {\n            finalOptions.modules = (baseOptions.modules || []).concat(options.modules);\n          } // merge custom directives\n\n\n          if (options.directives) {\n            finalOptions.directives = extend(Object.create(baseOptions.directives || null), options.directives);\n          } // copy other options\n\n\n          for (var key in options) {\n            if (key !== 'modules' && key !== 'directives') {\n              finalOptions[key] = options[key];\n            }\n          }\n        }\n\n        finalOptions.warn = warn;\n        var compiled = baseCompile(template.trim(), finalOptions);\n        {\n          detectErrors(compiled.ast, warn);\n        }\n        compiled.errors = errors;\n        compiled.tips = tips;\n        return compiled;\n      }\n\n      return {\n        compile: compile,\n        compileToFunctions: createCompileToFunctionFn(compile)\n      };\n    };\n  }\n  /*  */\n  // `createCompilerCreator` allows creating compilers that use alternative\n  // parser/optimizer/codegen, e.g the SSR optimizing compiler.\n  // Here we just export a default compiler using the default parts.\n\n\n  var createCompiler = createCompilerCreator(function baseCompile(template, options) {\n    var ast = parse(template.trim(), options);\n\n    if (options.optimize !== false) {\n      optimize(ast, options);\n    }\n\n    var code = generate(ast, options);\n    return {\n      ast: ast,\n      render: code.render,\n      staticRenderFns: code.staticRenderFns\n    };\n  });\n  /*  */\n\n  var ref$1 = createCompiler(baseOptions);\n  var compile = ref$1.compile;\n  var compileToFunctions = ref$1.compileToFunctions;\n  /*  */\n  // check whether current browser encodes a char inside attribute values\n\n  var div;\n\n  function getShouldDecode(href) {\n    div = div || document.createElement('div');\n    div.innerHTML = href ? \"<a href=\\\"\\n\\\"/>\" : \"<div a=\\\"\\n\\\"/>\";\n    return div.innerHTML.indexOf('&#10;') > 0;\n  } // #3663: IE encodes newlines inside attribute values while other browsers don't\n\n\n  var shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false; // #6828: chrome encodes content in a[href]\n\n  var shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;\n  /*  */\n\n  var idToTemplate = cached(function (id) {\n    var el = query(id);\n    return el && el.innerHTML;\n  });\n  var mount = Vue.prototype.$mount;\n\n  Vue.prototype.$mount = function (el, hydrating) {\n    el = el && query(el);\n    /* istanbul ignore if */\n\n    if (el === document.body || el === document.documentElement) {\n      warn(\"Do not mount Vue to <html> or <body> - mount to normal elements instead.\");\n      return this;\n    }\n\n    var options = this.$options; // resolve template/el and convert to render function\n\n    if (!options.render) {\n      var template = options.template;\n\n      if (template) {\n        if (typeof template === 'string') {\n          if (template.charAt(0) === '#') {\n            template = idToTemplate(template);\n            /* istanbul ignore if */\n\n            if (!template) {\n              warn(\"Template element not found or is empty: \" + options.template, this);\n            }\n          }\n        } else if (template.nodeType) {\n          template = template.innerHTML;\n        } else {\n          {\n            warn('invalid template option:' + template, this);\n          }\n          return this;\n        }\n      } else if (el) {\n        template = getOuterHTML(el);\n      }\n\n      if (template) {\n        /* istanbul ignore if */\n        if (config.performance && mark) {\n          mark('compile');\n        }\n\n        var ref = compileToFunctions(template, {\n          outputSourceRange: \"development\" !== 'production',\n          shouldDecodeNewlines: shouldDecodeNewlines,\n          shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,\n          delimiters: options.delimiters,\n          comments: options.comments\n        }, this);\n        var render = ref.render;\n        var staticRenderFns = ref.staticRenderFns;\n        options.render = render;\n        options.staticRenderFns = staticRenderFns;\n        /* istanbul ignore if */\n\n        if (config.performance && mark) {\n          mark('compile end');\n          measure(\"vue \" + this._name + \" compile\", 'compile', 'compile end');\n        }\n      }\n    }\n\n    return mount.call(this, el, hydrating);\n  };\n  /**\n   * Get outerHTML of elements, taking care\n   * of SVG elements in IE as well.\n   */\n\n\n  function getOuterHTML(el) {\n    if (el.outerHTML) {\n      return el.outerHTML;\n    } else {\n      var container = document.createElement('div');\n      container.appendChild(el.cloneNode(true));\n      return container.innerHTML;\n    }\n  }\n\n  Vue.compile = compileToFunctions;\n  return Vue;\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../timers-browserify/main.js */ \"./node_modules/timers-browserify/main.js\").setImmediate))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLmpzP2JhNGMiXSwibmFtZXMiOlsiZ2xvYmFsIiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJkZWZpbmUiLCJlbXB0eU9iamVjdCIsIk9iamVjdCIsImZyZWV6ZSIsImlzVW5kZWYiLCJ2IiwidW5kZWZpbmVkIiwiaXNEZWYiLCJpc1RydWUiLCJpc0ZhbHNlIiwiaXNQcmltaXRpdmUiLCJ2YWx1ZSIsImlzT2JqZWN0Iiwib2JqIiwiX3RvU3RyaW5nIiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJ0b1Jhd1R5cGUiLCJjYWxsIiwic2xpY2UiLCJpc1BsYWluT2JqZWN0IiwiaXNSZWdFeHAiLCJpc1ZhbGlkQXJyYXlJbmRleCIsInZhbCIsIm4iLCJwYXJzZUZsb2F0IiwiU3RyaW5nIiwiTWF0aCIsImZsb29yIiwiaXNGaW5pdGUiLCJpc1Byb21pc2UiLCJ0aGVuIiwiY2F0Y2giLCJBcnJheSIsImlzQXJyYXkiLCJKU09OIiwic3RyaW5naWZ5IiwidG9OdW1iZXIiLCJpc05hTiIsIm1ha2VNYXAiLCJzdHIiLCJleHBlY3RzTG93ZXJDYXNlIiwibWFwIiwiY3JlYXRlIiwibGlzdCIsInNwbGl0IiwiaSIsImxlbmd0aCIsInRvTG93ZXJDYXNlIiwiaXNCdWlsdEluVGFnIiwiaXNSZXNlcnZlZEF0dHJpYnV0ZSIsInJlbW92ZSIsImFyciIsIml0ZW0iLCJpbmRleCIsImluZGV4T2YiLCJzcGxpY2UiLCJoYXNPd25Qcm9wZXJ0eSIsImhhc093biIsImtleSIsImNhY2hlZCIsImZuIiwiY2FjaGUiLCJjYWNoZWRGbiIsImhpdCIsImNhbWVsaXplUkUiLCJjYW1lbGl6ZSIsInJlcGxhY2UiLCJfIiwiYyIsInRvVXBwZXJDYXNlIiwiY2FwaXRhbGl6ZSIsImNoYXJBdCIsImh5cGhlbmF0ZVJFIiwiaHlwaGVuYXRlIiwicG9seWZpbGxCaW5kIiwiY3R4IiwiYm91bmRGbiIsImEiLCJsIiwiYXJndW1lbnRzIiwiYXBwbHkiLCJfbGVuZ3RoIiwibmF0aXZlQmluZCIsImJpbmQiLCJGdW5jdGlvbiIsInRvQXJyYXkiLCJzdGFydCIsInJldCIsImV4dGVuZCIsInRvIiwiX2Zyb20iLCJ0b09iamVjdCIsInJlcyIsIm5vb3AiLCJiIiwibm8iLCJpZGVudGl0eSIsImdlblN0YXRpY0tleXMiLCJtb2R1bGVzIiwicmVkdWNlIiwia2V5cyIsIm0iLCJjb25jYXQiLCJzdGF0aWNLZXlzIiwiam9pbiIsImxvb3NlRXF1YWwiLCJpc09iamVjdEEiLCJpc09iamVjdEIiLCJpc0FycmF5QSIsImlzQXJyYXlCIiwiZXZlcnkiLCJlIiwiRGF0ZSIsImdldFRpbWUiLCJrZXlzQSIsImtleXNCIiwibG9vc2VJbmRleE9mIiwib25jZSIsImNhbGxlZCIsIlNTUl9BVFRSIiwiQVNTRVRfVFlQRVMiLCJMSUZFQ1lDTEVfSE9PS1MiLCJjb25maWciLCJvcHRpb25NZXJnZVN0cmF0ZWdpZXMiLCJzaWxlbnQiLCJwcm9kdWN0aW9uVGlwIiwiZGV2dG9vbHMiLCJwZXJmb3JtYW5jZSIsImVycm9ySGFuZGxlciIsIndhcm5IYW5kbGVyIiwiaWdub3JlZEVsZW1lbnRzIiwia2V5Q29kZXMiLCJpc1Jlc2VydmVkVGFnIiwiaXNSZXNlcnZlZEF0dHIiLCJpc1Vua25vd25FbGVtZW50IiwiZ2V0VGFnTmFtZXNwYWNlIiwicGFyc2VQbGF0Zm9ybVRhZ05hbWUiLCJtdXN0VXNlUHJvcCIsImFzeW5jIiwiX2xpZmVjeWNsZUhvb2tzIiwidW5pY29kZVJlZ0V4cCIsImlzUmVzZXJ2ZWQiLCJjaGFyQ29kZUF0IiwiZGVmIiwiZW51bWVyYWJsZSIsImRlZmluZVByb3BlcnR5Iiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJiYWlsUkUiLCJSZWdFeHAiLCJzb3VyY2UiLCJwYXJzZVBhdGgiLCJwYXRoIiwidGVzdCIsInNlZ21lbnRzIiwiaGFzUHJvdG8iLCJpbkJyb3dzZXIiLCJ3aW5kb3ciLCJpbldlZXgiLCJXWEVudmlyb25tZW50IiwicGxhdGZvcm0iLCJ3ZWV4UGxhdGZvcm0iLCJVQSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImlzSUUiLCJpc0lFOSIsImlzRWRnZSIsImlzQW5kcm9pZCIsImlzSU9TIiwiaXNDaHJvbWUiLCJpc1BoYW50b21KUyIsImlzRkYiLCJtYXRjaCIsIm5hdGl2ZVdhdGNoIiwid2F0Y2giLCJzdXBwb3J0c1Bhc3NpdmUiLCJvcHRzIiwiZ2V0IiwiYWRkRXZlbnRMaXN0ZW5lciIsIl9pc1NlcnZlciIsImlzU2VydmVyUmVuZGVyaW5nIiwiZW52IiwiVlVFX0VOViIsIl9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX18iLCJpc05hdGl2ZSIsIkN0b3IiLCJoYXNTeW1ib2wiLCJTeW1ib2wiLCJSZWZsZWN0Iiwib3duS2V5cyIsIl9TZXQiLCJTZXQiLCJzZXQiLCJoYXMiLCJhZGQiLCJjbGVhciIsIndhcm4iLCJ0aXAiLCJnZW5lcmF0ZUNvbXBvbmVudFRyYWNlIiwiZm9ybWF0Q29tcG9uZW50TmFtZSIsImhhc0NvbnNvbGUiLCJjb25zb2xlIiwiY2xhc3NpZnlSRSIsImNsYXNzaWZ5IiwibXNnIiwidm0iLCJ0cmFjZSIsImVycm9yIiwiaW5jbHVkZUZpbGUiLCIkcm9vdCIsIm9wdGlvbnMiLCJjaWQiLCJfaXNWdWUiLCIkb3B0aW9ucyIsImNvbnN0cnVjdG9yIiwibmFtZSIsIl9jb21wb25lbnRUYWciLCJmaWxlIiwiX19maWxlIiwicmVwZWF0IiwiJHBhcmVudCIsInRyZWUiLCJjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UiLCJsYXN0IiwicHVzaCIsInVpZCIsIkRlcCIsImlkIiwic3VicyIsImFkZFN1YiIsInN1YiIsInJlbW92ZVN1YiIsImRlcGVuZCIsInRhcmdldCIsImFkZERlcCIsIm5vdGlmeSIsInNvcnQiLCJ1cGRhdGUiLCJ0YXJnZXRTdGFjayIsInB1c2hUYXJnZXQiLCJwb3BUYXJnZXQiLCJwb3AiLCJWTm9kZSIsInRhZyIsImRhdGEiLCJjaGlsZHJlbiIsInRleHQiLCJlbG0iLCJjb250ZXh0IiwiY29tcG9uZW50T3B0aW9ucyIsImFzeW5jRmFjdG9yeSIsIm5zIiwiZm5Db250ZXh0IiwiZm5PcHRpb25zIiwiZm5TY29wZUlkIiwiY29tcG9uZW50SW5zdGFuY2UiLCJwYXJlbnQiLCJyYXciLCJpc1N0YXRpYyIsImlzUm9vdEluc2VydCIsImlzQ29tbWVudCIsImlzQ2xvbmVkIiwiaXNPbmNlIiwiYXN5bmNNZXRhIiwiaXNBc3luY1BsYWNlaG9sZGVyIiwicHJvdG90eXBlQWNjZXNzb3JzIiwiY2hpbGQiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiY3JlYXRlRW1wdHlWTm9kZSIsIm5vZGUiLCJjcmVhdGVUZXh0Vk5vZGUiLCJjbG9uZVZOb2RlIiwidm5vZGUiLCJjbG9uZWQiLCJhcnJheVByb3RvIiwiYXJyYXlNZXRob2RzIiwibWV0aG9kc1RvUGF0Y2giLCJmb3JFYWNoIiwibWV0aG9kIiwib3JpZ2luYWwiLCJtdXRhdG9yIiwiYXJncyIsImxlbiIsInJlc3VsdCIsIm9iIiwiX19vYl9fIiwiaW5zZXJ0ZWQiLCJvYnNlcnZlQXJyYXkiLCJkZXAiLCJhcnJheUtleXMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwic2hvdWxkT2JzZXJ2ZSIsInRvZ2dsZU9ic2VydmluZyIsIk9ic2VydmVyIiwidm1Db3VudCIsInByb3RvQXVnbWVudCIsImNvcHlBdWdtZW50Iiwid2FsayIsImRlZmluZVJlYWN0aXZlJCQxIiwiaXRlbXMiLCJvYnNlcnZlIiwic3JjIiwiX19wcm90b19fIiwiYXNSb290RGF0YSIsImlzRXh0ZW5zaWJsZSIsImN1c3RvbVNldHRlciIsInNoYWxsb3ciLCJwcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdldHRlciIsInNldHRlciIsImNoaWxkT2IiLCJyZWFjdGl2ZUdldHRlciIsImRlcGVuZEFycmF5IiwicmVhY3RpdmVTZXR0ZXIiLCJuZXdWYWwiLCJtYXgiLCJkZWwiLCJzdHJhdHMiLCJlbCIsInByb3BzRGF0YSIsImRlZmF1bHRTdHJhdCIsIm1lcmdlRGF0YSIsImZyb20iLCJ0b1ZhbCIsImZyb21WYWwiLCJtZXJnZURhdGFPckZuIiwicGFyZW50VmFsIiwiY2hpbGRWYWwiLCJtZXJnZWREYXRhRm4iLCJtZXJnZWRJbnN0YW5jZURhdGFGbiIsImluc3RhbmNlRGF0YSIsImRlZmF1bHREYXRhIiwibWVyZ2VIb29rIiwiZGVkdXBlSG9va3MiLCJob29rcyIsImhvb2siLCJtZXJnZUFzc2V0cyIsImFzc2VydE9iamVjdFR5cGUiLCJ0eXBlIiwia2V5JDEiLCJwcm9wcyIsIm1ldGhvZHMiLCJpbmplY3QiLCJjb21wdXRlZCIsInByb3ZpZGUiLCJjaGVja0NvbXBvbmVudHMiLCJjb21wb25lbnRzIiwidmFsaWRhdGVDb21wb25lbnROYW1lIiwibm9ybWFsaXplUHJvcHMiLCJub3JtYWxpemVJbmplY3QiLCJub3JtYWxpemVkIiwibm9ybWFsaXplRGlyZWN0aXZlcyIsImRpcnMiLCJkaXJlY3RpdmVzIiwiZGVmJCQxIiwibWVyZ2VPcHRpb25zIiwiX2Jhc2UiLCJleHRlbmRzIiwibWl4aW5zIiwibWVyZ2VGaWVsZCIsInN0cmF0IiwicmVzb2x2ZUFzc2V0Iiwid2Fybk1pc3NpbmciLCJhc3NldHMiLCJjYW1lbGl6ZWRJZCIsIlBhc2NhbENhc2VJZCIsInZhbGlkYXRlUHJvcCIsInByb3BPcHRpb25zIiwicHJvcCIsImFic2VudCIsImJvb2xlYW5JbmRleCIsImdldFR5cGVJbmRleCIsIkJvb2xlYW4iLCJzdHJpbmdJbmRleCIsImdldFByb3BEZWZhdWx0VmFsdWUiLCJwcmV2U2hvdWxkT2JzZXJ2ZSIsImFzc2VydFByb3AiLCJkZWZhdWx0IiwiX3Byb3BzIiwiZ2V0VHlwZSIsInJlcXVpcmVkIiwidmFsaWQiLCJleHBlY3RlZFR5cGVzIiwiYXNzZXJ0ZWRUeXBlIiwiYXNzZXJ0VHlwZSIsImV4cGVjdGVkVHlwZSIsImdldEludmFsaWRUeXBlTWVzc2FnZSIsInZhbGlkYXRvciIsInNpbXBsZUNoZWNrUkUiLCJ0IiwiaXNTYW1lVHlwZSIsIm1lc3NhZ2UiLCJyZWNlaXZlZFR5cGUiLCJleHBlY3RlZFZhbHVlIiwic3R5bGVWYWx1ZSIsInJlY2VpdmVkVmFsdWUiLCJpc0V4cGxpY2FibGUiLCJpc0Jvb2xlYW4iLCJOdW1iZXIiLCJleHBsaWNpdFR5cGVzIiwic29tZSIsImVsZW0iLCJoYW5kbGVFcnJvciIsImVyciIsImluZm8iLCJjdXIiLCJlcnJvckNhcHR1cmVkIiwiY2FwdHVyZSIsImdsb2JhbEhhbmRsZUVycm9yIiwiaW52b2tlV2l0aEVycm9ySGFuZGxpbmciLCJoYW5kbGVyIiwiX2hhbmRsZWQiLCJsb2dFcnJvciIsImlzVXNpbmdNaWNyb1Rhc2siLCJjYWxsYmFja3MiLCJwZW5kaW5nIiwiZmx1c2hDYWxsYmFja3MiLCJjb3BpZXMiLCJ0aW1lckZ1bmMiLCJQcm9taXNlIiwicCIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiTXV0YXRpb25PYnNlcnZlciIsImNvdW50ZXIiLCJvYnNlcnZlciIsInRleHROb2RlIiwiZG9jdW1lbnQiLCJjcmVhdGVUZXh0Tm9kZSIsImNoYXJhY3RlckRhdGEiLCJzZXRJbW1lZGlhdGUiLCJuZXh0VGljayIsImNiIiwiX3Jlc29sdmUiLCJtYXJrIiwibWVhc3VyZSIsInBlcmYiLCJjbGVhck1hcmtzIiwiY2xlYXJNZWFzdXJlcyIsInN0YXJ0VGFnIiwiZW5kVGFnIiwiaW5pdFByb3h5IiwiYWxsb3dlZEdsb2JhbHMiLCJ3YXJuTm9uUHJlc2VudCIsIndhcm5SZXNlcnZlZFByZWZpeCIsImhhc1Byb3h5IiwiUHJveHkiLCJpc0J1aWx0SW5Nb2RpZmllciIsImhhc0hhbmRsZXIiLCJpc0FsbG93ZWQiLCIkZGF0YSIsImdldEhhbmRsZXIiLCJoYW5kbGVycyIsInJlbmRlciIsIl93aXRoU3RyaXBwZWQiLCJfcmVuZGVyUHJveHkiLCJzZWVuT2JqZWN0cyIsInRyYXZlcnNlIiwiX3RyYXZlcnNlIiwic2VlbiIsImlzQSIsImlzRnJvemVuIiwiZGVwSWQiLCJub3JtYWxpemVFdmVudCIsInBhc3NpdmUiLCJvbmNlJCQxIiwiY3JlYXRlRm5JbnZva2VyIiwiZm5zIiwiaW52b2tlciIsImFyZ3VtZW50cyQxIiwidXBkYXRlTGlzdGVuZXJzIiwib24iLCJvbGRPbiIsInJlbW92ZSQkMSIsImNyZWF0ZU9uY2VIYW5kbGVyIiwib2xkIiwiZXZlbnQiLCJwYXJhbXMiLCJtZXJnZVZOb2RlSG9vayIsImhvb2tLZXkiLCJvbGRIb29rIiwid3JhcHBlZEhvb2siLCJtZXJnZWQiLCJleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhIiwiYXR0cnMiLCJhbHRLZXkiLCJrZXlJbkxvd2VyQ2FzZSIsImNoZWNrUHJvcCIsImhhc2giLCJwcmVzZXJ2ZSIsInNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIiwibm9ybWFsaXplQ2hpbGRyZW4iLCJub3JtYWxpemVBcnJheUNoaWxkcmVuIiwiaXNUZXh0Tm9kZSIsIm5lc3RlZEluZGV4IiwibGFzdEluZGV4Iiwic2hpZnQiLCJfaXNWTGlzdCIsImluaXRQcm92aWRlIiwiX3Byb3ZpZGVkIiwiaW5pdEluamVjdGlvbnMiLCJyZXNvbHZlSW5qZWN0IiwicHJvdmlkZUtleSIsInByb3ZpZGVEZWZhdWx0IiwicmVzb2x2ZVNsb3RzIiwic2xvdHMiLCJzbG90IiwibmFtZSQxIiwiaXNXaGl0ZXNwYWNlIiwibm9ybWFsaXplU2NvcGVkU2xvdHMiLCJub3JtYWxTbG90cyIsInByZXZTbG90cyIsImhhc05vcm1hbFNsb3RzIiwiaXNTdGFibGUiLCIkc3RhYmxlIiwiJGtleSIsIl9ub3JtYWxpemVkIiwiJGhhc05vcm1hbCIsIm5vcm1hbGl6ZVNjb3BlZFNsb3QiLCJrZXkkMiIsInByb3h5Tm9ybWFsU2xvdCIsInByb3h5IiwicmVuZGVyTGlzdCIsIml0ZXJhdG9yIiwibmV4dCIsImRvbmUiLCJyZW5kZXJTbG90IiwiZmFsbGJhY2siLCJiaW5kT2JqZWN0Iiwic2NvcGVkU2xvdEZuIiwiJHNjb3BlZFNsb3RzIiwibm9kZXMiLCIkc2xvdHMiLCIkY3JlYXRlRWxlbWVudCIsInJlc29sdmVGaWx0ZXIiLCJpc0tleU5vdE1hdGNoIiwiZXhwZWN0IiwiYWN0dWFsIiwiY2hlY2tLZXlDb2RlcyIsImV2ZW50S2V5Q29kZSIsImJ1aWx0SW5LZXlDb2RlIiwiZXZlbnRLZXlOYW1lIiwiYnVpbHRJbktleU5hbWUiLCJtYXBwZWRLZXlDb2RlIiwiYmluZE9iamVjdFByb3BzIiwiYXNQcm9wIiwiaXNTeW5jIiwibG9vcCIsImRvbVByb3BzIiwiY2FtZWxpemVkS2V5IiwiaHlwaGVuYXRlZEtleSIsIiRldmVudCIsInJlbmRlclN0YXRpYyIsImlzSW5Gb3IiLCJfc3RhdGljVHJlZXMiLCJzdGF0aWNSZW5kZXJGbnMiLCJtYXJrU3RhdGljIiwibWFya09uY2UiLCJtYXJrU3RhdGljTm9kZSIsImJpbmRPYmplY3RMaXN0ZW5lcnMiLCJleGlzdGluZyIsIm91cnMiLCJyZXNvbHZlU2NvcGVkU2xvdHMiLCJoYXNEeW5hbWljS2V5cyIsImNvbnRlbnRIYXNoS2V5IiwiYmluZER5bmFtaWNLZXlzIiwiYmFzZU9iaiIsInZhbHVlcyIsInByZXBlbmRNb2RpZmllciIsInN5bWJvbCIsImluc3RhbGxSZW5kZXJIZWxwZXJzIiwiX28iLCJfbiIsIl9zIiwiX2wiLCJfdCIsIl9xIiwiX2kiLCJfbSIsIl9mIiwiX2siLCJfYiIsIl92IiwiX2UiLCJfdSIsIl9nIiwiX2QiLCJfcCIsIkZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IiwidGhpcyQxIiwiY29udGV4dFZtIiwiX29yaWdpbmFsIiwiaXNDb21waWxlZCIsIl9jb21waWxlZCIsIm5lZWROb3JtYWxpemF0aW9uIiwibGlzdGVuZXJzIiwiaW5qZWN0aW9ucyIsInNjb3BlZFNsb3RzIiwiX3Njb3BlSWQiLCJfYyIsImQiLCJjcmVhdGVFbGVtZW50IiwiY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudCIsIm1lcmdlUHJvcHMiLCJyZW5kZXJDb250ZXh0IiwiY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCIsInZub2RlcyIsImNsb25lIiwiZGV2dG9vbHNNZXRhIiwiY29tcG9uZW50Vk5vZGVIb29rcyIsImluaXQiLCJoeWRyYXRpbmciLCJfaXNEZXN0cm95ZWQiLCJrZWVwQWxpdmUiLCJtb3VudGVkTm9kZSIsInByZXBhdGNoIiwiY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZSIsImFjdGl2ZUluc3RhbmNlIiwiJG1vdW50Iiwib2xkVm5vZGUiLCJ1cGRhdGVDaGlsZENvbXBvbmVudCIsImluc2VydCIsIl9pc01vdW50ZWQiLCJjYWxsSG9vayIsInF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50IiwiYWN0aXZhdGVDaGlsZENvbXBvbmVudCIsImRlc3Ryb3kiLCIkZGVzdHJveSIsImRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCIsImhvb2tzVG9NZXJnZSIsImNyZWF0ZUNvbXBvbmVudCIsImJhc2VDdG9yIiwicmVzb2x2ZUFzeW5jQ29tcG9uZW50IiwiY3JlYXRlQXN5bmNQbGFjZWhvbGRlciIsInJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMiLCJtb2RlbCIsInRyYW5zZm9ybU1vZGVsIiwiZnVuY3Rpb25hbCIsIm5hdGl2ZU9uIiwiYWJzdHJhY3QiLCJpbnN0YWxsQ29tcG9uZW50SG9va3MiLCJfaXNDb21wb25lbnQiLCJfcGFyZW50Vm5vZGUiLCJpbmxpbmVUZW1wbGF0ZSIsInRvTWVyZ2UiLCJfbWVyZ2VkIiwibWVyZ2VIb29rJDEiLCJmMSIsImYyIiwiY2FsbGJhY2siLCJTSU1QTEVfTk9STUFMSVpFIiwiQUxXQVlTX05PUk1BTElaRSIsIm5vcm1hbGl6YXRpb25UeXBlIiwiYWx3YXlzTm9ybWFsaXplIiwiX2NyZWF0ZUVsZW1lbnQiLCJpcyIsIiR2bm9kZSIsInByZSIsImFwcGx5TlMiLCJyZWdpc3RlckRlZXBCaW5kaW5ncyIsImZvcmNlIiwic3R5bGUiLCJjbGFzcyIsImluaXRSZW5kZXIiLCJfdm5vZGUiLCJwYXJlbnRWbm9kZSIsIl9yZW5kZXJDaGlsZHJlbiIsInBhcmVudERhdGEiLCJpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQiLCJfcGFyZW50TGlzdGVuZXJzIiwiY3VycmVudFJlbmRlcmluZ0luc3RhbmNlIiwicmVuZGVyTWl4aW4iLCJWdWUiLCIkbmV4dFRpY2siLCJfcmVuZGVyIiwicmVmIiwicmVuZGVyRXJyb3IiLCJlbnN1cmVDdG9yIiwiY29tcCIsImJhc2UiLCJfX2VzTW9kdWxlIiwidG9TdHJpbmdUYWciLCJlcnJvckNvbXAiLCJyZXNvbHZlZCIsIm93bmVyIiwib3duZXJzIiwibG9hZGluZyIsImxvYWRpbmdDb21wIiwic3luYyIsInRpbWVyTG9hZGluZyIsInRpbWVyVGltZW91dCIsIiRvbiIsImZvcmNlUmVuZGVyIiwicmVuZGVyQ29tcGxldGVkIiwiJGZvcmNlVXBkYXRlIiwiY2xlYXJUaW1lb3V0IiwicmVqZWN0IiwicmVhc29uIiwiY29tcG9uZW50IiwiZGVsYXkiLCJ0aW1lb3V0IiwiZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCIsImluaXRFdmVudHMiLCJfZXZlbnRzIiwiX2hhc0hvb2tFdmVudCIsInVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyIsInJlbW92ZSQxIiwiJG9mZiIsIl90YXJnZXQiLCJvbmNlSGFuZGxlciIsIm9sZExpc3RlbmVycyIsImV2ZW50c01peGluIiwiaG9va1JFIiwiJG9uY2UiLCJpJDEiLCJjYnMiLCIkZW1pdCIsImxvd2VyQ2FzZUV2ZW50Iiwic2V0QWN0aXZlSW5zdGFuY2UiLCJwcmV2QWN0aXZlSW5zdGFuY2UiLCJpbml0TGlmZWN5Y2xlIiwiJGNoaWxkcmVuIiwiJHJlZnMiLCJfd2F0Y2hlciIsIl9pbmFjdGl2ZSIsIl9kaXJlY3RJbmFjdGl2ZSIsIl9pc0JlaW5nRGVzdHJveWVkIiwibGlmZWN5Y2xlTWl4aW4iLCJfdXBkYXRlIiwicHJldkVsIiwiJGVsIiwicHJldlZub2RlIiwicmVzdG9yZUFjdGl2ZUluc3RhbmNlIiwiX19wYXRjaF9fIiwiX192dWVfXyIsInRlYXJkb3duIiwiX3dhdGNoZXJzIiwiX2RhdGEiLCJtb3VudENvbXBvbmVudCIsInRlbXBsYXRlIiwidXBkYXRlQ29tcG9uZW50IiwiX25hbWUiLCJfdWlkIiwiV2F0Y2hlciIsImJlZm9yZSIsInJlbmRlckNoaWxkcmVuIiwibmV3U2NvcGVkU2xvdHMiLCJvbGRTY29wZWRTbG90cyIsImhhc0R5bmFtaWNTY29wZWRTbG90IiwibmVlZHNGb3JjZVVwZGF0ZSIsIiRhdHRycyIsIiRsaXN0ZW5lcnMiLCJwcm9wS2V5cyIsIl9wcm9wS2V5cyIsImlzSW5JbmFjdGl2ZVRyZWUiLCJkaXJlY3QiLCJqIiwiTUFYX1VQREFURV9DT1VOVCIsInF1ZXVlIiwiYWN0aXZhdGVkQ2hpbGRyZW4iLCJjaXJjdWxhciIsIndhaXRpbmciLCJmbHVzaGluZyIsInJlc2V0U2NoZWR1bGVyU3RhdGUiLCJjdXJyZW50Rmx1c2hUaW1lc3RhbXAiLCJnZXROb3ciLCJub3ciLCJjcmVhdGVFdmVudCIsInRpbWVTdGFtcCIsImZsdXNoU2NoZWR1bGVyUXVldWUiLCJ3YXRjaGVyIiwicnVuIiwidXNlciIsImV4cHJlc3Npb24iLCJhY3RpdmF0ZWRRdWV1ZSIsInVwZGF0ZWRRdWV1ZSIsImNhbGxBY3RpdmF0ZWRIb29rcyIsImNhbGxVcGRhdGVkSG9va3MiLCJlbWl0IiwicXVldWVXYXRjaGVyIiwidWlkJDIiLCJleHBPckZuIiwiaXNSZW5kZXJXYXRjaGVyIiwiZGVlcCIsImxhenkiLCJhY3RpdmUiLCJkaXJ0eSIsImRlcHMiLCJuZXdEZXBzIiwiZGVwSWRzIiwibmV3RGVwSWRzIiwiY2xlYW51cERlcHMiLCJ0bXAiLCJvbGRWYWx1ZSIsImV2YWx1YXRlIiwic2hhcmVkUHJvcGVydHlEZWZpbml0aW9uIiwic291cmNlS2V5IiwicHJveHlHZXR0ZXIiLCJwcm94eVNldHRlciIsImluaXRTdGF0ZSIsImluaXRQcm9wcyIsImluaXRNZXRob2RzIiwiaW5pdERhdGEiLCJpbml0Q29tcHV0ZWQiLCJpbml0V2F0Y2giLCJwcm9wc09wdGlvbnMiLCJpc1Jvb3QiLCJnZXREYXRhIiwiY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyIsIndhdGNoZXJzIiwiX2NvbXB1dGVkV2F0Y2hlcnMiLCJpc1NTUiIsInVzZXJEZWYiLCJkZWZpbmVDb21wdXRlZCIsInNob3VsZENhY2hlIiwiY3JlYXRlQ29tcHV0ZWRHZXR0ZXIiLCJjcmVhdGVHZXR0ZXJJbnZva2VyIiwiY29tcHV0ZWRHZXR0ZXIiLCJjcmVhdGVXYXRjaGVyIiwiJHdhdGNoIiwic3RhdGVNaXhpbiIsImRhdGFEZWYiLCJwcm9wc0RlZiIsIiRzZXQiLCIkZGVsZXRlIiwiaW1tZWRpYXRlIiwidW53YXRjaEZuIiwidWlkJDMiLCJpbml0TWl4aW4iLCJfaW5pdCIsImluaXRJbnRlcm5hbENvbXBvbmVudCIsIl9zZWxmIiwidm5vZGVDb21wb25lbnRPcHRpb25zIiwic3VwZXIiLCJzdXBlck9wdGlvbnMiLCJjYWNoZWRTdXBlck9wdGlvbnMiLCJtb2RpZmllZE9wdGlvbnMiLCJyZXNvbHZlTW9kaWZpZWRPcHRpb25zIiwiZXh0ZW5kT3B0aW9ucyIsIm1vZGlmaWVkIiwibGF0ZXN0Iiwic2VhbGVkIiwic2VhbGVkT3B0aW9ucyIsImluaXRVc2UiLCJ1c2UiLCJwbHVnaW4iLCJpbnN0YWxsZWRQbHVnaW5zIiwiX2luc3RhbGxlZFBsdWdpbnMiLCJ1bnNoaWZ0IiwiaW5zdGFsbCIsImluaXRNaXhpbiQxIiwibWl4aW4iLCJpbml0RXh0ZW5kIiwiU3VwZXIiLCJTdXBlcklkIiwiY2FjaGVkQ3RvcnMiLCJfQ3RvciIsIlN1YiIsIlZ1ZUNvbXBvbmVudCIsImluaXRQcm9wcyQxIiwiaW5pdENvbXB1dGVkJDEiLCJDb21wIiwiaW5pdEFzc2V0UmVnaXN0ZXJzIiwiZGVmaW5pdGlvbiIsImdldENvbXBvbmVudE5hbWUiLCJtYXRjaGVzIiwicGF0dGVybiIsInBydW5lQ2FjaGUiLCJrZWVwQWxpdmVJbnN0YW5jZSIsImZpbHRlciIsImNhY2hlZE5vZGUiLCJwcnVuZUNhY2hlRW50cnkiLCJjdXJyZW50IiwiY2FjaGVkJCQxIiwicGF0dGVyblR5cGVzIiwiS2VlcEFsaXZlIiwiaW5jbHVkZSIsImV4Y2x1ZGUiLCJjcmVhdGVkIiwiZGVzdHJveWVkIiwibW91bnRlZCIsInJlZiQxIiwicGFyc2VJbnQiLCJidWlsdEluQ29tcG9uZW50cyIsImluaXRHbG9iYWxBUEkiLCJjb25maWdEZWYiLCJ1dGlsIiwiZGVmaW5lUmVhY3RpdmUiLCJkZWxldGUiLCJvYnNlcnZhYmxlIiwic3NyQ29udGV4dCIsInZlcnNpb24iLCJhY2NlcHRWYWx1ZSIsImF0dHIiLCJpc0VudW1lcmF0ZWRBdHRyIiwiaXNWYWxpZENvbnRlbnRFZGl0YWJsZVZhbHVlIiwiY29udmVydEVudW1lcmF0ZWRWYWx1ZSIsImlzRmFsc3lBdHRyVmFsdWUiLCJpc0Jvb2xlYW5BdHRyIiwieGxpbmtOUyIsImlzWGxpbmsiLCJnZXRYbGlua1Byb3AiLCJnZW5DbGFzc0ZvclZub2RlIiwicGFyZW50Tm9kZSIsImNoaWxkTm9kZSIsIm1lcmdlQ2xhc3NEYXRhIiwicmVuZGVyQ2xhc3MiLCJzdGF0aWNDbGFzcyIsImR5bmFtaWNDbGFzcyIsInN0cmluZ2lmeUNsYXNzIiwic3RyaW5naWZ5QXJyYXkiLCJzdHJpbmdpZnlPYmplY3QiLCJzdHJpbmdpZmllZCIsIm5hbWVzcGFjZU1hcCIsInN2ZyIsIm1hdGgiLCJpc0hUTUxUYWciLCJpc1NWRyIsImlzUHJlVGFnIiwidW5rbm93bkVsZW1lbnRDYWNoZSIsIkhUTUxVbmtub3duRWxlbWVudCIsIkhUTUxFbGVtZW50IiwiaXNUZXh0SW5wdXRUeXBlIiwicXVlcnkiLCJzZWxlY3RlZCIsInF1ZXJ5U2VsZWN0b3IiLCJjcmVhdGVFbGVtZW50JDEiLCJ0YWdOYW1lIiwibXVsdGlwbGUiLCJzZXRBdHRyaWJ1dGUiLCJjcmVhdGVFbGVtZW50TlMiLCJuYW1lc3BhY2UiLCJjcmVhdGVDb21tZW50IiwiaW5zZXJ0QmVmb3JlIiwibmV3Tm9kZSIsInJlZmVyZW5jZU5vZGUiLCJyZW1vdmVDaGlsZCIsImFwcGVuZENoaWxkIiwibmV4dFNpYmxpbmciLCJzZXRUZXh0Q29udGVudCIsInRleHRDb250ZW50Iiwic2V0U3R5bGVTY29wZSIsInNjb3BlSWQiLCJub2RlT3BzIiwicmVnaXN0ZXJSZWYiLCJpc1JlbW92YWwiLCJyZWZzIiwicmVmSW5Gb3IiLCJlbXB0eU5vZGUiLCJzYW1lVm5vZGUiLCJzYW1lSW5wdXRUeXBlIiwidHlwZUEiLCJ0eXBlQiIsImNyZWF0ZUtleVRvT2xkSWR4IiwiYmVnaW5JZHgiLCJlbmRJZHgiLCJjcmVhdGVQYXRjaEZ1bmN0aW9uIiwiYmFja2VuZCIsImVtcHR5Tm9kZUF0IiwiY3JlYXRlUm1DYiIsImNoaWxkRWxtIiwicmVtb3ZlTm9kZSIsImlzVW5rbm93bkVsZW1lbnQkJDEiLCJpblZQcmUiLCJpZ25vcmUiLCJjcmVhdGluZ0VsbUluVlByZSIsImNyZWF0ZUVsbSIsImluc2VydGVkVm5vZGVRdWV1ZSIsInBhcmVudEVsbSIsInJlZkVsbSIsIm5lc3RlZCIsIm93bmVyQXJyYXkiLCJzZXRTY29wZSIsImNyZWF0ZUNoaWxkcmVuIiwiaW52b2tlQ3JlYXRlSG9va3MiLCJpc1JlYWN0aXZhdGVkIiwiaW5pdENvbXBvbmVudCIsInJlYWN0aXZhdGVDb21wb25lbnQiLCJwZW5kaW5nSW5zZXJ0IiwiaXNQYXRjaGFibGUiLCJpbm5lck5vZGUiLCJ0cmFuc2l0aW9uIiwiYWN0aXZhdGUiLCJyZWYkJDEiLCJjaGVja0R1cGxpY2F0ZUtleXMiLCJhbmNlc3RvciIsImFkZFZub2RlcyIsInN0YXJ0SWR4IiwiaW52b2tlRGVzdHJveUhvb2siLCJyZW1vdmVWbm9kZXMiLCJjaCIsInJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2siLCJybSIsInVwZGF0ZUNoaWxkcmVuIiwib2xkQ2giLCJuZXdDaCIsInJlbW92ZU9ubHkiLCJvbGRTdGFydElkeCIsIm5ld1N0YXJ0SWR4Iiwib2xkRW5kSWR4Iiwib2xkU3RhcnRWbm9kZSIsIm9sZEVuZFZub2RlIiwibmV3RW5kSWR4IiwibmV3U3RhcnRWbm9kZSIsIm5ld0VuZFZub2RlIiwib2xkS2V5VG9JZHgiLCJpZHhJbk9sZCIsInZub2RlVG9Nb3ZlIiwiY2FuTW92ZSIsInBhdGNoVm5vZGUiLCJmaW5kSWR4SW5PbGQiLCJzZWVuS2V5cyIsImVuZCIsImh5ZHJhdGUiLCJwb3N0cGF0Y2giLCJpbnZva2VJbnNlcnRIb29rIiwiaW5pdGlhbCIsImh5ZHJhdGlvbkJhaWxlZCIsImlzUmVuZGVyZWRNb2R1bGUiLCJhc3NlcnROb2RlTWF0Y2giLCJoYXNDaGlsZE5vZGVzIiwiaW5uZXJIVE1MIiwiY2hpbGRyZW5NYXRjaCIsImZpcnN0Q2hpbGQiLCJjaGlsZE5vZGVzIiwiZnVsbEludm9rZSIsIm5vZGVUeXBlIiwicGF0Y2giLCJpc0luaXRpYWxQYXRjaCIsImlzUmVhbEVsZW1lbnQiLCJoYXNBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJvbGRFbG0iLCJfbGVhdmVDYiIsInBhdGNoYWJsZSIsImkkMiIsInVwZGF0ZURpcmVjdGl2ZXMiLCJ1bmJpbmREaXJlY3RpdmVzIiwiaXNDcmVhdGUiLCJpc0Rlc3Ryb3kiLCJvbGREaXJzIiwibm9ybWFsaXplRGlyZWN0aXZlcyQxIiwibmV3RGlycyIsImRpcnNXaXRoSW5zZXJ0IiwiZGlyc1dpdGhQb3N0cGF0Y2giLCJvbGREaXIiLCJkaXIiLCJjYWxsSG9vayQxIiwib2xkQXJnIiwiYXJnIiwiY29tcG9uZW50VXBkYXRlZCIsImNhbGxJbnNlcnQiLCJlbXB0eU1vZGlmaWVycyIsIm1vZGlmaWVycyIsImdldFJhd0Rpck5hbWUiLCJyYXdOYW1lIiwiYmFzZU1vZHVsZXMiLCJ1cGRhdGVBdHRycyIsImluaGVyaXRBdHRycyIsIm9sZEF0dHJzIiwic2V0QXR0ciIsInJlbW92ZUF0dHJpYnV0ZU5TIiwiYmFzZVNldEF0dHIiLCJzZXRBdHRyaWJ1dGVOUyIsIl9faWVwaCIsImJsb2NrZXIiLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJyZW1vdmVFdmVudExpc3RlbmVyIiwidXBkYXRlQ2xhc3MiLCJvbGREYXRhIiwiY2xzIiwidHJhbnNpdGlvbkNsYXNzIiwiX3RyYW5zaXRpb25DbGFzc2VzIiwiX3ByZXZDbGFzcyIsImtsYXNzIiwidmFsaWREaXZpc2lvbkNoYXJSRSIsInBhcnNlRmlsdGVycyIsImV4cCIsImluU2luZ2xlIiwiaW5Eb3VibGUiLCJpblRlbXBsYXRlU3RyaW5nIiwiaW5SZWdleCIsImN1cmx5Iiwic3F1YXJlIiwicGFyZW4iLCJsYXN0RmlsdGVySW5kZXgiLCJwcmV2IiwiZmlsdGVycyIsInRyaW0iLCJwdXNoRmlsdGVyIiwid3JhcEZpbHRlciIsImJhc2VXYXJuIiwicmFuZ2UiLCJwbHVja01vZHVsZUZ1bmN0aW9uIiwiYWRkUHJvcCIsImR5bmFtaWMiLCJyYW5nZVNldEl0ZW0iLCJwbGFpbiIsImFkZEF0dHIiLCJkeW5hbWljQXR0cnMiLCJhZGRSYXdBdHRyIiwiYXR0cnNNYXAiLCJhdHRyc0xpc3QiLCJhZGREaXJlY3RpdmUiLCJpc0R5bmFtaWNBcmciLCJwcmVwZW5kTW9kaWZpZXJNYXJrZXIiLCJhZGRIYW5kbGVyIiwiaW1wb3J0YW50IiwicHJldmVudCIsInJpZ2h0IiwibWlkZGxlIiwiZXZlbnRzIiwibmF0aXZlIiwibmF0aXZlRXZlbnRzIiwibmV3SGFuZGxlciIsImdldFJhd0JpbmRpbmdBdHRyIiwicmF3QXR0cnNNYXAiLCJnZXRCaW5kaW5nQXR0ciIsImdldFN0YXRpYyIsImR5bmFtaWNWYWx1ZSIsImdldEFuZFJlbW92ZUF0dHIiLCJzdGF0aWNWYWx1ZSIsInJlbW92ZUZyb21NYXAiLCJnZXRBbmRSZW1vdmVBdHRyQnlSZWdleCIsImdlbkNvbXBvbmVudE1vZGVsIiwibnVtYmVyIiwiYmFzZVZhbHVlRXhwcmVzc2lvbiIsInZhbHVlRXhwcmVzc2lvbiIsImFzc2lnbm1lbnQiLCJnZW5Bc3NpZ25tZW50Q29kZSIsInBhcnNlTW9kZWwiLCJjaHIiLCJpbmRleCQxIiwiZXhwcmVzc2lvblBvcyIsImV4cHJlc3Npb25FbmRQb3MiLCJsYXN0SW5kZXhPZiIsImVvZiIsImlzU3RyaW5nU3RhcnQiLCJwYXJzZVN0cmluZyIsInBhcnNlQnJhY2tldCIsImluQnJhY2tldCIsInN0cmluZ1F1b3RlIiwid2FybiQxIiwiUkFOR0VfVE9LRU4iLCJDSEVDS0JPWF9SQURJT19UT0tFTiIsIl93YXJuIiwiZ2VuU2VsZWN0IiwiZ2VuQ2hlY2tib3hNb2RlbCIsImdlblJhZGlvTW9kZWwiLCJnZW5EZWZhdWx0TW9kZWwiLCJ2YWx1ZUJpbmRpbmciLCJ0cnVlVmFsdWVCaW5kaW5nIiwiZmFsc2VWYWx1ZUJpbmRpbmciLCJzZWxlY3RlZFZhbCIsImNvZGUiLCJ2YWx1ZSQxIiwidHlwZUJpbmRpbmciLCJiaW5kaW5nIiwibmVlZENvbXBvc2l0aW9uR3VhcmQiLCJub3JtYWxpemVFdmVudHMiLCJjaGFuZ2UiLCJ0YXJnZXQkMSIsImNyZWF0ZU9uY2VIYW5kbGVyJDEiLCJyZW1vdmUkMiIsInVzZU1pY3JvdGFza0ZpeCIsImFkZCQxIiwiYXR0YWNoZWRUaW1lc3RhbXAiLCJfd3JhcHBlciIsImN1cnJlbnRUYXJnZXQiLCJvd25lckRvY3VtZW50IiwidXBkYXRlRE9NTGlzdGVuZXJzIiwic3ZnQ29udGFpbmVyIiwidXBkYXRlRE9NUHJvcHMiLCJvbGRQcm9wcyIsIl92YWx1ZSIsInN0ckN1ciIsInNob3VsZFVwZGF0ZVZhbHVlIiwiY2hlY2tWYWwiLCJjb21wb3NpbmciLCJpc05vdEluRm9jdXNBbmREaXJ0eSIsImlzRGlydHlXaXRoTW9kaWZpZXJzIiwibm90SW5Gb2N1cyIsImFjdGl2ZUVsZW1lbnQiLCJfdk1vZGlmaWVycyIsInBhcnNlU3R5bGVUZXh0IiwiY3NzVGV4dCIsImxpc3REZWxpbWl0ZXIiLCJwcm9wZXJ0eURlbGltaXRlciIsIm5vcm1hbGl6ZVN0eWxlRGF0YSIsIm5vcm1hbGl6ZVN0eWxlQmluZGluZyIsInN0YXRpY1N0eWxlIiwiYmluZGluZ1N0eWxlIiwiZ2V0U3R5bGUiLCJjaGVja0NoaWxkIiwic3R5bGVEYXRhIiwiY3NzVmFyUkUiLCJpbXBvcnRhbnRSRSIsInNldFByb3AiLCJzZXRQcm9wZXJ0eSIsIm5vcm1hbGl6ZWROYW1lIiwibm9ybWFsaXplIiwidmVuZG9yTmFtZXMiLCJlbXB0eVN0eWxlIiwiY2FwTmFtZSIsInVwZGF0ZVN0eWxlIiwib2xkU3RhdGljU3R5bGUiLCJvbGRTdHlsZUJpbmRpbmciLCJub3JtYWxpemVkU3R5bGUiLCJvbGRTdHlsZSIsIm5ld1N0eWxlIiwid2hpdGVzcGFjZVJFIiwiYWRkQ2xhc3MiLCJjbGFzc0xpc3QiLCJnZXRBdHRyaWJ1dGUiLCJyZW1vdmVDbGFzcyIsInRhciIsInJlc29sdmVUcmFuc2l0aW9uIiwiY3NzIiwiYXV0b0Nzc1RyYW5zaXRpb24iLCJlbnRlckNsYXNzIiwiZW50ZXJUb0NsYXNzIiwiZW50ZXJBY3RpdmVDbGFzcyIsImxlYXZlQ2xhc3MiLCJsZWF2ZVRvQ2xhc3MiLCJsZWF2ZUFjdGl2ZUNsYXNzIiwiaGFzVHJhbnNpdGlvbiIsIlRSQU5TSVRJT04iLCJBTklNQVRJT04iLCJ0cmFuc2l0aW9uUHJvcCIsInRyYW5zaXRpb25FbmRFdmVudCIsImFuaW1hdGlvblByb3AiLCJhbmltYXRpb25FbmRFdmVudCIsIm9udHJhbnNpdGlvbmVuZCIsIm9ud2Via2l0dHJhbnNpdGlvbmVuZCIsIm9uYW5pbWF0aW9uZW5kIiwib253ZWJraXRhbmltYXRpb25lbmQiLCJyYWYiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJuZXh0RnJhbWUiLCJhZGRUcmFuc2l0aW9uQ2xhc3MiLCJ0cmFuc2l0aW9uQ2xhc3NlcyIsInJlbW92ZVRyYW5zaXRpb25DbGFzcyIsIndoZW5UcmFuc2l0aW9uRW5kcyIsImdldFRyYW5zaXRpb25JbmZvIiwicHJvcENvdW50IiwiZW5kZWQiLCJvbkVuZCIsInRyYW5zZm9ybVJFIiwic3R5bGVzIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInRyYW5zaXRpb25EZWxheXMiLCJ0cmFuc2l0aW9uRHVyYXRpb25zIiwidHJhbnNpdGlvblRpbWVvdXQiLCJnZXRUaW1lb3V0IiwiYW5pbWF0aW9uRGVsYXlzIiwiYW5pbWF0aW9uRHVyYXRpb25zIiwiYW5pbWF0aW9uVGltZW91dCIsImhhc1RyYW5zZm9ybSIsImRlbGF5cyIsImR1cmF0aW9ucyIsInRvTXMiLCJzIiwiZW50ZXIiLCJ0b2dnbGVEaXNwbGF5IiwiY2FuY2VsbGVkIiwiX2VudGVyQ2IiLCJhcHBlYXJDbGFzcyIsImFwcGVhclRvQ2xhc3MiLCJhcHBlYXJBY3RpdmVDbGFzcyIsImJlZm9yZUVudGVyIiwiYWZ0ZXJFbnRlciIsImVudGVyQ2FuY2VsbGVkIiwiYmVmb3JlQXBwZWFyIiwiYXBwZWFyIiwiYWZ0ZXJBcHBlYXIiLCJhcHBlYXJDYW5jZWxsZWQiLCJkdXJhdGlvbiIsInRyYW5zaXRpb25Ob2RlIiwiaXNBcHBlYXIiLCJzdGFydENsYXNzIiwiYWN0aXZlQ2xhc3MiLCJ0b0NsYXNzIiwiYmVmb3JlRW50ZXJIb29rIiwiZW50ZXJIb29rIiwiYWZ0ZXJFbnRlckhvb2siLCJlbnRlckNhbmNlbGxlZEhvb2siLCJleHBsaWNpdEVudGVyRHVyYXRpb24iLCJjaGVja0R1cmF0aW9uIiwiZXhwZWN0c0NTUyIsInVzZXJXYW50c0NvbnRyb2wiLCJnZXRIb29rQXJndW1lbnRzTGVuZ3RoIiwic2hvdyIsInBlbmRpbmdOb2RlIiwiX3BlbmRpbmciLCJpc1ZhbGlkRHVyYXRpb24iLCJsZWF2ZSIsImJlZm9yZUxlYXZlIiwiYWZ0ZXJMZWF2ZSIsImxlYXZlQ2FuY2VsbGVkIiwiZGVsYXlMZWF2ZSIsImV4cGxpY2l0TGVhdmVEdXJhdGlvbiIsInBlcmZvcm1MZWF2ZSIsImludm9rZXJGbnMiLCJfZW50ZXIiLCJwbGF0Zm9ybU1vZHVsZXMiLCJ2bW9kZWwiLCJ0cmlnZ2VyIiwiZGlyZWN0aXZlIiwiX3ZPcHRpb25zIiwic2V0U2VsZWN0ZWQiLCJnZXRWYWx1ZSIsIm9uQ29tcG9zaXRpb25TdGFydCIsIm9uQ29tcG9zaXRpb25FbmQiLCJwcmV2T3B0aW9ucyIsImN1ck9wdGlvbnMiLCJvIiwibmVlZFJlc2V0IiwiaGFzTm9NYXRjaGluZ09wdGlvbiIsImFjdHVhbGx5U2V0U2VsZWN0ZWQiLCJpc011bHRpcGxlIiwib3B0aW9uIiwic2VsZWN0ZWRJbmRleCIsImluaXRFdmVudCIsImRpc3BhdGNoRXZlbnQiLCJsb2NhdGVOb2RlIiwidHJhbnNpdGlvbiQkMSIsIm9yaWdpbmFsRGlzcGxheSIsIl9fdk9yaWdpbmFsRGlzcGxheSIsImRpc3BsYXkiLCJ1bmJpbmQiLCJwbGF0Zm9ybURpcmVjdGl2ZXMiLCJ0cmFuc2l0aW9uUHJvcHMiLCJtb2RlIiwiZ2V0UmVhbENoaWxkIiwiY29tcE9wdGlvbnMiLCJleHRyYWN0VHJhbnNpdGlvbkRhdGEiLCJwbGFjZWhvbGRlciIsImgiLCJyYXdDaGlsZCIsImhhc1BhcmVudFRyYW5zaXRpb24iLCJpc1NhbWVDaGlsZCIsIm9sZENoaWxkIiwiaXNOb3RUZXh0Tm9kZSIsImlzVlNob3dEaXJlY3RpdmUiLCJUcmFuc2l0aW9uIiwiX2xlYXZpbmciLCJvbGRSYXdDaGlsZCIsImRlbGF5ZWRMZWF2ZSIsIm1vdmVDbGFzcyIsIlRyYW5zaXRpb25Hcm91cCIsImJlZm9yZU1vdW50Iiwia2VwdCIsInByZXZDaGlsZHJlbiIsInJhd0NoaWxkcmVuIiwidHJhbnNpdGlvbkRhdGEiLCJyZW1vdmVkIiwiYyQxIiwicG9zIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwidXBkYXRlZCIsImhhc01vdmUiLCJjYWxsUGVuZGluZ0NicyIsInJlY29yZFBvc2l0aW9uIiwiYXBwbHlUcmFuc2xhdGlvbiIsIl9yZWZsb3ciLCJib2R5Iiwib2Zmc2V0SGVpZ2h0IiwibW92ZWQiLCJ0cmFuc2Zvcm0iLCJXZWJraXRUcmFuc2Zvcm0iLCJ0cmFuc2l0aW9uRHVyYXRpb24iLCJfbW92ZUNiIiwicHJvcGVydHlOYW1lIiwiX2hhc01vdmUiLCJjbG9uZU5vZGUiLCJuZXdQb3MiLCJvbGRQb3MiLCJkeCIsImxlZnQiLCJkeSIsInRvcCIsInBsYXRmb3JtQ29tcG9uZW50cyIsImRlZmF1bHRUYWdSRSIsInJlZ2V4RXNjYXBlUkUiLCJidWlsZFJlZ2V4IiwiZGVsaW1pdGVycyIsIm9wZW4iLCJjbG9zZSIsInBhcnNlVGV4dCIsInRhZ1JFIiwidG9rZW5zIiwicmF3VG9rZW5zIiwidG9rZW5WYWx1ZSIsImV4ZWMiLCJ0cmFuc2Zvcm1Ob2RlIiwiY2xhc3NCaW5kaW5nIiwiZ2VuRGF0YSIsImtsYXNzJDEiLCJ0cmFuc2Zvcm1Ob2RlJDEiLCJzdHlsZUJpbmRpbmciLCJnZW5EYXRhJDEiLCJzdHlsZSQxIiwiZGVjb2RlciIsImhlIiwiZGVjb2RlIiwiaHRtbCIsImlzVW5hcnlUYWciLCJjYW5CZUxlZnRPcGVuVGFnIiwiaXNOb25QaHJhc2luZ1RhZyIsImF0dHJpYnV0ZSIsImR5bmFtaWNBcmdBdHRyaWJ1dGUiLCJuY25hbWUiLCJxbmFtZUNhcHR1cmUiLCJzdGFydFRhZ09wZW4iLCJzdGFydFRhZ0Nsb3NlIiwiZG9jdHlwZSIsImNvbW1lbnQiLCJjb25kaXRpb25hbENvbW1lbnQiLCJpc1BsYWluVGV4dEVsZW1lbnQiLCJyZUNhY2hlIiwiZGVjb2RpbmdNYXAiLCJlbmNvZGVkQXR0ciIsImVuY29kZWRBdHRyV2l0aE5ld0xpbmVzIiwiaXNJZ25vcmVOZXdsaW5lVGFnIiwic2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lIiwiZGVjb2RlQXR0ciIsInNob3VsZERlY29kZU5ld2xpbmVzIiwicmUiLCJwYXJzZUhUTUwiLCJzdGFjayIsImV4cGVjdEhUTUwiLCJpc1VuYXJ5VGFnJCQxIiwiY2FuQmVMZWZ0T3BlblRhZyQkMSIsImxhc3RUYWciLCJ0ZXh0RW5kIiwiY29tbWVudEVuZCIsInNob3VsZEtlZXBDb21tZW50Iiwic3Vic3RyaW5nIiwiYWR2YW5jZSIsImNvbmRpdGlvbmFsRW5kIiwiZG9jdHlwZU1hdGNoIiwiZW5kVGFnTWF0Y2giLCJjdXJJbmRleCIsInBhcnNlRW5kVGFnIiwic3RhcnRUYWdNYXRjaCIsInBhcnNlU3RhcnRUYWciLCJoYW5kbGVTdGFydFRhZyIsInJlc3QiLCJjaGFycyIsImVuZFRhZ0xlbmd0aCIsInN0YWNrZWRUYWciLCJyZVN0YWNrZWRUYWciLCJyZXN0JDEiLCJhbGwiLCJ1bmFyeVNsYXNoIiwidW5hcnkiLCJzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYiLCJvdXRwdXRTb3VyY2VSYW5nZSIsImxvd2VyQ2FzZWRUYWciLCJsb3dlckNhc2VkVGFnTmFtZSIsIm9uUkUiLCJkaXJSRSIsImZvckFsaWFzUkUiLCJmb3JJdGVyYXRvclJFIiwic3RyaXBQYXJlbnNSRSIsImR5bmFtaWNBcmdSRSIsImFyZ1JFIiwiYmluZFJFIiwibW9kaWZpZXJSRSIsInNsb3RSRSIsImxpbmVCcmVha1JFIiwid2hpdGVzcGFjZVJFJDEiLCJpbnZhbGlkQXR0cmlidXRlUkUiLCJkZWNvZGVIVE1MQ2FjaGVkIiwiZW1wdHlTbG90U2NvcGVUb2tlbiIsIndhcm4kMiIsInRyYW5zZm9ybXMiLCJwcmVUcmFuc2Zvcm1zIiwicG9zdFRyYW5zZm9ybXMiLCJwbGF0Zm9ybUlzUHJlVGFnIiwicGxhdGZvcm1NdXN0VXNlUHJvcCIsInBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlIiwibWF5YmVDb21wb25lbnQiLCJjcmVhdGVBU1RFbGVtZW50IiwibWFrZUF0dHJzTWFwIiwicGFyc2UiLCJwcmVzZXJ2ZVdoaXRlc3BhY2UiLCJ3aGl0ZXNwYWNlT3B0aW9uIiwid2hpdGVzcGFjZSIsInJvb3QiLCJjdXJyZW50UGFyZW50IiwiaW5QcmUiLCJ3YXJuZWQiLCJ3YXJuT25jZSIsImNsb3NlRWxlbWVudCIsImVsZW1lbnQiLCJ0cmltRW5kaW5nV2hpdGVzcGFjZSIsInByb2Nlc3NlZCIsInByb2Nlc3NFbGVtZW50IiwiaWYiLCJlbHNlaWYiLCJlbHNlIiwiY2hlY2tSb290Q29uc3RyYWludHMiLCJhZGRJZkNvbmRpdGlvbiIsImJsb2NrIiwiZm9yYmlkZGVuIiwicHJvY2Vzc0lmQ29uZGl0aW9ucyIsInNsb3RTY29wZSIsInNsb3RUYXJnZXQiLCJsYXN0Tm9kZSIsImNvbW1lbnRzIiwic3RhcnQkMSIsImd1YXJkSUVTVkdCdWciLCJjdW11bGF0ZWQiLCJpc0ZvcmJpZGRlblRhZyIsInByb2Nlc3NQcmUiLCJwcm9jZXNzUmF3QXR0cnMiLCJwcm9jZXNzRm9yIiwicHJvY2Vzc0lmIiwicHJvY2Vzc09uY2UiLCJlbmQkMSIsImlzVGV4dFRhZyIsInByb2Nlc3NLZXkiLCJwcm9jZXNzUmVmIiwicHJvY2Vzc1Nsb3RDb250ZW50IiwicHJvY2Vzc1Nsb3RPdXRsZXQiLCJwcm9jZXNzQ29tcG9uZW50IiwicHJvY2Vzc0F0dHJzIiwiZm9yIiwiaXRlcmF0b3IyIiwiaXRlcmF0b3IxIiwiY2hlY2tJbkZvciIsInBhcnNlRm9yIiwiaW5NYXRjaCIsImFsaWFzIiwiaXRlcmF0b3JNYXRjaCIsImZpbmRQcmV2RWxlbWVudCIsImNvbmRpdGlvbiIsImlmQ29uZGl0aW9ucyIsInNsb3RUYXJnZXREeW5hbWljIiwic2xvdEJpbmRpbmciLCJnZXRTbG90TmFtZSIsInNsb3RCaW5kaW5nJDEiLCJkeW5hbWljJDEiLCJzbG90Q29udGFpbmVyIiwic2xvdE5hbWUiLCJzeW5jR2VuIiwiaXNEeW5hbWljIiwiaGFzQmluZGluZ3MiLCJwYXJzZU1vZGlmaWVycyIsImNhbWVsIiwiYXJnTWF0Y2giLCJjaGVja0ZvckFsaWFzTW9kZWwiLCJpZU5TQnVnIiwiaWVOU1ByZWZpeCIsIl9lbCIsInByZVRyYW5zZm9ybU5vZGUiLCJpZkNvbmRpdGlvbiIsImlmQ29uZGl0aW9uRXh0cmEiLCJoYXNFbHNlIiwiZWxzZUlmQ29uZGl0aW9uIiwiYnJhbmNoMCIsImNsb25lQVNURWxlbWVudCIsImJyYW5jaDEiLCJicmFuY2gyIiwibW9kZWwkMSIsIm1vZHVsZXMkMSIsImRpcmVjdGl2ZXMkMSIsImJhc2VPcHRpb25zIiwiaXNTdGF0aWNLZXkiLCJpc1BsYXRmb3JtUmVzZXJ2ZWRUYWciLCJnZW5TdGF0aWNLZXlzQ2FjaGVkIiwiZ2VuU3RhdGljS2V5cyQxIiwib3B0aW1pemUiLCJtYXJrU3RhdGljJDEiLCJtYXJrU3RhdGljUm9vdHMiLCJzdGF0aWMiLCJsJDEiLCJzdGF0aWNJbkZvciIsInN0YXRpY1Jvb3QiLCJpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvciIsImZuRXhwUkUiLCJmbkludm9rZVJFIiwic2ltcGxlUGF0aFJFIiwiZXNjIiwidGFiIiwic3BhY2UiLCJ1cCIsImRvd24iLCJrZXlOYW1lcyIsImdlbkd1YXJkIiwibW9kaWZpZXJDb2RlIiwic3RvcCIsInNlbGYiLCJjdHJsIiwiYWx0IiwibWV0YSIsImdlbkhhbmRsZXJzIiwicHJlZml4Iiwic3RhdGljSGFuZGxlcnMiLCJkeW5hbWljSGFuZGxlcnMiLCJoYW5kbGVyQ29kZSIsImdlbkhhbmRsZXIiLCJpc01ldGhvZFBhdGgiLCJpc0Z1bmN0aW9uRXhwcmVzc2lvbiIsImlzRnVuY3Rpb25JbnZvY2F0aW9uIiwiZ2VuTW9kaWZpZXJDb2RlIiwia2V5TW9kaWZpZXIiLCJnZW5LZXlGaWx0ZXIiLCJnZW5GaWx0ZXJDb2RlIiwia2V5VmFsIiwia2V5Q29kZSIsImtleU5hbWUiLCJ3cmFwTGlzdGVuZXJzIiwiYmluZCQxIiwid3JhcERhdGEiLCJiYXNlRGlyZWN0aXZlcyIsImNsb2FrIiwiQ29kZWdlblN0YXRlIiwiZGF0YUdlbkZucyIsIm9uY2VJZCIsImdlbmVyYXRlIiwiYXN0Iiwic3RhdGUiLCJnZW5FbGVtZW50Iiwic3RhdGljUHJvY2Vzc2VkIiwiZ2VuU3RhdGljIiwib25jZVByb2Nlc3NlZCIsImdlbk9uY2UiLCJmb3JQcm9jZXNzZWQiLCJnZW5Gb3IiLCJpZlByb2Nlc3NlZCIsImdlbklmIiwiZ2VuQ2hpbGRyZW4iLCJnZW5TbG90IiwiZ2VuQ29tcG9uZW50IiwiZ2VuRGF0YSQyIiwib3JpZ2luYWxQcmVTdGF0ZSIsImFsdEdlbiIsImFsdEVtcHR5IiwiZ2VuSWZDb25kaXRpb25zIiwiY29uZGl0aW9ucyIsImdlblRlcm5hcnlFeHAiLCJhbHRIZWxwZXIiLCJnZW5EaXJlY3RpdmVzIiwiZ2VuUHJvcHMiLCJnZW5TY29wZWRTbG90cyIsImdlbklubGluZVRlbXBsYXRlIiwiaGFzUnVudGltZSIsIm5lZWRSdW50aW1lIiwiZ2VuIiwiaW5saW5lUmVuZGVyRm5zIiwiY29udGFpbnNTbG90Q2hpbGQiLCJuZWVkc0tleSIsImdlbmVyYXRlZFNsb3RzIiwiZ2VuU2NvcGVkU2xvdCIsImlzTGVnYWN5U3ludGF4IiwicmV2ZXJzZVByb3h5IiwiY2hlY2tTa2lwIiwiYWx0R2VuRWxlbWVudCIsImFsdEdlbk5vZGUiLCJlbCQxIiwibm9ybWFsaXphdGlvblR5cGUkMSIsImdldE5vcm1hbGl6YXRpb25UeXBlIiwiZ2VuTm9kZSIsIm5lZWRzTm9ybWFsaXphdGlvbiIsImdlbkNvbW1lbnQiLCJnZW5UZXh0IiwidHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzIiwiYmluZCQkMSIsImNvbXBvbmVudE5hbWUiLCJzdGF0aWNQcm9wcyIsImR5bmFtaWNQcm9wcyIsInByb2hpYml0ZWRLZXl3b3JkUkUiLCJ1bmFyeU9wZXJhdG9yc1JFIiwic3RyaXBTdHJpbmdSRSIsImRldGVjdEVycm9ycyIsImNoZWNrTm9kZSIsImNoZWNrRm9yIiwiY2hlY2tFdmVudCIsImNoZWNrRXhwcmVzc2lvbiIsInN0aXBwZWQiLCJrZXl3b3JkTWF0Y2giLCJjaGVja0lkZW50aWZpZXIiLCJpZGVudCIsImdlbmVyYXRlQ29kZUZyYW1lIiwibGluZXMiLCJjb3VudCIsInJlcGVhdCQxIiwibGluZUxlbmd0aCIsInBhZCIsImxlbmd0aCQxIiwibWluIiwiY3JlYXRlRnVuY3Rpb24iLCJlcnJvcnMiLCJjcmVhdGVDb21waWxlVG9GdW5jdGlvbkZuIiwiY29tcGlsZSIsImNvbXBpbGVUb0Z1bmN0aW9ucyIsIndhcm4kJDEiLCJjb21waWxlZCIsInRpcHMiLCJmbkdlbkVycm9ycyIsImNyZWF0ZUNvbXBpbGVyQ3JlYXRvciIsImJhc2VDb21waWxlIiwiY3JlYXRlQ29tcGlsZXIiLCJmaW5hbE9wdGlvbnMiLCJsZWFkaW5nU3BhY2VMZW5ndGgiLCJkaXYiLCJnZXRTaG91bGREZWNvZGUiLCJocmVmIiwiaWRUb1RlbXBsYXRlIiwibW91bnQiLCJkb2N1bWVudEVsZW1lbnQiLCJnZXRPdXRlckhUTUwiLCJvdXRlckhUTUwiLCJjb250YWluZXIiXSwibWFwcGluZ3MiOiI7O0FBQUE7Ozs7O0FBS0MsV0FBVUEsTUFBVixFQUFrQkMsT0FBbEIsRUFBMkI7QUFDMUIsZ0NBQU9DLE9BQVAsT0FBbUIsUUFBbkIsSUFBK0IsT0FBT0MsTUFBUCxLQUFrQixXQUFqRCxHQUErREEsTUFBTSxDQUFD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QUF2QixDQUFoQjtBQUNBMGxDLGVBQVMsQ0FBQzF3QixXQUFWLENBQXNCM21CLEVBQUUsQ0FBQ2dpQyxTQUFILENBQWEsSUFBYixDQUF0QjtBQUNBLGFBQU9xVixTQUFTLENBQUN0ckIsU0FBakI7QUFDRDtBQUNGOztBQUVEN1YsS0FBRyxDQUFDZ2dDLE9BQUosR0FBY0Msa0JBQWQ7QUFFQSxTQUFPamdDLEdBQVA7QUFFRCxDQWxxWEEsQ0FBRCxDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3Z1ZS9kaXN0L3Z1ZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVnVlLmpzIHYyLjYuMTBcbiAqIChjKSAyMDE0LTIwMTkgRXZhbiBZb3VcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5WdWUgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCBmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICAvKiAgKi9cblxuICB2YXIgZW1wdHlPYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcblxuICAvLyBUaGVzZSBoZWxwZXJzIHByb2R1Y2UgYmV0dGVyIFZNIGNvZGUgaW4gSlMgZW5naW5lcyBkdWUgdG8gdGhlaXJcbiAgLy8gZXhwbGljaXRuZXNzIGFuZCBmdW5jdGlvbiBpbmxpbmluZy5cbiAgZnVuY3Rpb24gaXNVbmRlZiAodikge1xuICAgIHJldHVybiB2ID09PSB1bmRlZmluZWQgfHwgdiA9PT0gbnVsbFxuICB9XG5cbiAgZnVuY3Rpb24gaXNEZWYgKHYpIHtcbiAgICByZXR1cm4gdiAhPT0gdW5kZWZpbmVkICYmIHYgIT09IG51bGxcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVHJ1ZSAodikge1xuICAgIHJldHVybiB2ID09PSB0cnVlXG4gIH1cblxuICBmdW5jdGlvbiBpc0ZhbHNlICh2KSB7XG4gICAgcmV0dXJuIHYgPT09IGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgdmFsdWUgaXMgcHJpbWl0aXZlLlxuICAgKi9cbiAgZnVuY3Rpb24gaXNQcmltaXRpdmUgKHZhbHVlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHxcbiAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgdHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJyB8fFxuICAgICAgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbidcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogUXVpY2sgb2JqZWN0IGNoZWNrIC0gdGhpcyBpcyBwcmltYXJpbHkgdXNlZCB0byB0ZWxsXG4gICAqIE9iamVjdHMgZnJvbSBwcmltaXRpdmUgdmFsdWVzIHdoZW4gd2Uga25vdyB0aGUgdmFsdWVcbiAgICogaXMgYSBKU09OLWNvbXBsaWFudCB0eXBlLlxuICAgKi9cbiAgZnVuY3Rpb24gaXNPYmplY3QgKG9iaikge1xuICAgIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCdcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHJhdyB0eXBlIHN0cmluZyBvZiBhIHZhbHVlLCBlLmcuLCBbb2JqZWN0IE9iamVjdF0uXG4gICAqL1xuICB2YXIgX3RvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuICBmdW5jdGlvbiB0b1Jhd1R5cGUgKHZhbHVlKSB7XG4gICAgcmV0dXJuIF90b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTdHJpY3Qgb2JqZWN0IHR5cGUgY2hlY2suIE9ubHkgcmV0dXJucyB0cnVlXG4gICAqIGZvciBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdHMuXG4gICAqL1xuICBmdW5jdGlvbiBpc1BsYWluT2JqZWN0IChvYmopIHtcbiAgICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSdcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUmVnRXhwICh2KSB7XG4gICAgcmV0dXJuIF90b1N0cmluZy5jYWxsKHYpID09PSAnW29iamVjdCBSZWdFeHBdJ1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHZhbCBpcyBhIHZhbGlkIGFycmF5IGluZGV4LlxuICAgKi9cbiAgZnVuY3Rpb24gaXNWYWxpZEFycmF5SW5kZXggKHZhbCkge1xuICAgIHZhciBuID0gcGFyc2VGbG9hdChTdHJpbmcodmFsKSk7XG4gICAgcmV0dXJuIG4gPj0gMCAmJiBNYXRoLmZsb29yKG4pID09PSBuICYmIGlzRmluaXRlKHZhbClcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUHJvbWlzZSAodmFsKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGlzRGVmKHZhbCkgJiZcbiAgICAgIHR5cGVvZiB2YWwudGhlbiA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgdHlwZW9mIHZhbC5jYXRjaCA9PT0gJ2Z1bmN0aW9uJ1xuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgdmFsdWUgdG8gYSBzdHJpbmcgdGhhdCBpcyBhY3R1YWxseSByZW5kZXJlZC5cbiAgICovXG4gIGZ1bmN0aW9uIHRvU3RyaW5nICh2YWwpIHtcbiAgICByZXR1cm4gdmFsID09IG51bGxcbiAgICAgID8gJydcbiAgICAgIDogQXJyYXkuaXNBcnJheSh2YWwpIHx8IChpc1BsYWluT2JqZWN0KHZhbCkgJiYgdmFsLnRvU3RyaW5nID09PSBfdG9TdHJpbmcpXG4gICAgICAgID8gSlNPTi5zdHJpbmdpZnkodmFsLCBudWxsLCAyKVxuICAgICAgICA6IFN0cmluZyh2YWwpXG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBhbiBpbnB1dCB2YWx1ZSB0byBhIG51bWJlciBmb3IgcGVyc2lzdGVuY2UuXG4gICAqIElmIHRoZSBjb252ZXJzaW9uIGZhaWxzLCByZXR1cm4gb3JpZ2luYWwgc3RyaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gdG9OdW1iZXIgKHZhbCkge1xuICAgIHZhciBuID0gcGFyc2VGbG9hdCh2YWwpO1xuICAgIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG5cbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIGEgbWFwIGFuZCByZXR1cm4gYSBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYSBrZXlcbiAgICogaXMgaW4gdGhhdCBtYXAuXG4gICAqL1xuICBmdW5jdGlvbiBtYWtlTWFwIChcbiAgICBzdHIsXG4gICAgZXhwZWN0c0xvd2VyQ2FzZVxuICApIHtcbiAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgbGlzdCA9IHN0ci5zcGxpdCgnLCcpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgbWFwW2xpc3RbaV1dID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGV4cGVjdHNMb3dlckNhc2VcbiAgICAgID8gZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbC50b0xvd2VyQ2FzZSgpXTsgfVxuICAgICAgOiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsXTsgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIGEgYnVpbHQtaW4gdGFnLlxuICAgKi9cbiAgdmFyIGlzQnVpbHRJblRhZyA9IG1ha2VNYXAoJ3Nsb3QsY29tcG9uZW50JywgdHJ1ZSk7XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZS5cbiAgICovXG4gIHZhciBpc1Jlc2VydmVkQXR0cmlidXRlID0gbWFrZU1hcCgna2V5LHJlZixzbG90LHNsb3Qtc2NvcGUsaXMnKTtcblxuICAvKipcbiAgICogUmVtb3ZlIGFuIGl0ZW0gZnJvbSBhbiBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIHJlbW92ZSAoYXJyLCBpdGVtKSB7XG4gICAgaWYgKGFyci5sZW5ndGgpIHtcbiAgICAgIHZhciBpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xuICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIGFyci5zcGxpY2UoaW5kZXgsIDEpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyB0aGUgcHJvcGVydHkuXG4gICAqL1xuICB2YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICBmdW5jdGlvbiBoYXNPd24gKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgY2FjaGVkIHZlcnNpb24gb2YgYSBwdXJlIGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gY2FjaGVkIChmbikge1xuICAgIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgcmV0dXJuIChmdW5jdGlvbiBjYWNoZWRGbiAoc3RyKSB7XG4gICAgICB2YXIgaGl0ID0gY2FjaGVbc3RyXTtcbiAgICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQ2FtZWxpemUgYSBoeXBoZW4tZGVsaW1pdGVkIHN0cmluZy5cbiAgICovXG4gIHZhciBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xuICB2YXIgY2FtZWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCBmdW5jdGlvbiAoXywgYykgeyByZXR1cm4gYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnOyB9KVxuICB9KTtcblxuICAvKipcbiAgICogQ2FwaXRhbGl6ZSBhIHN0cmluZy5cbiAgICovXG4gIHZhciBjYXBpdGFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBIeXBoZW5hdGUgYSBjYW1lbENhc2Ugc3RyaW5nLlxuICAgKi9cbiAgdmFyIGh5cGhlbmF0ZVJFID0gL1xcQihbQS1aXSkvZztcbiAgdmFyIGh5cGhlbmF0ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnLSQxJykudG9Mb3dlckNhc2UoKVxuICB9KTtcblxuICAvKipcbiAgICogU2ltcGxlIGJpbmQgcG9seWZpbGwgZm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBzdXBwb3J0IGl0LFxuICAgKiBlLmcuLCBQaGFudG9tSlMgMS54LiBUZWNobmljYWxseSwgd2UgZG9uJ3QgbmVlZCB0aGlzIGFueW1vcmVcbiAgICogc2luY2UgbmF0aXZlIGJpbmQgaXMgbm93IHBlcmZvcm1hbnQgZW5vdWdoIGluIG1vc3QgYnJvd3NlcnMuXG4gICAqIEJ1dCByZW1vdmluZyBpdCB3b3VsZCBtZWFuIGJyZWFraW5nIGNvZGUgdGhhdCB3YXMgYWJsZSB0byBydW4gaW5cbiAgICogUGhhbnRvbUpTIDEueCwgc28gdGhpcyBtdXN0IGJlIGtlcHQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXG4gICAqL1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGZ1bmN0aW9uIHBvbHlmaWxsQmluZCAoZm4sIGN0eCkge1xuICAgIGZ1bmN0aW9uIGJvdW5kRm4gKGEpIHtcbiAgICAgIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHJldHVybiBsXG4gICAgICAgID8gbCA+IDFcbiAgICAgICAgICA/IGZuLmFwcGx5KGN0eCwgYXJndW1lbnRzKVxuICAgICAgICAgIDogZm4uY2FsbChjdHgsIGEpXG4gICAgICAgIDogZm4uY2FsbChjdHgpXG4gICAgfVxuXG4gICAgYm91bmRGbi5fbGVuZ3RoID0gZm4ubGVuZ3RoO1xuICAgIHJldHVybiBib3VuZEZuXG4gIH1cblxuICBmdW5jdGlvbiBuYXRpdmVCaW5kIChmbiwgY3R4KSB7XG4gICAgcmV0dXJuIGZuLmJpbmQoY3R4KVxuICB9XG5cbiAgdmFyIGJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuICAgID8gbmF0aXZlQmluZFxuICAgIDogcG9seWZpbGxCaW5kO1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGFuIEFycmF5LWxpa2Ugb2JqZWN0IHRvIGEgcmVhbCBBcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIHRvQXJyYXkgKGxpc3QsIHN0YXJ0KSB7XG4gICAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICAgIHZhciBpID0gbGlzdC5sZW5ndGggLSBzdGFydDtcbiAgICB2YXIgcmV0ID0gbmV3IEFycmF5KGkpO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHJldFtpXSA9IGxpc3RbaSArIHN0YXJ0XTtcbiAgICB9XG4gICAgcmV0dXJuIHJldFxuICB9XG5cbiAgLyoqXG4gICAqIE1peCBwcm9wZXJ0aWVzIGludG8gdGFyZ2V0IG9iamVjdC5cbiAgICovXG4gIGZ1bmN0aW9uIGV4dGVuZCAodG8sIF9mcm9tKSB7XG4gICAgZm9yICh2YXIga2V5IGluIF9mcm9tKSB7XG4gICAgICB0b1trZXldID0gX2Zyb21ba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHRvXG4gIH1cblxuICAvKipcbiAgICogTWVyZ2UgYW4gQXJyYXkgb2YgT2JqZWN0cyBpbnRvIGEgc2luZ2xlIE9iamVjdC5cbiAgICovXG4gIGZ1bmN0aW9uIHRvT2JqZWN0IChhcnIpIHtcbiAgICB2YXIgcmVzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhcnJbaV0pIHtcbiAgICAgICAgZXh0ZW5kKHJlcywgYXJyW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuICAvKipcbiAgICogUGVyZm9ybSBubyBvcGVyYXRpb24uXG4gICAqIFN0dWJiaW5nIGFyZ3MgdG8gbWFrZSBGbG93IGhhcHB5IHdpdGhvdXQgbGVhdmluZyB1c2VsZXNzIHRyYW5zcGlsZWQgY29kZVxuICAgKiB3aXRoIC4uLnJlc3QgKGh0dHBzOi8vZmxvdy5vcmcvYmxvZy8yMDE3LzA1LzA3L1N0cmljdC1GdW5jdGlvbi1DYWxsLUFyaXR5LykuXG4gICAqL1xuICBmdW5jdGlvbiBub29wIChhLCBiLCBjKSB7fVxuXG4gIC8qKlxuICAgKiBBbHdheXMgcmV0dXJuIGZhbHNlLlxuICAgKi9cbiAgdmFyIG5vID0gZnVuY3Rpb24gKGEsIGIsIGMpIHsgcmV0dXJuIGZhbHNlOyB9O1xuXG4gIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBzYW1lIHZhbHVlLlxuICAgKi9cbiAgdmFyIGlkZW50aXR5ID0gZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH07XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgc3RyaW5nIGNvbnRhaW5pbmcgc3RhdGljIGtleXMgZnJvbSBjb21waWxlciBtb2R1bGVzLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2VuU3RhdGljS2V5cyAobW9kdWxlcykge1xuICAgIHJldHVybiBtb2R1bGVzLnJlZHVjZShmdW5jdGlvbiAoa2V5cywgbSkge1xuICAgICAgcmV0dXJuIGtleXMuY29uY2F0KG0uc3RhdGljS2V5cyB8fCBbXSlcbiAgICB9LCBbXSkuam9pbignLCcpXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgdHdvIHZhbHVlcyBhcmUgbG9vc2VseSBlcXVhbCAtIHRoYXQgaXMsXG4gICAqIGlmIHRoZXkgYXJlIHBsYWluIG9iamVjdHMsIGRvIHRoZXkgaGF2ZSB0aGUgc2FtZSBzaGFwZT9cbiAgICovXG4gIGZ1bmN0aW9uIGxvb3NlRXF1YWwgKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gYikgeyByZXR1cm4gdHJ1ZSB9XG4gICAgdmFyIGlzT2JqZWN0QSA9IGlzT2JqZWN0KGEpO1xuICAgIHZhciBpc09iamVjdEIgPSBpc09iamVjdChiKTtcbiAgICBpZiAoaXNPYmplY3RBICYmIGlzT2JqZWN0Qikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGlzQXJyYXlBID0gQXJyYXkuaXNBcnJheShhKTtcbiAgICAgICAgdmFyIGlzQXJyYXlCID0gQXJyYXkuaXNBcnJheShiKTtcbiAgICAgICAgaWYgKGlzQXJyYXlBICYmIGlzQXJyYXlCKSB7XG4gICAgICAgICAgcmV0dXJuIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9vc2VFcXVhbChlLCBiW2ldKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSBpZiAoYSBpbnN0YW5jZW9mIERhdGUgJiYgYiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICByZXR1cm4gYS5nZXRUaW1lKCkgPT09IGIuZ2V0VGltZSgpXG4gICAgICAgIH0gZWxzZSBpZiAoIWlzQXJyYXlBICYmICFpc0FycmF5Qikge1xuICAgICAgICAgIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKGEpO1xuICAgICAgICAgIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKGIpO1xuICAgICAgICAgIHJldHVybiBrZXlzQS5sZW5ndGggPT09IGtleXNCLmxlbmd0aCAmJiBrZXlzQS5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gbG9vc2VFcXVhbChhW2tleV0sIGJba2V5XSlcbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaXNPYmplY3RBICYmICFpc09iamVjdEIpIHtcbiAgICAgIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBmaXJzdCBpbmRleCBhdCB3aGljaCBhIGxvb3NlbHkgZXF1YWwgdmFsdWUgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBhcnJheSAoaWYgdmFsdWUgaXMgYSBwbGFpbiBvYmplY3QsIHRoZSBhcnJheSBtdXN0XG4gICAqIGNvbnRhaW4gYW4gb2JqZWN0IG9mIHRoZSBzYW1lIHNoYXBlKSwgb3IgLTEgaWYgaXQgaXMgbm90IHByZXNlbnQuXG4gICAqL1xuICBmdW5jdGlvbiBsb29zZUluZGV4T2YgKGFyciwgdmFsKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChsb29zZUVxdWFsKGFycltpXSwgdmFsKSkgeyByZXR1cm4gaSB9XG4gICAgfVxuICAgIHJldHVybiAtMVxuICB9XG5cbiAgLyoqXG4gICAqIEVuc3VyZSBhIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmx5IG9uY2UuXG4gICAqL1xuICBmdW5jdGlvbiBvbmNlIChmbikge1xuICAgIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgU1NSX0FUVFIgPSAnZGF0YS1zZXJ2ZXItcmVuZGVyZWQnO1xuXG4gIHZhciBBU1NFVF9UWVBFUyA9IFtcbiAgICAnY29tcG9uZW50JyxcbiAgICAnZGlyZWN0aXZlJyxcbiAgICAnZmlsdGVyJ1xuICBdO1xuXG4gIHZhciBMSUZFQ1lDTEVfSE9PS1MgPSBbXG4gICAgJ2JlZm9yZUNyZWF0ZScsXG4gICAgJ2NyZWF0ZWQnLFxuICAgICdiZWZvcmVNb3VudCcsXG4gICAgJ21vdW50ZWQnLFxuICAgICdiZWZvcmVVcGRhdGUnLFxuICAgICd1cGRhdGVkJyxcbiAgICAnYmVmb3JlRGVzdHJveScsXG4gICAgJ2Rlc3Ryb3llZCcsXG4gICAgJ2FjdGl2YXRlZCcsXG4gICAgJ2RlYWN0aXZhdGVkJyxcbiAgICAnZXJyb3JDYXB0dXJlZCcsXG4gICAgJ3NlcnZlclByZWZldGNoJ1xuICBdO1xuXG4gIC8qICAqL1xuXG5cblxuICB2YXIgY29uZmlnID0gKHtcbiAgICAvKipcbiAgICAgKiBPcHRpb24gbWVyZ2Ugc3RyYXRlZ2llcyAodXNlZCBpbiBjb3JlL3V0aWwvb3B0aW9ucylcbiAgICAgKi9cbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICBvcHRpb25NZXJnZVN0cmF0ZWdpZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIHN1cHByZXNzIHdhcm5pbmdzLlxuICAgICAqL1xuICAgIHNpbGVudDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBTaG93IHByb2R1Y3Rpb24gbW9kZSB0aXAgbWVzc2FnZSBvbiBib290P1xuICAgICAqL1xuICAgIHByb2R1Y3Rpb25UaXA6IFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBlbmFibGUgZGV2dG9vbHNcbiAgICAgKi9cbiAgICBkZXZ0b29sczogXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicsXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIHJlY29yZCBwZXJmXG4gICAgICovXG4gICAgcGVyZm9ybWFuY2U6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogRXJyb3IgaGFuZGxlciBmb3Igd2F0Y2hlciBlcnJvcnNcbiAgICAgKi9cbiAgICBlcnJvckhhbmRsZXI6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBXYXJuIGhhbmRsZXIgZm9yIHdhdGNoZXIgd2FybnNcbiAgICAgKi9cbiAgICB3YXJuSGFuZGxlcjogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIElnbm9yZSBjZXJ0YWluIGN1c3RvbSBlbGVtZW50c1xuICAgICAqL1xuICAgIGlnbm9yZWRFbGVtZW50czogW10sXG5cbiAgICAvKipcbiAgICAgKiBDdXN0b20gdXNlciBrZXkgYWxpYXNlcyBmb3Igdi1vblxuICAgICAqL1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIGtleUNvZGVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSB0YWcgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgcmVnaXN0ZXJlZCBhcyBhXG4gICAgICogY29tcG9uZW50LiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuICAgICAqL1xuICAgIGlzUmVzZXJ2ZWRUYWc6IG5vLFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHVzZWQgYXMgYSBjb21wb25lbnRcbiAgICAgKiBwcm9wLiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuICAgICAqL1xuICAgIGlzUmVzZXJ2ZWRBdHRyOiBubyxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgdGFnIGlzIGFuIHVua25vd24gZWxlbWVudC5cbiAgICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAgICovXG4gICAgaXNVbmtub3duRWxlbWVudDogbm8sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG5hbWVzcGFjZSBvZiBhbiBlbGVtZW50XG4gICAgICovXG4gICAgZ2V0VGFnTmFtZXNwYWNlOiBub29wLFxuXG4gICAgLyoqXG4gICAgICogUGFyc2UgdGhlIHJlYWwgdGFnIG5hbWUgZm9yIHRoZSBzcGVjaWZpYyBwbGF0Zm9ybS5cbiAgICAgKi9cbiAgICBwYXJzZVBsYXRmb3JtVGFnTmFtZTogaWRlbnRpdHksXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgbXVzdCBiZSBib3VuZCB1c2luZyBwcm9wZXJ0eSwgZS5nLiB2YWx1ZVxuICAgICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICAgKi9cbiAgICBtdXN0VXNlUHJvcDogbm8sXG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIHVwZGF0ZXMgYXN5bmNocm9ub3VzbHkuIEludGVuZGVkIHRvIGJlIHVzZWQgYnkgVnVlIFRlc3QgVXRpbHNcbiAgICAgKiBUaGlzIHdpbGwgc2lnbmlmaWNhbnRseSByZWR1Y2UgcGVyZm9ybWFuY2UgaWYgc2V0IHRvIGZhbHNlLlxuICAgICAqL1xuICAgIGFzeW5jOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogRXhwb3NlZCBmb3IgbGVnYWN5IHJlYXNvbnNcbiAgICAgKi9cbiAgICBfbGlmZWN5Y2xlSG9va3M6IExJRkVDWUNMRV9IT09LU1xuICB9KTtcblxuICAvKiAgKi9cblxuICAvKipcbiAgICogdW5pY29kZSBsZXR0ZXJzIHVzZWQgZm9yIHBhcnNpbmcgaHRtbCB0YWdzLCBjb21wb25lbnQgbmFtZXMgYW5kIHByb3BlcnR5IHBhdGhzLlxuICAgKiB1c2luZyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUzL3NlbWFudGljcy1zY3JpcHRpbmcuaHRtbCNwb3RlbnRpYWxjdXN0b21lbGVtZW50bmFtZVxuICAgKiBza2lwcGluZyBcXHUxMDAwMC1cXHVFRkZGRiBkdWUgdG8gaXQgZnJlZXppbmcgdXAgUGhhbnRvbUpTXG4gICAqL1xuICB2YXIgdW5pY29kZVJlZ0V4cCA9IC9hLXpBLVpcXHUwMEI3XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjAzRi1cXHUyMDQwXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZELztcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBzdHJpbmcgc3RhcnRzIHdpdGggJCBvciBfXG4gICAqL1xuICBmdW5jdGlvbiBpc1Jlc2VydmVkIChzdHIpIHtcbiAgICB2YXIgYyA9IChzdHIgKyAnJykuY2hhckNvZGVBdCgwKTtcbiAgICByZXR1cm4gYyA9PT0gMHgyNCB8fCBjID09PSAweDVGXG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lIGEgcHJvcGVydHkuXG4gICAqL1xuICBmdW5jdGlvbiBkZWYgKG9iaiwga2V5LCB2YWwsIGVudW1lcmFibGUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWwsXG4gICAgICBlbnVtZXJhYmxlOiAhIWVudW1lcmFibGUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIHNpbXBsZSBwYXRoLlxuICAgKi9cbiAgdmFyIGJhaWxSRSA9IG5ldyBSZWdFeHAoKFwiW15cIiArICh1bmljb2RlUmVnRXhwLnNvdXJjZSkgKyBcIi4kX1xcXFxkXVwiKSk7XG4gIGZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xuICAgIGlmIChiYWlsUkUudGVzdChwYXRoKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIW9iaikgeyByZXR1cm4gfVxuICAgICAgICBvYmogPSBvYmpbc2VnbWVudHNbaV1dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9ialxuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIC8vIGNhbiB3ZSB1c2UgX19wcm90b19fP1xuICB2YXIgaGFzUHJvdG8gPSAnX19wcm90b19fJyBpbiB7fTtcblxuICAvLyBCcm93c2VyIGVudmlyb25tZW50IHNuaWZmaW5nXG4gIHZhciBpbkJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbiAgdmFyIGluV2VleCA9IHR5cGVvZiBXWEVudmlyb25tZW50ICE9PSAndW5kZWZpbmVkJyAmJiAhIVdYRW52aXJvbm1lbnQucGxhdGZvcm07XG4gIHZhciB3ZWV4UGxhdGZvcm0gPSBpbldlZXggJiYgV1hFbnZpcm9ubWVudC5wbGF0Zm9ybS50b0xvd2VyQ2FzZSgpO1xuICB2YXIgVUEgPSBpbkJyb3dzZXIgJiYgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbiAgdmFyIGlzSUUgPSBVQSAmJiAvbXNpZXx0cmlkZW50Ly50ZXN0KFVBKTtcbiAgdmFyIGlzSUU5ID0gVUEgJiYgVUEuaW5kZXhPZignbXNpZSA5LjAnKSA+IDA7XG4gIHZhciBpc0VkZ2UgPSBVQSAmJiBVQS5pbmRleE9mKCdlZGdlLycpID4gMDtcbiAgdmFyIGlzQW5kcm9pZCA9IChVQSAmJiBVQS5pbmRleE9mKCdhbmRyb2lkJykgPiAwKSB8fCAod2VleFBsYXRmb3JtID09PSAnYW5kcm9pZCcpO1xuICB2YXIgaXNJT1MgPSAoVUEgJiYgL2lwaG9uZXxpcGFkfGlwb2R8aW9zLy50ZXN0KFVBKSkgfHwgKHdlZXhQbGF0Zm9ybSA9PT0gJ2lvcycpO1xuICB2YXIgaXNDaHJvbWUgPSBVQSAmJiAvY2hyb21lXFwvXFxkKy8udGVzdChVQSkgJiYgIWlzRWRnZTtcbiAgdmFyIGlzUGhhbnRvbUpTID0gVUEgJiYgL3BoYW50b21qcy8udGVzdChVQSk7XG4gIHZhciBpc0ZGID0gVUEgJiYgVUEubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKTtcblxuICAvLyBGaXJlZm94IGhhcyBhIFwid2F0Y2hcIiBmdW5jdGlvbiBvbiBPYmplY3QucHJvdG90eXBlLi4uXG4gIHZhciBuYXRpdmVXYXRjaCA9ICh7fSkud2F0Y2g7XG5cbiAgdmFyIHN1cHBvcnRzUGFzc2l2ZSA9IGZhbHNlO1xuICBpZiAoaW5Ccm93c2VyKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBvcHRzID0ge307XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3B0cywgJ3Bhc3NpdmUnLCAoe1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KSk7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8yODVcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0LXBhc3NpdmUnLCBudWxsLCBvcHRzKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG5cbiAgLy8gdGhpcyBuZWVkcyB0byBiZSBsYXp5LWV2YWxlZCBiZWNhdXNlIHZ1ZSBtYXkgYmUgcmVxdWlyZWQgYmVmb3JlXG4gIC8vIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgY2FuIHNldCBWVUVfRU5WXG4gIHZhciBfaXNTZXJ2ZXI7XG4gIHZhciBpc1NlcnZlclJlbmRlcmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoX2lzU2VydmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCFpbkJyb3dzZXIgJiYgIWluV2VleCAmJiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBkZXRlY3QgcHJlc2VuY2Ugb2YgdnVlLXNlcnZlci1yZW5kZXJlciBhbmQgYXZvaWRcbiAgICAgICAgLy8gV2VicGFjayBzaGltbWluZyB0aGUgcHJvY2Vzc1xuICAgICAgICBfaXNTZXJ2ZXIgPSBnbG9iYWxbJ3Byb2Nlc3MnXSAmJiBnbG9iYWxbJ3Byb2Nlc3MnXS5lbnYuVlVFX0VOViA9PT0gJ3NlcnZlcic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfaXNTZXJ2ZXIgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIF9pc1NlcnZlclxuICB9O1xuXG4gIC8vIGRldGVjdCBkZXZ0b29sc1xuICB2YXIgZGV2dG9vbHMgPSBpbkJyb3dzZXIgJiYgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZnVuY3Rpb24gaXNOYXRpdmUgKEN0b3IpIHtcbiAgICByZXR1cm4gdHlwZW9mIEN0b3IgPT09ICdmdW5jdGlvbicgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KEN0b3IudG9TdHJpbmcoKSlcbiAgfVxuXG4gIHZhciBoYXNTeW1ib2wgPVxuICAgIHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFN5bWJvbCkgJiZcbiAgICB0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUmVmbGVjdC5vd25LZXlzKTtcblxuICB2YXIgX1NldDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBpZiAodHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU2V0KSkge1xuICAgIC8vIHVzZSBuYXRpdmUgU2V0IHdoZW4gYXZhaWxhYmxlLlxuICAgIF9TZXQgPSBTZXQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gYSBub24tc3RhbmRhcmQgU2V0IHBvbHlmaWxsIHRoYXQgb25seSB3b3JrcyB3aXRoIHByaW1pdGl2ZSBrZXlzLlxuICAgIF9TZXQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFNldCAoKSB7XG4gICAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIH1cbiAgICAgIFNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gaGFzIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0W2tleV0gPT09IHRydWVcbiAgICAgIH07XG4gICAgICBTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoa2V5KSB7XG4gICAgICAgIHRoaXMuc2V0W2tleV0gPSB0cnVlO1xuICAgICAgfTtcbiAgICAgIFNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBTZXQ7XG4gICAgfSgpKTtcbiAgfVxuXG4gIC8qICAqL1xuXG4gIHZhciB3YXJuID0gbm9vcDtcbiAgdmFyIHRpcCA9IG5vb3A7XG4gIHZhciBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gKG5vb3ApOyAvLyB3b3JrIGFyb3VuZCBmbG93IGNoZWNrXG4gIHZhciBmb3JtYXRDb21wb25lbnROYW1lID0gKG5vb3ApO1xuXG4gIHtcbiAgICB2YXIgaGFzQ29uc29sZSA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJztcbiAgICB2YXIgY2xhc3NpZnlSRSA9IC8oPzpefFstX10pKFxcdykvZztcbiAgICB2YXIgY2xhc3NpZnkgPSBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBzdHJcbiAgICAgIC5yZXBsYWNlKGNsYXNzaWZ5UkUsIGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRvVXBwZXJDYXNlKCk7IH0pXG4gICAgICAucmVwbGFjZSgvWy1fXS9nLCAnJyk7IH07XG5cbiAgICB3YXJuID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcbiAgICAgIHZhciB0cmFjZSA9IHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJztcblxuICAgICAgaWYgKGNvbmZpZy53YXJuSGFuZGxlcikge1xuICAgICAgICBjb25maWcud2FybkhhbmRsZXIuY2FsbChudWxsLCBtc2csIHZtLCB0cmFjZSk7XG4gICAgICB9IGVsc2UgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKChcIltWdWUgd2Fybl06IFwiICsgbXNnICsgdHJhY2UpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGlwID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcbiAgICAgIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiW1Z1ZSB0aXBdOiBcIiArIG1zZyArIChcbiAgICAgICAgICB2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJydcbiAgICAgICAgKSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvcm1hdENvbXBvbmVudE5hbWUgPSBmdW5jdGlvbiAodm0sIGluY2x1ZGVGaWxlKSB7XG4gICAgICBpZiAodm0uJHJvb3QgPT09IHZtKSB7XG4gICAgICAgIHJldHVybiAnPFJvb3Q+J1xuICAgICAgfVxuICAgICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygdm0gPT09ICdmdW5jdGlvbicgJiYgdm0uY2lkICE9IG51bGxcbiAgICAgICAgPyB2bS5vcHRpb25zXG4gICAgICAgIDogdm0uX2lzVnVlXG4gICAgICAgICAgPyB2bS4kb3B0aW9ucyB8fCB2bS5jb25zdHJ1Y3Rvci5vcHRpb25zXG4gICAgICAgICAgOiB2bTtcbiAgICAgIHZhciBuYW1lID0gb3B0aW9ucy5uYW1lIHx8IG9wdGlvbnMuX2NvbXBvbmVudFRhZztcbiAgICAgIHZhciBmaWxlID0gb3B0aW9ucy5fX2ZpbGU7XG4gICAgICBpZiAoIW5hbWUgJiYgZmlsZSkge1xuICAgICAgICB2YXIgbWF0Y2ggPSBmaWxlLm1hdGNoKC8oW14vXFxcXF0rKVxcLnZ1ZSQvKTtcbiAgICAgICAgbmFtZSA9IG1hdGNoICYmIG1hdGNoWzFdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gKFxuICAgICAgICAobmFtZSA/IChcIjxcIiArIChjbGFzc2lmeShuYW1lKSkgKyBcIj5cIikgOiBcIjxBbm9ueW1vdXM+XCIpICtcbiAgICAgICAgKGZpbGUgJiYgaW5jbHVkZUZpbGUgIT09IGZhbHNlID8gKFwiIGF0IFwiICsgZmlsZSkgOiAnJylcbiAgICAgIClcbiAgICB9O1xuXG4gICAgdmFyIHJlcGVhdCA9IGZ1bmN0aW9uIChzdHIsIG4pIHtcbiAgICAgIHZhciByZXMgPSAnJztcbiAgICAgIHdoaWxlIChuKSB7XG4gICAgICAgIGlmIChuICUgMiA9PT0gMSkgeyByZXMgKz0gc3RyOyB9XG4gICAgICAgIGlmIChuID4gMSkgeyBzdHIgKz0gc3RyOyB9XG4gICAgICAgIG4gPj49IDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzXG4gICAgfTtcblxuICAgIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSBmdW5jdGlvbiAodm0pIHtcbiAgICAgIGlmICh2bS5faXNWdWUgJiYgdm0uJHBhcmVudCkge1xuICAgICAgICB2YXIgdHJlZSA9IFtdO1xuICAgICAgICB2YXIgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcbiAgICAgICAgd2hpbGUgKHZtKSB7XG4gICAgICAgICAgaWYgKHRyZWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGxhc3QgPSB0cmVlW3RyZWUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAobGFzdC5jb25zdHJ1Y3RvciA9PT0gdm0uY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlKys7XG4gICAgICAgICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID4gMCkge1xuICAgICAgICAgICAgICB0cmVlW3RyZWUubGVuZ3RoIC0gMV0gPSBbbGFzdCwgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlXTtcbiAgICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdHJlZS5wdXNoKHZtKTtcbiAgICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdcXG5cXG5mb3VuZCBpblxcblxcbicgKyB0cmVlXG4gICAgICAgICAgLm1hcChmdW5jdGlvbiAodm0sIGkpIHsgcmV0dXJuIChcIlwiICsgKGkgPT09IDAgPyAnLS0tPiAnIDogcmVwZWF0KCcgJywgNSArIGkgKiAyKSkgKyAoQXJyYXkuaXNBcnJheSh2bSlcbiAgICAgICAgICAgICAgPyAoKGZvcm1hdENvbXBvbmVudE5hbWUodm1bMF0pKSArIFwiLi4uIChcIiArICh2bVsxXSkgKyBcIiByZWN1cnNpdmUgY2FsbHMpXCIpXG4gICAgICAgICAgICAgIDogZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpKTsgfSlcbiAgICAgICAgICAuam9pbignXFxuJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAoXCJcXG5cXG4oZm91bmQgaW4gXCIgKyAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCIpXCIpXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qICAqL1xuXG4gIHZhciB1aWQgPSAwO1xuXG4gIC8qKlxuICAgKiBBIGRlcCBpcyBhbiBvYnNlcnZhYmxlIHRoYXQgY2FuIGhhdmUgbXVsdGlwbGVcbiAgICogZGlyZWN0aXZlcyBzdWJzY3JpYmluZyB0byBpdC5cbiAgICovXG4gIHZhciBEZXAgPSBmdW5jdGlvbiBEZXAgKCkge1xuICAgIHRoaXMuaWQgPSB1aWQrKztcbiAgICB0aGlzLnN1YnMgPSBbXTtcbiAgfTtcblxuICBEZXAucHJvdG90eXBlLmFkZFN1YiA9IGZ1bmN0aW9uIGFkZFN1YiAoc3ViKSB7XG4gICAgdGhpcy5zdWJzLnB1c2goc3ViKTtcbiAgfTtcblxuICBEZXAucHJvdG90eXBlLnJlbW92ZVN1YiA9IGZ1bmN0aW9uIHJlbW92ZVN1YiAoc3ViKSB7XG4gICAgcmVtb3ZlKHRoaXMuc3Vicywgc3ViKTtcbiAgfTtcblxuICBEZXAucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgIERlcC50YXJnZXQuYWRkRGVwKHRoaXMpO1xuICAgIH1cbiAgfTtcblxuICBEZXAucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uIG5vdGlmeSAoKSB7XG4gICAgLy8gc3RhYmlsaXplIHRoZSBzdWJzY3JpYmVyIGxpc3QgZmlyc3RcbiAgICB2YXIgc3VicyA9IHRoaXMuc3Vicy5zbGljZSgpO1xuICAgIGlmICghY29uZmlnLmFzeW5jKSB7XG4gICAgICAvLyBzdWJzIGFyZW4ndCBzb3J0ZWQgaW4gc2NoZWR1bGVyIGlmIG5vdCBydW5uaW5nIGFzeW5jXG4gICAgICAvLyB3ZSBuZWVkIHRvIHNvcnQgdGhlbSBub3cgdG8gbWFrZSBzdXJlIHRoZXkgZmlyZSBpbiBjb3JyZWN0XG4gICAgICAvLyBvcmRlclxuICAgICAgc3Vicy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmlkIC0gYi5pZDsgfSk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gc3Vicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHN1YnNbaV0udXBkYXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cbiAgLy8gVGhpcyBpcyBnbG9iYWxseSB1bmlxdWUgYmVjYXVzZSBvbmx5IG9uZSB3YXRjaGVyXG4gIC8vIGNhbiBiZSBldmFsdWF0ZWQgYXQgYSB0aW1lLlxuICBEZXAudGFyZ2V0ID0gbnVsbDtcbiAgdmFyIHRhcmdldFN0YWNrID0gW107XG5cbiAgZnVuY3Rpb24gcHVzaFRhcmdldCAodGFyZ2V0KSB7XG4gICAgdGFyZ2V0U3RhY2sucHVzaCh0YXJnZXQpO1xuICAgIERlcC50YXJnZXQgPSB0YXJnZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBwb3BUYXJnZXQgKCkge1xuICAgIHRhcmdldFN0YWNrLnBvcCgpO1xuICAgIERlcC50YXJnZXQgPSB0YXJnZXRTdGFja1t0YXJnZXRTdGFjay5sZW5ndGggLSAxXTtcbiAgfVxuXG4gIC8qICAqL1xuXG4gIHZhciBWTm9kZSA9IGZ1bmN0aW9uIFZOb2RlIChcbiAgICB0YWcsXG4gICAgZGF0YSxcbiAgICBjaGlsZHJlbixcbiAgICB0ZXh0LFxuICAgIGVsbSxcbiAgICBjb250ZXh0LFxuICAgIGNvbXBvbmVudE9wdGlvbnMsXG4gICAgYXN5bmNGYWN0b3J5XG4gICkge1xuICAgIHRoaXMudGFnID0gdGFnO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgdGhpcy5lbG0gPSBlbG07XG4gICAgdGhpcy5ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMuZm5Db250ZXh0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZm5PcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZm5TY29wZUlkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMua2V5ID0gZGF0YSAmJiBkYXRhLmtleTtcbiAgICB0aGlzLmNvbXBvbmVudE9wdGlvbnMgPSBjb21wb25lbnRPcHRpb25zO1xuICAgIHRoaXMuY29tcG9uZW50SW5zdGFuY2UgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5yYXcgPSBmYWxzZTtcbiAgICB0aGlzLmlzU3RhdGljID0gZmFsc2U7XG4gICAgdGhpcy5pc1Jvb3RJbnNlcnQgPSB0cnVlO1xuICAgIHRoaXMuaXNDb21tZW50ID0gZmFsc2U7XG4gICAgdGhpcy5pc0Nsb25lZCA9IGZhbHNlO1xuICAgIHRoaXMuaXNPbmNlID0gZmFsc2U7XG4gICAgdGhpcy5hc3luY0ZhY3RvcnkgPSBhc3luY0ZhY3Rvcnk7XG4gICAgdGhpcy5hc3luY01ldGEgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pc0FzeW5jUGxhY2Vob2xkZXIgPSBmYWxzZTtcbiAgfTtcblxuICB2YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBjaGlsZDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4gIC8vIERFUFJFQ0FURUQ6IGFsaWFzIGZvciBjb21wb25lbnRJbnN0YW5jZSBmb3IgYmFja3dhcmRzIGNvbXBhdC5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcHJvdG90eXBlQWNjZXNzb3JzLmNoaWxkLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wb25lbnRJbnN0YW5jZVxuICB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBWTm9kZS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG4gIHZhciBjcmVhdGVFbXB0eVZOb2RlID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICBpZiAoIHRleHQgPT09IHZvaWQgMCApIHRleHQgPSAnJztcblxuICAgIHZhciBub2RlID0gbmV3IFZOb2RlKCk7XG4gICAgbm9kZS50ZXh0ID0gdGV4dDtcbiAgICBub2RlLmlzQ29tbWVudCA9IHRydWU7XG4gICAgcmV0dXJuIG5vZGVcbiAgfTtcblxuICBmdW5jdGlvbiBjcmVhdGVUZXh0Vk5vZGUgKHZhbCkge1xuICAgIHJldHVybiBuZXcgVk5vZGUodW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgU3RyaW5nKHZhbCkpXG4gIH1cblxuICAvLyBvcHRpbWl6ZWQgc2hhbGxvdyBjbG9uZVxuICAvLyB1c2VkIGZvciBzdGF0aWMgbm9kZXMgYW5kIHNsb3Qgbm9kZXMgYmVjYXVzZSB0aGV5IG1heSBiZSByZXVzZWQgYWNyb3NzXG4gIC8vIG11bHRpcGxlIHJlbmRlcnMsIGNsb25pbmcgdGhlbSBhdm9pZHMgZXJyb3JzIHdoZW4gRE9NIG1hbmlwdWxhdGlvbnMgcmVseVxuICAvLyBvbiB0aGVpciBlbG0gcmVmZXJlbmNlLlxuICBmdW5jdGlvbiBjbG9uZVZOb2RlICh2bm9kZSkge1xuICAgIHZhciBjbG9uZWQgPSBuZXcgVk5vZGUoXG4gICAgICB2bm9kZS50YWcsXG4gICAgICB2bm9kZS5kYXRhLFxuICAgICAgLy8gIzc5NzVcbiAgICAgIC8vIGNsb25lIGNoaWxkcmVuIGFycmF5IHRvIGF2b2lkIG11dGF0aW5nIG9yaWdpbmFsIGluIGNhc2Ugb2YgY2xvbmluZ1xuICAgICAgLy8gYSBjaGlsZC5cbiAgICAgIHZub2RlLmNoaWxkcmVuICYmIHZub2RlLmNoaWxkcmVuLnNsaWNlKCksXG4gICAgICB2bm9kZS50ZXh0LFxuICAgICAgdm5vZGUuZWxtLFxuICAgICAgdm5vZGUuY29udGV4dCxcbiAgICAgIHZub2RlLmNvbXBvbmVudE9wdGlvbnMsXG4gICAgICB2bm9kZS5hc3luY0ZhY3RvcnlcbiAgICApO1xuICAgIGNsb25lZC5ucyA9IHZub2RlLm5zO1xuICAgIGNsb25lZC5pc1N0YXRpYyA9IHZub2RlLmlzU3RhdGljO1xuICAgIGNsb25lZC5rZXkgPSB2bm9kZS5rZXk7XG4gICAgY2xvbmVkLmlzQ29tbWVudCA9IHZub2RlLmlzQ29tbWVudDtcbiAgICBjbG9uZWQuZm5Db250ZXh0ID0gdm5vZGUuZm5Db250ZXh0O1xuICAgIGNsb25lZC5mbk9wdGlvbnMgPSB2bm9kZS5mbk9wdGlvbnM7XG4gICAgY2xvbmVkLmZuU2NvcGVJZCA9IHZub2RlLmZuU2NvcGVJZDtcbiAgICBjbG9uZWQuYXN5bmNNZXRhID0gdm5vZGUuYXN5bmNNZXRhO1xuICAgIGNsb25lZC5pc0Nsb25lZCA9IHRydWU7XG4gICAgcmV0dXJuIGNsb25lZFxuICB9XG5cbiAgLypcbiAgICogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoXG4gICAqIGR5bmFtaWNhbGx5IGFjY2Vzc2luZyBtZXRob2RzIG9uIEFycmF5IHByb3RvdHlwZVxuICAgKi9cblxuICB2YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbiAgdmFyIGFycmF5TWV0aG9kcyA9IE9iamVjdC5jcmVhdGUoYXJyYXlQcm90byk7XG5cbiAgdmFyIG1ldGhvZHNUb1BhdGNoID0gW1xuICAgICdwdXNoJyxcbiAgICAncG9wJyxcbiAgICAnc2hpZnQnLFxuICAgICd1bnNoaWZ0JyxcbiAgICAnc3BsaWNlJyxcbiAgICAnc29ydCcsXG4gICAgJ3JldmVyc2UnXG4gIF07XG5cbiAgLyoqXG4gICAqIEludGVyY2VwdCBtdXRhdGluZyBtZXRob2RzIGFuZCBlbWl0IGV2ZW50c1xuICAgKi9cbiAgbWV0aG9kc1RvUGF0Y2guZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgLy8gY2FjaGUgb3JpZ2luYWwgbWV0aG9kXG4gICAgdmFyIG9yaWdpbmFsID0gYXJyYXlQcm90b1ttZXRob2RdO1xuICAgIGRlZihhcnJheU1ldGhvZHMsIG1ldGhvZCwgZnVuY3Rpb24gbXV0YXRvciAoKSB7XG4gICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgdmFyIHJlc3VsdCA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgdmFyIG9iID0gdGhpcy5fX29iX187XG4gICAgICB2YXIgaW5zZXJ0ZWQ7XG4gICAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgICBjYXNlICdwdXNoJzpcbiAgICAgICAgY2FzZSAndW5zaGlmdCc6XG4gICAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ3NwbGljZSc6XG4gICAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzLnNsaWNlKDIpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBpZiAoaW5zZXJ0ZWQpIHsgb2Iub2JzZXJ2ZUFycmF5KGluc2VydGVkKTsgfVxuICAgICAgLy8gbm90aWZ5IGNoYW5nZVxuICAgICAgb2IuZGVwLm5vdGlmeSgpO1xuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH0pO1xuICB9KTtcblxuICAvKiAgKi9cblxuICB2YXIgYXJyYXlLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJyYXlNZXRob2RzKTtcblxuICAvKipcbiAgICogSW4gc29tZSBjYXNlcyB3ZSBtYXkgd2FudCB0byBkaXNhYmxlIG9ic2VydmF0aW9uIGluc2lkZSBhIGNvbXBvbmVudCdzXG4gICAqIHVwZGF0ZSBjb21wdXRhdGlvbi5cbiAgICovXG4gIHZhciBzaG91bGRPYnNlcnZlID0gdHJ1ZTtcblxuICBmdW5jdGlvbiB0b2dnbGVPYnNlcnZpbmcgKHZhbHVlKSB7XG4gICAgc2hvdWxkT2JzZXJ2ZSA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIE9ic2VydmVyIGNsYXNzIHRoYXQgaXMgYXR0YWNoZWQgdG8gZWFjaCBvYnNlcnZlZFxuICAgKiBvYmplY3QuIE9uY2UgYXR0YWNoZWQsIHRoZSBvYnNlcnZlciBjb252ZXJ0cyB0aGUgdGFyZ2V0XG4gICAqIG9iamVjdCdzIHByb3BlcnR5IGtleXMgaW50byBnZXR0ZXIvc2V0dGVycyB0aGF0XG4gICAqIGNvbGxlY3QgZGVwZW5kZW5jaWVzIGFuZCBkaXNwYXRjaCB1cGRhdGVzLlxuICAgKi9cbiAgdmFyIE9ic2VydmVyID0gZnVuY3Rpb24gT2JzZXJ2ZXIgKHZhbHVlKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMuZGVwID0gbmV3IERlcCgpO1xuICAgIHRoaXMudm1Db3VudCA9IDA7XG4gICAgZGVmKHZhbHVlLCAnX19vYl9fJywgdGhpcyk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBpZiAoaGFzUHJvdG8pIHtcbiAgICAgICAgcHJvdG9BdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29weUF1Z21lbnQodmFsdWUsIGFycmF5TWV0aG9kcywgYXJyYXlLZXlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub2JzZXJ2ZUFycmF5KHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53YWxrKHZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFdhbGsgdGhyb3VnaCBhbGwgcHJvcGVydGllcyBhbmQgY29udmVydCB0aGVtIGludG9cbiAgICogZ2V0dGVyL3NldHRlcnMuIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuXG4gICAqIHZhbHVlIHR5cGUgaXMgT2JqZWN0LlxuICAgKi9cbiAgT2JzZXJ2ZXIucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiB3YWxrIChvYmopIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZWZpbmVSZWFjdGl2ZSQkMShvYmosIGtleXNbaV0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogT2JzZXJ2ZSBhIGxpc3Qgb2YgQXJyYXkgaXRlbXMuXG4gICAqL1xuICBPYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZUFycmF5ID0gZnVuY3Rpb24gb2JzZXJ2ZUFycmF5IChpdGVtcykge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBvYnNlcnZlKGl0ZW1zW2ldKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gaGVscGVyc1xuXG4gIC8qKlxuICAgKiBBdWdtZW50IGEgdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBpbnRlcmNlcHRpbmdcbiAgICogdGhlIHByb3RvdHlwZSBjaGFpbiB1c2luZyBfX3Byb3RvX19cbiAgICovXG4gIGZ1bmN0aW9uIHByb3RvQXVnbWVudCAodGFyZ2V0LCBzcmMpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuICAgIHRhcmdldC5fX3Byb3RvX18gPSBzcmM7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90byAqL1xuICB9XG5cbiAgLyoqXG4gICAqIEF1Z21lbnQgYSB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGRlZmluaW5nXG4gICAqIGhpZGRlbiBwcm9wZXJ0aWVzLlxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZnVuY3Rpb24gY29weUF1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICBkZWYodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdCB0byBjcmVhdGUgYW4gb2JzZXJ2ZXIgaW5zdGFuY2UgZm9yIGEgdmFsdWUsXG4gICAqIHJldHVybnMgdGhlIG5ldyBvYnNlcnZlciBpZiBzdWNjZXNzZnVsbHkgb2JzZXJ2ZWQsXG4gICAqIG9yIHRoZSBleGlzdGluZyBvYnNlcnZlciBpZiB0aGUgdmFsdWUgYWxyZWFkeSBoYXMgb25lLlxuICAgKi9cbiAgZnVuY3Rpb24gb2JzZXJ2ZSAodmFsdWUsIGFzUm9vdERhdGEpIHtcbiAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCB2YWx1ZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIG9iO1xuICAgIGlmIChoYXNPd24odmFsdWUsICdfX29iX18nKSAmJiB2YWx1ZS5fX29iX18gaW5zdGFuY2VvZiBPYnNlcnZlcikge1xuICAgICAgb2IgPSB2YWx1ZS5fX29iX187XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHNob3VsZE9ic2VydmUgJiZcbiAgICAgICFpc1NlcnZlclJlbmRlcmluZygpICYmXG4gICAgICAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSkpICYmXG4gICAgICBPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKSAmJlxuICAgICAgIXZhbHVlLl9pc1Z1ZVxuICAgICkge1xuICAgICAgb2IgPSBuZXcgT2JzZXJ2ZXIodmFsdWUpO1xuICAgIH1cbiAgICBpZiAoYXNSb290RGF0YSAmJiBvYikge1xuICAgICAgb2Iudm1Db3VudCsrO1xuICAgIH1cbiAgICByZXR1cm4gb2JcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmUgYSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiBhbiBPYmplY3QuXG4gICAqL1xuICBmdW5jdGlvbiBkZWZpbmVSZWFjdGl2ZSQkMSAoXG4gICAgb2JqLFxuICAgIGtleSxcbiAgICB2YWwsXG4gICAgY3VzdG9tU2V0dGVyLFxuICAgIHNoYWxsb3dcbiAgKSB7XG4gICAgdmFyIGRlcCA9IG5ldyBEZXAoKTtcblxuICAgIHZhciBwcm9wZXJ0eSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuICAgIGlmIChwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5jb25maWd1cmFibGUgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBjYXRlciBmb3IgcHJlLWRlZmluZWQgZ2V0dGVyL3NldHRlcnNcbiAgICB2YXIgZ2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuZ2V0O1xuICAgIHZhciBzZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5zZXQ7XG4gICAgaWYgKCghZ2V0dGVyIHx8IHNldHRlcikgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdmFsID0gb2JqW2tleV07XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKHZhbCk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiByZWFjdGl2ZUdldHRlciAoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgICAgZGVwLmRlcGVuZCgpO1xuICAgICAgICAgIGlmIChjaGlsZE9iKSB7XG4gICAgICAgICAgICBjaGlsZE9iLmRlcC5kZXBlbmQoKTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICBkZXBlbmRBcnJheSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gcmVhY3RpdmVTZXR0ZXIgKG5ld1ZhbCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgICAgaWYgKG5ld1ZhbCA9PT0gdmFsdWUgfHwgKG5ld1ZhbCAhPT0gbmV3VmFsICYmIHZhbHVlICE9PSB2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgICBpZiAoY3VzdG9tU2V0dGVyKSB7XG4gICAgICAgICAgY3VzdG9tU2V0dGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gIzc5ODE6IGZvciBhY2Nlc3NvciBwcm9wZXJ0aWVzIHdpdGhvdXQgc2V0dGVyXG4gICAgICAgIGlmIChnZXR0ZXIgJiYgIXNldHRlcikgeyByZXR1cm4gfVxuICAgICAgICBpZiAoc2V0dGVyKSB7XG4gICAgICAgICAgc2V0dGVyLmNhbGwob2JqLCBuZXdWYWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IG5ld1ZhbDtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZE9iID0gIXNoYWxsb3cgJiYgb2JzZXJ2ZShuZXdWYWwpO1xuICAgICAgICBkZXAubm90aWZ5KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IGEgcHJvcGVydHkgb24gYW4gb2JqZWN0LiBBZGRzIHRoZSBuZXcgcHJvcGVydHkgYW5kXG4gICAqIHRyaWdnZXJzIGNoYW5nZSBub3RpZmljYXRpb24gaWYgdGhlIHByb3BlcnR5IGRvZXNuJ3RcbiAgICogYWxyZWFkeSBleGlzdC5cbiAgICovXG4gIGZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbCkge1xuICAgIGlmIChpc1VuZGVmKHRhcmdldCkgfHwgaXNQcmltaXRpdmUodGFyZ2V0KVxuICAgICkge1xuICAgICAgd2FybigoXCJDYW5ub3Qgc2V0IHJlYWN0aXZlIHByb3BlcnR5IG9uIHVuZGVmaW5lZCwgbnVsbCwgb3IgcHJpbWl0aXZlIHZhbHVlOiBcIiArICgodGFyZ2V0KSkpKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiBpc1ZhbGlkQXJyYXlJbmRleChrZXkpKSB7XG4gICAgICB0YXJnZXQubGVuZ3RoID0gTWF0aC5tYXgodGFyZ2V0Lmxlbmd0aCwga2V5KTtcbiAgICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxLCB2YWwpO1xuICAgICAgcmV0dXJuIHZhbFxuICAgIH1cbiAgICBpZiAoa2V5IGluIHRhcmdldCAmJiAhKGtleSBpbiBPYmplY3QucHJvdG90eXBlKSkge1xuICAgICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgICByZXR1cm4gdmFsXG4gICAgfVxuICAgIHZhciBvYiA9ICh0YXJnZXQpLl9fb2JfXztcbiAgICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdBdm9pZCBhZGRpbmcgcmVhY3RpdmUgcHJvcGVydGllcyB0byBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICAgJ2F0IHJ1bnRpbWUgLSBkZWNsYXJlIGl0IHVwZnJvbnQgaW4gdGhlIGRhdGEgb3B0aW9uLidcbiAgICAgICk7XG4gICAgICByZXR1cm4gdmFsXG4gICAgfVxuICAgIGlmICghb2IpIHtcbiAgICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgICAgcmV0dXJuIHZhbFxuICAgIH1cbiAgICBkZWZpbmVSZWFjdGl2ZSQkMShvYi52YWx1ZSwga2V5LCB2YWwpO1xuICAgIG9iLmRlcC5ub3RpZnkoKTtcbiAgICByZXR1cm4gdmFsXG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIGEgcHJvcGVydHkgYW5kIHRyaWdnZXIgY2hhbmdlIGlmIG5lY2Vzc2FyeS5cbiAgICovXG4gIGZ1bmN0aW9uIGRlbCAodGFyZ2V0LCBrZXkpIHtcbiAgICBpZiAoaXNVbmRlZih0YXJnZXQpIHx8IGlzUHJpbWl0aXZlKHRhcmdldClcbiAgICApIHtcbiAgICAgIHdhcm4oKFwiQ2Fubm90IGRlbGV0ZSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiB1bmRlZmluZWQsIG51bGwsIG9yIHByaW1pdGl2ZSB2YWx1ZTogXCIgKyAoKHRhcmdldCkpKSk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgaXNWYWxpZEFycmF5SW5kZXgoa2V5KSkge1xuICAgICAgdGFyZ2V0LnNwbGljZShrZXksIDEpO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBvYiA9ICh0YXJnZXQpLl9fb2JfXztcbiAgICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdBdm9pZCBkZWxldGluZyBwcm9wZXJ0aWVzIG9uIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgICAnLSBqdXN0IHNldCBpdCB0byBudWxsLidcbiAgICAgICk7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKCFoYXNPd24odGFyZ2V0LCBrZXkpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgZGVsZXRlIHRhcmdldFtrZXldO1xuICAgIGlmICghb2IpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBvYi5kZXAubm90aWZ5KCk7XG4gIH1cblxuICAvKipcbiAgICogQ29sbGVjdCBkZXBlbmRlbmNpZXMgb24gYXJyYXkgZWxlbWVudHMgd2hlbiB0aGUgYXJyYXkgaXMgdG91Y2hlZCwgc2luY2VcbiAgICogd2UgY2Fubm90IGludGVyY2VwdCBhcnJheSBlbGVtZW50IGFjY2VzcyBsaWtlIHByb3BlcnR5IGdldHRlcnMuXG4gICAqL1xuICBmdW5jdGlvbiBkZXBlbmRBcnJheSAodmFsdWUpIHtcbiAgICBmb3IgKHZhciBlID0gKHZvaWQgMCksIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBlID0gdmFsdWVbaV07XG4gICAgICBlICYmIGUuX19vYl9fICYmIGUuX19vYl9fLmRlcC5kZXBlbmQoKTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSB7XG4gICAgICAgIGRlcGVuZEFycmF5KGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIC8qKlxuICAgKiBPcHRpb24gb3ZlcndyaXRpbmcgc3RyYXRlZ2llcyBhcmUgZnVuY3Rpb25zIHRoYXQgaGFuZGxlXG4gICAqIGhvdyB0byBtZXJnZSBhIHBhcmVudCBvcHRpb24gdmFsdWUgYW5kIGEgY2hpbGQgb3B0aW9uXG4gICAqIHZhbHVlIGludG8gdGhlIGZpbmFsIHZhbHVlLlxuICAgKi9cbiAgdmFyIHN0cmF0cyA9IGNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXM7XG5cbiAgLyoqXG4gICAqIE9wdGlvbnMgd2l0aCByZXN0cmljdGlvbnNcbiAgICovXG4gIHtcbiAgICBzdHJhdHMuZWwgPSBzdHJhdHMucHJvcHNEYXRhID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQsIHZtLCBrZXkpIHtcbiAgICAgIGlmICghdm0pIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIm9wdGlvbiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgaW5zdGFuY2UgXCIgK1xuICAgICAgICAgICdjcmVhdGlvbiB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkLidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWZhdWx0U3RyYXQocGFyZW50LCBjaGlsZClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciB0aGF0IHJlY3Vyc2l2ZWx5IG1lcmdlcyB0d28gZGF0YSBvYmplY3RzIHRvZ2V0aGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gbWVyZ2VEYXRhICh0bywgZnJvbSkge1xuICAgIGlmICghZnJvbSkgeyByZXR1cm4gdG8gfVxuICAgIHZhciBrZXksIHRvVmFsLCBmcm9tVmFsO1xuXG4gICAgdmFyIGtleXMgPSBoYXNTeW1ib2xcbiAgICAgID8gUmVmbGVjdC5vd25LZXlzKGZyb20pXG4gICAgICA6IE9iamVjdC5rZXlzKGZyb20pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgLy8gaW4gY2FzZSB0aGUgb2JqZWN0IGlzIGFscmVhZHkgb2JzZXJ2ZWQuLi5cbiAgICAgIGlmIChrZXkgPT09ICdfX29iX18nKSB7IGNvbnRpbnVlIH1cbiAgICAgIHRvVmFsID0gdG9ba2V5XTtcbiAgICAgIGZyb21WYWwgPSBmcm9tW2tleV07XG4gICAgICBpZiAoIWhhc093bih0bywga2V5KSkge1xuICAgICAgICBzZXQodG8sIGtleSwgZnJvbVZhbCk7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICB0b1ZhbCAhPT0gZnJvbVZhbCAmJlxuICAgICAgICBpc1BsYWluT2JqZWN0KHRvVmFsKSAmJlxuICAgICAgICBpc1BsYWluT2JqZWN0KGZyb21WYWwpXG4gICAgICApIHtcbiAgICAgICAgbWVyZ2VEYXRhKHRvVmFsLCBmcm9tVmFsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvXG4gIH1cblxuICAvKipcbiAgICogRGF0YVxuICAgKi9cbiAgZnVuY3Rpb24gbWVyZ2VEYXRhT3JGbiAoXG4gICAgcGFyZW50VmFsLFxuICAgIGNoaWxkVmFsLFxuICAgIHZtXG4gICkge1xuICAgIGlmICghdm0pIHtcbiAgICAgIC8vIGluIGEgVnVlLmV4dGVuZCBtZXJnZSwgYm90aCBzaG91bGQgYmUgZnVuY3Rpb25zXG4gICAgICBpZiAoIWNoaWxkVmFsKSB7XG4gICAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICAgIH1cbiAgICAgIGlmICghcGFyZW50VmFsKSB7XG4gICAgICAgIHJldHVybiBjaGlsZFZhbFxuICAgICAgfVxuICAgICAgLy8gd2hlbiBwYXJlbnRWYWwgJiBjaGlsZFZhbCBhcmUgYm90aCBwcmVzZW50LFxuICAgICAgLy8gd2UgbmVlZCB0byByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG4gICAgICAvLyBtZXJnZWQgcmVzdWx0IG9mIGJvdGggZnVuY3Rpb25zLi4uIG5vIG5lZWQgdG9cbiAgICAgIC8vIGNoZWNrIGlmIHBhcmVudFZhbCBpcyBhIGZ1bmN0aW9uIGhlcmUgYmVjYXVzZVxuICAgICAgLy8gaXQgaGFzIHRvIGJlIGEgZnVuY3Rpb24gdG8gcGFzcyBwcmV2aW91cyBtZXJnZXMuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkRGF0YUZuICgpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlRGF0YShcbiAgICAgICAgICB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbicgPyBjaGlsZFZhbC5jYWxsKHRoaXMsIHRoaXMpIDogY2hpbGRWYWwsXG4gICAgICAgICAgdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IHBhcmVudFZhbC5jYWxsKHRoaXMsIHRoaXMpIDogcGFyZW50VmFsXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZEluc3RhbmNlRGF0YUZuICgpIHtcbiAgICAgICAgLy8gaW5zdGFuY2UgbWVyZ2VcbiAgICAgICAgdmFyIGluc3RhbmNlRGF0YSA9IHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgID8gY2hpbGRWYWwuY2FsbCh2bSwgdm0pXG4gICAgICAgICAgOiBjaGlsZFZhbDtcbiAgICAgICAgdmFyIGRlZmF1bHREYXRhID0gdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgID8gcGFyZW50VmFsLmNhbGwodm0sIHZtKVxuICAgICAgICAgIDogcGFyZW50VmFsO1xuICAgICAgICBpZiAoaW5zdGFuY2VEYXRhKSB7XG4gICAgICAgICAgcmV0dXJuIG1lcmdlRGF0YShpbnN0YW5jZURhdGEsIGRlZmF1bHREYXRhKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBkZWZhdWx0RGF0YVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3RyYXRzLmRhdGEgPSBmdW5jdGlvbiAoXG4gICAgcGFyZW50VmFsLFxuICAgIGNoaWxkVmFsLFxuICAgIHZtXG4gICkge1xuICAgIGlmICghdm0pIHtcbiAgICAgIGlmIChjaGlsZFZhbCAmJiB0eXBlb2YgY2hpbGRWYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnVGhlIFwiZGF0YVwiIG9wdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbiAnICtcbiAgICAgICAgICAndGhhdCByZXR1cm5zIGEgcGVyLWluc3RhbmNlIHZhbHVlIGluIGNvbXBvbmVudCAnICtcbiAgICAgICAgICAnZGVmaW5pdGlvbnMuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXJnZURhdGFPckZuKHBhcmVudFZhbCwgY2hpbGRWYWwpXG4gICAgfVxuXG4gICAgcmV0dXJuIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pXG4gIH07XG5cbiAgLyoqXG4gICAqIEhvb2tzIGFuZCBwcm9wcyBhcmUgbWVyZ2VkIGFzIGFycmF5cy5cbiAgICovXG4gIGZ1bmN0aW9uIG1lcmdlSG9vayAoXG4gICAgcGFyZW50VmFsLFxuICAgIGNoaWxkVmFsXG4gICkge1xuICAgIHZhciByZXMgPSBjaGlsZFZhbFxuICAgICAgPyBwYXJlbnRWYWxcbiAgICAgICAgPyBwYXJlbnRWYWwuY29uY2F0KGNoaWxkVmFsKVxuICAgICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRWYWwpXG4gICAgICAgICAgPyBjaGlsZFZhbFxuICAgICAgICAgIDogW2NoaWxkVmFsXVxuICAgICAgOiBwYXJlbnRWYWw7XG4gICAgcmV0dXJuIHJlc1xuICAgICAgPyBkZWR1cGVIb29rcyhyZXMpXG4gICAgICA6IHJlc1xuICB9XG5cbiAgZnVuY3Rpb24gZGVkdXBlSG9va3MgKGhvb2tzKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZXMuaW5kZXhPZihob29rc1tpXSkgPT09IC0xKSB7XG4gICAgICAgIHJlcy5wdXNoKGhvb2tzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgTElGRUNZQ0xFX0hPT0tTLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHtcbiAgICBzdHJhdHNbaG9va10gPSBtZXJnZUhvb2s7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBBc3NldHNcbiAgICpcbiAgICogV2hlbiBhIHZtIGlzIHByZXNlbnQgKGluc3RhbmNlIGNyZWF0aW9uKSwgd2UgbmVlZCB0byBkb1xuICAgKiBhIHRocmVlLXdheSBtZXJnZSBiZXR3ZWVuIGNvbnN0cnVjdG9yIG9wdGlvbnMsIGluc3RhbmNlXG4gICAqIG9wdGlvbnMgYW5kIHBhcmVudCBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gbWVyZ2VBc3NldHMgKFxuICAgIHBhcmVudFZhbCxcbiAgICBjaGlsZFZhbCxcbiAgICB2bSxcbiAgICBrZXlcbiAgKSB7XG4gICAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpO1xuICAgIGlmIChjaGlsZFZhbCkge1xuICAgICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gICAgICByZXR1cm4gZXh0ZW5kKHJlcywgY2hpbGRWYWwpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXNcbiAgICB9XG4gIH1cblxuICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgc3RyYXRzW3R5cGUgKyAncyddID0gbWVyZ2VBc3NldHM7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBXYXRjaGVycy5cbiAgICpcbiAgICogV2F0Y2hlcnMgaGFzaGVzIHNob3VsZCBub3Qgb3ZlcndyaXRlIG9uZVxuICAgKiBhbm90aGVyLCBzbyB3ZSBtZXJnZSB0aGVtIGFzIGFycmF5cy5cbiAgICovXG4gIHN0cmF0cy53YXRjaCA9IGZ1bmN0aW9uIChcbiAgICBwYXJlbnRWYWwsXG4gICAgY2hpbGRWYWwsXG4gICAgdm0sXG4gICAga2V5XG4gICkge1xuICAgIC8vIHdvcmsgYXJvdW5kIEZpcmVmb3gncyBPYmplY3QucHJvdG90eXBlLndhdGNoLi4uXG4gICAgaWYgKHBhcmVudFZhbCA9PT0gbmF0aXZlV2F0Y2gpIHsgcGFyZW50VmFsID0gdW5kZWZpbmVkOyB9XG4gICAgaWYgKGNoaWxkVmFsID09PSBuYXRpdmVXYXRjaCkgeyBjaGlsZFZhbCA9IHVuZGVmaW5lZDsgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGRWYWwpIHsgcmV0dXJuIE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpIH1cbiAgICB7XG4gICAgICBhc3NlcnRPYmplY3RUeXBlKGtleSwgY2hpbGRWYWwsIHZtKTtcbiAgICB9XG4gICAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgICB2YXIgcmV0ID0ge307XG4gICAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgICBmb3IgKHZhciBrZXkkMSBpbiBjaGlsZFZhbCkge1xuICAgICAgdmFyIHBhcmVudCA9IHJldFtrZXkkMV07XG4gICAgICB2YXIgY2hpbGQgPSBjaGlsZFZhbFtrZXkkMV07XG4gICAgICBpZiAocGFyZW50ICYmICFBcnJheS5pc0FycmF5KHBhcmVudCkpIHtcbiAgICAgICAgcGFyZW50ID0gW3BhcmVudF07XG4gICAgICB9XG4gICAgICByZXRba2V5JDFdID0gcGFyZW50XG4gICAgICAgID8gcGFyZW50LmNvbmNhdChjaGlsZClcbiAgICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkKSA/IGNoaWxkIDogW2NoaWxkXTtcbiAgICB9XG4gICAgcmV0dXJuIHJldFxuICB9O1xuXG4gIC8qKlxuICAgKiBPdGhlciBvYmplY3QgaGFzaGVzLlxuICAgKi9cbiAgc3RyYXRzLnByb3BzID1cbiAgc3RyYXRzLm1ldGhvZHMgPVxuICBzdHJhdHMuaW5qZWN0ID1cbiAgc3RyYXRzLmNvbXB1dGVkID0gZnVuY3Rpb24gKFxuICAgIHBhcmVudFZhbCxcbiAgICBjaGlsZFZhbCxcbiAgICB2bSxcbiAgICBrZXlcbiAgKSB7XG4gICAgaWYgKGNoaWxkVmFsICYmIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBhc3NlcnRPYmplY3RUeXBlKGtleSwgY2hpbGRWYWwsIHZtKTtcbiAgICB9XG4gICAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgICB2YXIgcmV0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICAgIGlmIChjaGlsZFZhbCkgeyBleHRlbmQocmV0LCBjaGlsZFZhbCk7IH1cbiAgICByZXR1cm4gcmV0XG4gIH07XG4gIHN0cmF0cy5wcm92aWRlID0gbWVyZ2VEYXRhT3JGbjtcblxuICAvKipcbiAgICogRGVmYXVsdCBzdHJhdGVneS5cbiAgICovXG4gIHZhciBkZWZhdWx0U3RyYXQgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICAgIHJldHVybiBjaGlsZFZhbCA9PT0gdW5kZWZpbmVkXG4gICAgICA/IHBhcmVudFZhbFxuICAgICAgOiBjaGlsZFZhbFxuICB9O1xuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBjb21wb25lbnQgbmFtZXNcbiAgICovXG4gIGZ1bmN0aW9uIGNoZWNrQ29tcG9uZW50cyAob3B0aW9ucykge1xuICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zLmNvbXBvbmVudHMpIHtcbiAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShrZXkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlQ29tcG9uZW50TmFtZSAobmFtZSkge1xuICAgIGlmICghbmV3IFJlZ0V4cCgoXCJeW2EtekEtWl1bXFxcXC1cXFxcLjAtOV9cIiArICh1bmljb2RlUmVnRXhwLnNvdXJjZSkgKyBcIl0qJFwiKSkudGVzdChuYW1lKSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0ludmFsaWQgY29tcG9uZW50IG5hbWU6IFwiJyArIG5hbWUgKyAnXCIuIENvbXBvbmVudCBuYW1lcyAnICtcbiAgICAgICAgJ3Nob3VsZCBjb25mb3JtIHRvIHZhbGlkIGN1c3RvbSBlbGVtZW50IG5hbWUgaW4gaHRtbDUgc3BlY2lmaWNhdGlvbi4nXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoaXNCdWlsdEluVGFnKG5hbWUpIHx8IGNvbmZpZy5pc1Jlc2VydmVkVGFnKG5hbWUpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCAnICtcbiAgICAgICAgJ2lkOiAnICsgbmFtZVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRW5zdXJlIGFsbCBwcm9wcyBvcHRpb24gc3ludGF4IGFyZSBub3JtYWxpemVkIGludG8gdGhlXG4gICAqIE9iamVjdC1iYXNlZCBmb3JtYXQuXG4gICAqL1xuICBmdW5jdGlvbiBub3JtYWxpemVQcm9wcyAob3B0aW9ucywgdm0pIHtcbiAgICB2YXIgcHJvcHMgPSBvcHRpb25zLnByb3BzO1xuICAgIGlmICghcHJvcHMpIHsgcmV0dXJuIH1cbiAgICB2YXIgcmVzID0ge307XG4gICAgdmFyIGksIHZhbCwgbmFtZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wcykpIHtcbiAgICAgIGkgPSBwcm9wcy5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHZhbCA9IHByb3BzW2ldO1xuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBuYW1lID0gY2FtZWxpemUodmFsKTtcbiAgICAgICAgICByZXNbbmFtZV0gPSB7IHR5cGU6IG51bGwgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuKCdwcm9wcyBtdXN0IGJlIHN0cmluZ3Mgd2hlbiB1c2luZyBhcnJheSBzeW50YXguJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QocHJvcHMpKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgdmFsID0gcHJvcHNba2V5XTtcbiAgICAgICAgbmFtZSA9IGNhbWVsaXplKGtleSk7XG4gICAgICAgIHJlc1tuYW1lXSA9IGlzUGxhaW5PYmplY3QodmFsKVxuICAgICAgICAgID8gdmFsXG4gICAgICAgICAgOiB7IHR5cGU6IHZhbCB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwicHJvcHNcXFwiOiBleHBlY3RlZCBhbiBBcnJheSBvciBhbiBPYmplY3QsIFwiICtcbiAgICAgICAgXCJidXQgZ290IFwiICsgKHRvUmF3VHlwZShwcm9wcykpICsgXCIuXCIsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgICBvcHRpb25zLnByb3BzID0gcmVzO1xuICB9XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZSBhbGwgaW5qZWN0aW9ucyBpbnRvIE9iamVjdC1iYXNlZCBmb3JtYXRcbiAgICovXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZUluamVjdCAob3B0aW9ucywgdm0pIHtcbiAgICB2YXIgaW5qZWN0ID0gb3B0aW9ucy5pbmplY3Q7XG4gICAgaWYgKCFpbmplY3QpIHsgcmV0dXJuIH1cbiAgICB2YXIgbm9ybWFsaXplZCA9IG9wdGlvbnMuaW5qZWN0ID0ge307XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaW5qZWN0KSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmplY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbm9ybWFsaXplZFtpbmplY3RbaV1dID0geyBmcm9tOiBpbmplY3RbaV0gfTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QoaW5qZWN0KSkge1xuICAgICAgZm9yICh2YXIga2V5IGluIGluamVjdCkge1xuICAgICAgICB2YXIgdmFsID0gaW5qZWN0W2tleV07XG4gICAgICAgIG5vcm1hbGl6ZWRba2V5XSA9IGlzUGxhaW5PYmplY3QodmFsKVxuICAgICAgICAgID8gZXh0ZW5kKHsgZnJvbToga2V5IH0sIHZhbClcbiAgICAgICAgICA6IHsgZnJvbTogdmFsIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJpbmplY3RcXFwiOiBleHBlY3RlZCBhbiBBcnJheSBvciBhbiBPYmplY3QsIFwiICtcbiAgICAgICAgXCJidXQgZ290IFwiICsgKHRvUmF3VHlwZShpbmplY3QpKSArIFwiLlwiLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTm9ybWFsaXplIHJhdyBmdW5jdGlvbiBkaXJlY3RpdmVzIGludG8gb2JqZWN0IGZvcm1hdC5cbiAgICovXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMgKG9wdGlvbnMpIHtcbiAgICB2YXIgZGlycyA9IG9wdGlvbnMuZGlyZWN0aXZlcztcbiAgICBpZiAoZGlycykge1xuICAgICAgZm9yICh2YXIga2V5IGluIGRpcnMpIHtcbiAgICAgICAgdmFyIGRlZiQkMSA9IGRpcnNba2V5XTtcbiAgICAgICAgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBkaXJzW2tleV0gPSB7IGJpbmQ6IGRlZiQkMSwgdXBkYXRlOiBkZWYkJDEgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2VydE9iamVjdFR5cGUgKG5hbWUsIHZhbHVlLCB2bSkge1xuICAgIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJcIiArIG5hbWUgKyBcIlxcXCI6IGV4cGVjdGVkIGFuIE9iamVjdCwgXCIgK1xuICAgICAgICBcImJ1dCBnb3QgXCIgKyAodG9SYXdUeXBlKHZhbHVlKSkgKyBcIi5cIixcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1lcmdlIHR3byBvcHRpb24gb2JqZWN0cyBpbnRvIGEgbmV3IG9uZS5cbiAgICogQ29yZSB1dGlsaXR5IHVzZWQgaW4gYm90aCBpbnN0YW50aWF0aW9uIGFuZCBpbmhlcml0YW5jZS5cbiAgICovXG4gIGZ1bmN0aW9uIG1lcmdlT3B0aW9ucyAoXG4gICAgcGFyZW50LFxuICAgIGNoaWxkLFxuICAgIHZtXG4gICkge1xuICAgIHtcbiAgICAgIGNoZWNrQ29tcG9uZW50cyhjaGlsZCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2hpbGQgPSBjaGlsZC5vcHRpb25zO1xuICAgIH1cblxuICAgIG5vcm1hbGl6ZVByb3BzKGNoaWxkLCB2bSk7XG4gICAgbm9ybWFsaXplSW5qZWN0KGNoaWxkLCB2bSk7XG4gICAgbm9ybWFsaXplRGlyZWN0aXZlcyhjaGlsZCk7XG5cbiAgICAvLyBBcHBseSBleHRlbmRzIGFuZCBtaXhpbnMgb24gdGhlIGNoaWxkIG9wdGlvbnMsXG4gICAgLy8gYnV0IG9ubHkgaWYgaXQgaXMgYSByYXcgb3B0aW9ucyBvYmplY3QgdGhhdCBpc24ndFxuICAgIC8vIHRoZSByZXN1bHQgb2YgYW5vdGhlciBtZXJnZU9wdGlvbnMgY2FsbC5cbiAgICAvLyBPbmx5IG1lcmdlZCBvcHRpb25zIGhhcyB0aGUgX2Jhc2UgcHJvcGVydHkuXG4gICAgaWYgKCFjaGlsZC5fYmFzZSkge1xuICAgICAgaWYgKGNoaWxkLmV4dGVuZHMpIHtcbiAgICAgICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGQuZXh0ZW5kcywgdm0pO1xuICAgICAgfVxuICAgICAgaWYgKGNoaWxkLm1peGlucykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkLm1peGlucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5taXhpbnNbaV0sIHZtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBvcHRpb25zID0ge307XG4gICAgdmFyIGtleTtcbiAgICBmb3IgKGtleSBpbiBwYXJlbnQpIHtcbiAgICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgICB9XG4gICAgZm9yIChrZXkgaW4gY2hpbGQpIHtcbiAgICAgIGlmICghaGFzT3duKHBhcmVudCwga2V5KSkge1xuICAgICAgICBtZXJnZUZpZWxkKGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1lcmdlRmllbGQgKGtleSkge1xuICAgICAgdmFyIHN0cmF0ID0gc3RyYXRzW2tleV0gfHwgZGVmYXVsdFN0cmF0O1xuICAgICAgb3B0aW9uc1trZXldID0gc3RyYXQocGFyZW50W2tleV0sIGNoaWxkW2tleV0sIHZtLCBrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9uc1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc29sdmUgYW4gYXNzZXQuXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBiZWNhdXNlIGNoaWxkIGluc3RhbmNlcyBuZWVkIGFjY2Vzc1xuICAgKiB0byBhc3NldHMgZGVmaW5lZCBpbiBpdHMgYW5jZXN0b3IgY2hhaW4uXG4gICAqL1xuICBmdW5jdGlvbiByZXNvbHZlQXNzZXQgKFxuICAgIG9wdGlvbnMsXG4gICAgdHlwZSxcbiAgICBpZCxcbiAgICB3YXJuTWlzc2luZ1xuICApIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBhc3NldHMgPSBvcHRpb25zW3R5cGVdO1xuICAgIC8vIGNoZWNrIGxvY2FsIHJlZ2lzdHJhdGlvbiB2YXJpYXRpb25zIGZpcnN0XG4gICAgaWYgKGhhc093bihhc3NldHMsIGlkKSkgeyByZXR1cm4gYXNzZXRzW2lkXSB9XG4gICAgdmFyIGNhbWVsaXplZElkID0gY2FtZWxpemUoaWQpO1xuICAgIGlmIChoYXNPd24oYXNzZXRzLCBjYW1lbGl6ZWRJZCkpIHsgcmV0dXJuIGFzc2V0c1tjYW1lbGl6ZWRJZF0gfVxuICAgIHZhciBQYXNjYWxDYXNlSWQgPSBjYXBpdGFsaXplKGNhbWVsaXplZElkKTtcbiAgICBpZiAoaGFzT3duKGFzc2V0cywgUGFzY2FsQ2FzZUlkKSkgeyByZXR1cm4gYXNzZXRzW1Bhc2NhbENhc2VJZF0gfVxuICAgIC8vIGZhbGxiYWNrIHRvIHByb3RvdHlwZSBjaGFpblxuICAgIHZhciByZXMgPSBhc3NldHNbaWRdIHx8IGFzc2V0c1tjYW1lbGl6ZWRJZF0gfHwgYXNzZXRzW1Bhc2NhbENhc2VJZF07XG4gICAgaWYgKHdhcm5NaXNzaW5nICYmICFyZXMpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdGYWlsZWQgdG8gcmVzb2x2ZSAnICsgdHlwZS5zbGljZSgwLCAtMSkgKyAnOiAnICsgaWQsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfVxuXG4gIC8qICAqL1xuXG5cblxuICBmdW5jdGlvbiB2YWxpZGF0ZVByb3AgKFxuICAgIGtleSxcbiAgICBwcm9wT3B0aW9ucyxcbiAgICBwcm9wc0RhdGEsXG4gICAgdm1cbiAgKSB7XG4gICAgdmFyIHByb3AgPSBwcm9wT3B0aW9uc1trZXldO1xuICAgIHZhciBhYnNlbnQgPSAhaGFzT3duKHByb3BzRGF0YSwga2V5KTtcbiAgICB2YXIgdmFsdWUgPSBwcm9wc0RhdGFba2V5XTtcbiAgICAvLyBib29sZWFuIGNhc3RpbmdcbiAgICB2YXIgYm9vbGVhbkluZGV4ID0gZ2V0VHlwZUluZGV4KEJvb2xlYW4sIHByb3AudHlwZSk7XG4gICAgaWYgKGJvb2xlYW5JbmRleCA+IC0xKSB7XG4gICAgICBpZiAoYWJzZW50ICYmICFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xuICAgICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IGh5cGhlbmF0ZShrZXkpKSB7XG4gICAgICAgIC8vIG9ubHkgY2FzdCBlbXB0eSBzdHJpbmcgLyBzYW1lIG5hbWUgdG8gYm9vbGVhbiBpZlxuICAgICAgICAvLyBib29sZWFuIGhhcyBoaWdoZXIgcHJpb3JpdHlcbiAgICAgICAgdmFyIHN0cmluZ0luZGV4ID0gZ2V0VHlwZUluZGV4KFN0cmluZywgcHJvcC50eXBlKTtcbiAgICAgICAgaWYgKHN0cmluZ0luZGV4IDwgMCB8fCBib29sZWFuSW5kZXggPCBzdHJpbmdJbmRleCkge1xuICAgICAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBjaGVjayBkZWZhdWx0IHZhbHVlXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhbHVlID0gZ2V0UHJvcERlZmF1bHRWYWx1ZSh2bSwgcHJvcCwga2V5KTtcbiAgICAgIC8vIHNpbmNlIHRoZSBkZWZhdWx0IHZhbHVlIGlzIGEgZnJlc2ggY29weSxcbiAgICAgIC8vIG1ha2Ugc3VyZSB0byBvYnNlcnZlIGl0LlxuICAgICAgdmFyIHByZXZTaG91bGRPYnNlcnZlID0gc2hvdWxkT2JzZXJ2ZTtcbiAgICAgIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbiAgICAgIG9ic2VydmUodmFsdWUpO1xuICAgICAgdG9nZ2xlT2JzZXJ2aW5nKHByZXZTaG91bGRPYnNlcnZlKTtcbiAgICB9XG4gICAge1xuICAgICAgYXNzZXJ0UHJvcChwcm9wLCBrZXksIHZhbHVlLCB2bSwgYWJzZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGEgcHJvcC5cbiAgICovXG4gIGZ1bmN0aW9uIGdldFByb3BEZWZhdWx0VmFsdWUgKHZtLCBwcm9wLCBrZXkpIHtcbiAgICAvLyBubyBkZWZhdWx0LCByZXR1cm4gdW5kZWZpbmVkXG4gICAgaWYgKCFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH1cbiAgICB2YXIgZGVmID0gcHJvcC5kZWZhdWx0O1xuICAgIC8vIHdhcm4gYWdhaW5zdCBub24tZmFjdG9yeSBkZWZhdWx0cyBmb3IgT2JqZWN0ICYgQXJyYXlcbiAgICBpZiAoaXNPYmplY3QoZGVmKSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0ludmFsaWQgZGVmYXVsdCB2YWx1ZSBmb3IgcHJvcCBcIicgKyBrZXkgKyAnXCI6ICcgK1xuICAgICAgICAnUHJvcHMgd2l0aCB0eXBlIE9iamVjdC9BcnJheSBtdXN0IHVzZSBhIGZhY3RvcnkgZnVuY3Rpb24gJyArXG4gICAgICAgICd0byByZXR1cm4gdGhlIGRlZmF1bHQgdmFsdWUuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICAgIC8vIHRoZSByYXcgcHJvcCB2YWx1ZSB3YXMgYWxzbyB1bmRlZmluZWQgZnJvbSBwcmV2aW91cyByZW5kZXIsXG4gICAgLy8gcmV0dXJuIHByZXZpb3VzIGRlZmF1bHQgdmFsdWUgdG8gYXZvaWQgdW5uZWNlc3Nhcnkgd2F0Y2hlciB0cmlnZ2VyXG4gICAgaWYgKHZtICYmIHZtLiRvcHRpb25zLnByb3BzRGF0YSAmJlxuICAgICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhW2tleV0gPT09IHVuZGVmaW5lZCAmJlxuICAgICAgdm0uX3Byb3BzW2tleV0gIT09IHVuZGVmaW5lZFxuICAgICkge1xuICAgICAgcmV0dXJuIHZtLl9wcm9wc1trZXldXG4gICAgfVxuICAgIC8vIGNhbGwgZmFjdG9yeSBmdW5jdGlvbiBmb3Igbm9uLUZ1bmN0aW9uIHR5cGVzXG4gICAgLy8gYSB2YWx1ZSBpcyBGdW5jdGlvbiBpZiBpdHMgcHJvdG90eXBlIGlzIGZ1bmN0aW9uIGV2ZW4gYWNyb3NzIGRpZmZlcmVudCBleGVjdXRpb24gY29udGV4dFxuICAgIHJldHVybiB0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nICYmIGdldFR5cGUocHJvcC50eXBlKSAhPT0gJ0Z1bmN0aW9uJ1xuICAgICAgPyBkZWYuY2FsbCh2bSlcbiAgICAgIDogZGVmXG4gIH1cblxuICAvKipcbiAgICogQXNzZXJ0IHdoZXRoZXIgYSBwcm9wIGlzIHZhbGlkLlxuICAgKi9cbiAgZnVuY3Rpb24gYXNzZXJ0UHJvcCAoXG4gICAgcHJvcCxcbiAgICBuYW1lLFxuICAgIHZhbHVlLFxuICAgIHZtLFxuICAgIGFic2VudFxuICApIHtcbiAgICBpZiAocHJvcC5yZXF1aXJlZCAmJiBhYnNlbnQpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdNaXNzaW5nIHJlcXVpcmVkIHByb3A6IFwiJyArIG5hbWUgKyAnXCInLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAodmFsdWUgPT0gbnVsbCAmJiAhcHJvcC5yZXF1aXJlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciB0eXBlID0gcHJvcC50eXBlO1xuICAgIHZhciB2YWxpZCA9ICF0eXBlIHx8IHR5cGUgPT09IHRydWU7XG4gICAgdmFyIGV4cGVjdGVkVHlwZXMgPSBbXTtcbiAgICBpZiAodHlwZSkge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICAgIHR5cGUgPSBbdHlwZV07XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGUubGVuZ3RoICYmICF2YWxpZDsgaSsrKSB7XG4gICAgICAgIHZhciBhc3NlcnRlZFR5cGUgPSBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlW2ldKTtcbiAgICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGFzc2VydGVkVHlwZS5leHBlY3RlZFR5cGUgfHwgJycpO1xuICAgICAgICB2YWxpZCA9IGFzc2VydGVkVHlwZS52YWxpZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXZhbGlkKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgdmFsaWRhdG9yID0gcHJvcC52YWxpZGF0b3I7XG4gICAgaWYgKHZhbGlkYXRvcikge1xuICAgICAgaWYgKCF2YWxpZGF0b3IodmFsdWUpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ0ludmFsaWQgcHJvcDogY3VzdG9tIHZhbGlkYXRvciBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHNpbXBsZUNoZWNrUkUgPSAvXihTdHJpbmd8TnVtYmVyfEJvb2xlYW58RnVuY3Rpb258U3ltYm9sKSQvO1xuXG4gIGZ1bmN0aW9uIGFzc2VydFR5cGUgKHZhbHVlLCB0eXBlKSB7XG4gICAgdmFyIHZhbGlkO1xuICAgIHZhciBleHBlY3RlZFR5cGUgPSBnZXRUeXBlKHR5cGUpO1xuICAgIGlmIChzaW1wbGVDaGVja1JFLnRlc3QoZXhwZWN0ZWRUeXBlKSkge1xuICAgICAgdmFyIHQgPSB0eXBlb2YgdmFsdWU7XG4gICAgICB2YWxpZCA9IHQgPT09IGV4cGVjdGVkVHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgLy8gZm9yIHByaW1pdGl2ZSB3cmFwcGVyIG9iamVjdHNcbiAgICAgIGlmICghdmFsaWQgJiYgdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdPYmplY3QnKSB7XG4gICAgICB2YWxpZCA9IGlzUGxhaW5PYmplY3QodmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnQXJyYXknKSB7XG4gICAgICB2YWxpZCA9IEFycmF5LmlzQXJyYXkodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbGlkOiB2YWxpZCxcbiAgICAgIGV4cGVjdGVkVHlwZTogZXhwZWN0ZWRUeXBlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVzZSBmdW5jdGlvbiBzdHJpbmcgbmFtZSB0byBjaGVjayBidWlsdC1pbiB0eXBlcyxcbiAgICogYmVjYXVzZSBhIHNpbXBsZSBlcXVhbGl0eSBjaGVjayB3aWxsIGZhaWwgd2hlbiBydW5uaW5nXG4gICAqIGFjcm9zcyBkaWZmZXJlbnQgdm1zIC8gaWZyYW1lcy5cbiAgICovXG4gIGZ1bmN0aW9uIGdldFR5cGUgKGZuKSB7XG4gICAgdmFyIG1hdGNoID0gZm4gJiYgZm4udG9TdHJpbmcoKS5tYXRjaCgvXlxccypmdW5jdGlvbiAoXFx3KykvKTtcbiAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6ICcnXG4gIH1cblxuICBmdW5jdGlvbiBpc1NhbWVUeXBlIChhLCBiKSB7XG4gICAgcmV0dXJuIGdldFR5cGUoYSkgPT09IGdldFR5cGUoYilcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFR5cGVJbmRleCAodHlwZSwgZXhwZWN0ZWRUeXBlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFR5cGVzKSkge1xuICAgICAgcmV0dXJuIGlzU2FtZVR5cGUoZXhwZWN0ZWRUeXBlcywgdHlwZSkgPyAwIDogLTFcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGV4cGVjdGVkVHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChpc1NhbWVUeXBlKGV4cGVjdGVkVHlwZXNbaV0sIHR5cGUpKSB7XG4gICAgICAgIHJldHVybiBpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SW52YWxpZFR5cGVNZXNzYWdlIChuYW1lLCB2YWx1ZSwgZXhwZWN0ZWRUeXBlcykge1xuICAgIHZhciBtZXNzYWdlID0gXCJJbnZhbGlkIHByb3A6IHR5cGUgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIuXCIgK1xuICAgICAgXCIgRXhwZWN0ZWQgXCIgKyAoZXhwZWN0ZWRUeXBlcy5tYXAoY2FwaXRhbGl6ZSkuam9pbignLCAnKSk7XG4gICAgdmFyIGV4cGVjdGVkVHlwZSA9IGV4cGVjdGVkVHlwZXNbMF07XG4gICAgdmFyIHJlY2VpdmVkVHlwZSA9IHRvUmF3VHlwZSh2YWx1ZSk7XG4gICAgdmFyIGV4cGVjdGVkVmFsdWUgPSBzdHlsZVZhbHVlKHZhbHVlLCBleHBlY3RlZFR5cGUpO1xuICAgIHZhciByZWNlaXZlZFZhbHVlID0gc3R5bGVWYWx1ZSh2YWx1ZSwgcmVjZWl2ZWRUeXBlKTtcbiAgICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIHNwZWNpZnkgZXhwZWN0ZWQgdmFsdWVcbiAgICBpZiAoZXhwZWN0ZWRUeXBlcy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgaXNFeHBsaWNhYmxlKGV4cGVjdGVkVHlwZSkgJiZcbiAgICAgICAgIWlzQm9vbGVhbihleHBlY3RlZFR5cGUsIHJlY2VpdmVkVHlwZSkpIHtcbiAgICAgIG1lc3NhZ2UgKz0gXCIgd2l0aCB2YWx1ZSBcIiArIGV4cGVjdGVkVmFsdWU7XG4gICAgfVxuICAgIG1lc3NhZ2UgKz0gXCIsIGdvdCBcIiArIHJlY2VpdmVkVHlwZSArIFwiIFwiO1xuICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gc3BlY2lmeSByZWNlaXZlZCB2YWx1ZVxuICAgIGlmIChpc0V4cGxpY2FibGUocmVjZWl2ZWRUeXBlKSkge1xuICAgICAgbWVzc2FnZSArPSBcIndpdGggdmFsdWUgXCIgKyByZWNlaXZlZFZhbHVlICsgXCIuXCI7XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlXG4gIH1cblxuICBmdW5jdGlvbiBzdHlsZVZhbHVlICh2YWx1ZSwgdHlwZSkge1xuICAgIGlmICh0eXBlID09PSAnU3RyaW5nJykge1xuICAgICAgcmV0dXJuIChcIlxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnTnVtYmVyJykge1xuICAgICAgcmV0dXJuIChcIlwiICsgKE51bWJlcih2YWx1ZSkpKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKFwiXCIgKyB2YWx1ZSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc0V4cGxpY2FibGUgKHZhbHVlKSB7XG4gICAgdmFyIGV4cGxpY2l0VHlwZXMgPSBbJ3N0cmluZycsICdudW1iZXInLCAnYm9vbGVhbiddO1xuICAgIHJldHVybiBleHBsaWNpdFR5cGVzLnNvbWUoZnVuY3Rpb24gKGVsZW0pIHsgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IGVsZW07IH0pXG4gIH1cblxuICBmdW5jdGlvbiBpc0Jvb2xlYW4gKCkge1xuICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgIHJldHVybiBhcmdzLnNvbWUoZnVuY3Rpb24gKGVsZW0pIHsgcmV0dXJuIGVsZW0udG9Mb3dlckNhc2UoKSA9PT0gJ2Jvb2xlYW4nOyB9KVxuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gaGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgICAvLyBEZWFjdGl2YXRlIGRlcHMgdHJhY2tpbmcgd2hpbGUgcHJvY2Vzc2luZyBlcnJvciBoYW5kbGVyIHRvIGF2b2lkIHBvc3NpYmxlIGluZmluaXRlIHJlbmRlcmluZy5cbiAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWV4L2lzc3Vlcy8xNTA1XG4gICAgcHVzaFRhcmdldCgpO1xuICAgIHRyeSB7XG4gICAgICBpZiAodm0pIHtcbiAgICAgICAgdmFyIGN1ciA9IHZtO1xuICAgICAgICB3aGlsZSAoKGN1ciA9IGN1ci4kcGFyZW50KSkge1xuICAgICAgICAgIHZhciBob29rcyA9IGN1ci4kb3B0aW9ucy5lcnJvckNhcHR1cmVkO1xuICAgICAgICAgIGlmIChob29rcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBjYXB0dXJlID0gaG9va3NbaV0uY2FsbChjdXIsIGVyciwgdm0sIGluZm8pID09PSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoY2FwdHVyZSkgeyByZXR1cm4gfVxuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZ2xvYmFsSGFuZGxlRXJyb3IoZSwgY3VyLCAnZXJyb3JDYXB0dXJlZCBob29rJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGdsb2JhbEhhbmRsZUVycm9yKGVyciwgdm0sIGluZm8pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBwb3BUYXJnZXQoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyAoXG4gICAgaGFuZGxlcixcbiAgICBjb250ZXh0LFxuICAgIGFyZ3MsXG4gICAgdm0sXG4gICAgaW5mb1xuICApIHtcbiAgICB2YXIgcmVzO1xuICAgIHRyeSB7XG4gICAgICByZXMgPSBhcmdzID8gaGFuZGxlci5hcHBseShjb250ZXh0LCBhcmdzKSA6IGhhbmRsZXIuY2FsbChjb250ZXh0KTtcbiAgICAgIGlmIChyZXMgJiYgIXJlcy5faXNWdWUgJiYgaXNQcm9taXNlKHJlcykgJiYgIXJlcy5faGFuZGxlZCkge1xuICAgICAgICByZXMuY2F0Y2goZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGhhbmRsZUVycm9yKGUsIHZtLCBpbmZvICsgXCIgKFByb21pc2UvYXN5bmMpXCIpOyB9KTtcbiAgICAgICAgLy8gaXNzdWUgIzk1MTFcbiAgICAgICAgLy8gYXZvaWQgY2F0Y2ggdHJpZ2dlcmluZyBtdWx0aXBsZSB0aW1lcyB3aGVuIG5lc3RlZCBjYWxsc1xuICAgICAgICByZXMuX2hhbmRsZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBpbmZvKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgZnVuY3Rpb24gZ2xvYmFsSGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgICBpZiAoY29uZmlnLmVycm9ySGFuZGxlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZy5lcnJvckhhbmRsZXIuY2FsbChudWxsLCBlcnIsIHZtLCBpbmZvKVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBpZiB0aGUgdXNlciBpbnRlbnRpb25hbGx5IHRocm93cyB0aGUgb3JpZ2luYWwgZXJyb3IgaW4gdGhlIGhhbmRsZXIsXG4gICAgICAgIC8vIGRvIG5vdCBsb2cgaXQgdHdpY2VcbiAgICAgICAgaWYgKGUgIT09IGVycikge1xuICAgICAgICAgIGxvZ0Vycm9yKGUsIG51bGwsICdjb25maWcuZXJyb3JIYW5kbGVyJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbG9nRXJyb3IoZXJyLCB2bSwgaW5mbyk7XG4gIH1cblxuICBmdW5jdGlvbiBsb2dFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICAgIHtcbiAgICAgIHdhcm4oKFwiRXJyb3IgaW4gXCIgKyBpbmZvICsgXCI6IFxcXCJcIiArIChlcnIudG9TdHJpbmcoKSkgKyBcIlxcXCJcIiksIHZtKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoKGluQnJvd3NlciB8fCBpbldlZXgpICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICB2YXIgaXNVc2luZ01pY3JvVGFzayA9IGZhbHNlO1xuXG4gIHZhciBjYWxsYmFja3MgPSBbXTtcbiAgdmFyIHBlbmRpbmcgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBmbHVzaENhbGxiYWNrcyAoKSB7XG4gICAgcGVuZGluZyA9IGZhbHNlO1xuICAgIHZhciBjb3BpZXMgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gICAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3BpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvcGllc1tpXSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEhlcmUgd2UgaGF2ZSBhc3luYyBkZWZlcnJpbmcgd3JhcHBlcnMgdXNpbmcgbWljcm90YXNrcy5cbiAgLy8gSW4gMi41IHdlIHVzZWQgKG1hY3JvKSB0YXNrcyAoaW4gY29tYmluYXRpb24gd2l0aCBtaWNyb3Rhc2tzKS5cbiAgLy8gSG93ZXZlciwgaXQgaGFzIHN1YnRsZSBwcm9ibGVtcyB3aGVuIHN0YXRlIGlzIGNoYW5nZWQgcmlnaHQgYmVmb3JlIHJlcGFpbnRcbiAgLy8gKGUuZy4gIzY4MTMsIG91dC1pbiB0cmFuc2l0aW9ucykuXG4gIC8vIEFsc28sIHVzaW5nIChtYWNybykgdGFza3MgaW4gZXZlbnQgaGFuZGxlciB3b3VsZCBjYXVzZSBzb21lIHdlaXJkIGJlaGF2aW9yc1xuICAvLyB0aGF0IGNhbm5vdCBiZSBjaXJjdW12ZW50ZWQgKGUuZy4gIzcxMDksICM3MTUzLCAjNzU0NiwgIzc4MzQsICM4MTA5KS5cbiAgLy8gU28gd2Ugbm93IHVzZSBtaWNyb3Rhc2tzIGV2ZXJ5d2hlcmUsIGFnYWluLlxuICAvLyBBIG1ham9yIGRyYXdiYWNrIG9mIHRoaXMgdHJhZGVvZmYgaXMgdGhhdCB0aGVyZSBhcmUgc29tZSBzY2VuYXJpb3NcbiAgLy8gd2hlcmUgbWljcm90YXNrcyBoYXZlIHRvbyBoaWdoIGEgcHJpb3JpdHkgYW5kIGZpcmUgaW4gYmV0d2VlbiBzdXBwb3NlZGx5XG4gIC8vIHNlcXVlbnRpYWwgZXZlbnRzIChlLmcuICM0NTIxLCAjNjY5MCwgd2hpY2ggaGF2ZSB3b3JrYXJvdW5kcylcbiAgLy8gb3IgZXZlbiBiZXR3ZWVuIGJ1YmJsaW5nIG9mIHRoZSBzYW1lIGV2ZW50ICgjNjU2NikuXG4gIHZhciB0aW1lckZ1bmM7XG5cbiAgLy8gVGhlIG5leHRUaWNrIGJlaGF2aW9yIGxldmVyYWdlcyB0aGUgbWljcm90YXNrIHF1ZXVlLCB3aGljaCBjYW4gYmUgYWNjZXNzZWRcbiAgLy8gdmlhIGVpdGhlciBuYXRpdmUgUHJvbWlzZS50aGVuIG9yIE11dGF0aW9uT2JzZXJ2ZXIuXG4gIC8vIE11dGF0aW9uT2JzZXJ2ZXIgaGFzIHdpZGVyIHN1cHBvcnQsIGhvd2V2ZXIgaXQgaXMgc2VyaW91c2x5IGJ1Z2dlZCBpblxuICAvLyBVSVdlYlZpZXcgaW4gaU9TID49IDkuMy4zIHdoZW4gdHJpZ2dlcmVkIGluIHRvdWNoIGV2ZW50IGhhbmRsZXJzLiBJdFxuICAvLyBjb21wbGV0ZWx5IHN0b3BzIHdvcmtpbmcgYWZ0ZXIgdHJpZ2dlcmluZyBhIGZldyB0aW1lcy4uLiBzbywgaWYgbmF0aXZlXG4gIC8vIFByb21pc2UgaXMgYXZhaWxhYmxlLCB3ZSB3aWxsIHVzZSBpdDpcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQsICRmbG93LWRpc2FibGUtbGluZSAqL1xuICBpZiAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb21pc2UpKSB7XG4gICAgdmFyIHAgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwLnRoZW4oZmx1c2hDYWxsYmFja3MpO1xuICAgICAgLy8gSW4gcHJvYmxlbWF0aWMgVUlXZWJWaWV3cywgUHJvbWlzZS50aGVuIGRvZXNuJ3QgY29tcGxldGVseSBicmVhaywgYnV0XG4gICAgICAvLyBpdCBjYW4gZ2V0IHN0dWNrIGluIGEgd2VpcmQgc3RhdGUgd2hlcmUgY2FsbGJhY2tzIGFyZSBwdXNoZWQgaW50byB0aGVcbiAgICAgIC8vIG1pY3JvdGFzayBxdWV1ZSBidXQgdGhlIHF1ZXVlIGlzbid0IGJlaW5nIGZsdXNoZWQsIHVudGlsIHRoZSBicm93c2VyXG4gICAgICAvLyBuZWVkcyB0byBkbyBzb21lIG90aGVyIHdvcmssIGUuZy4gaGFuZGxlIGEgdGltZXIuIFRoZXJlZm9yZSB3ZSBjYW5cbiAgICAgIC8vIFwiZm9yY2VcIiB0aGUgbWljcm90YXNrIHF1ZXVlIHRvIGJlIGZsdXNoZWQgYnkgYWRkaW5nIGFuIGVtcHR5IHRpbWVyLlxuICAgICAgaWYgKGlzSU9TKSB7IHNldFRpbWVvdXQobm9vcCk7IH1cbiAgICB9O1xuICAgIGlzVXNpbmdNaWNyb1Rhc2sgPSB0cnVlO1xuICB9IGVsc2UgaWYgKCFpc0lFICYmIHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJyAmJiAoXG4gICAgaXNOYXRpdmUoTXV0YXRpb25PYnNlcnZlcikgfHxcbiAgICAvLyBQaGFudG9tSlMgYW5kIGlPUyA3LnhcbiAgICBNdXRhdGlvbk9ic2VydmVyLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE11dGF0aW9uT2JzZXJ2ZXJDb25zdHJ1Y3Rvcl0nXG4gICkpIHtcbiAgICAvLyBVc2UgTXV0YXRpb25PYnNlcnZlciB3aGVyZSBuYXRpdmUgUHJvbWlzZSBpcyBub3QgYXZhaWxhYmxlLFxuICAgIC8vIGUuZy4gUGhhbnRvbUpTLCBpT1M3LCBBbmRyb2lkIDQuNFxuICAgIC8vICgjNjQ2NiBNdXRhdGlvbk9ic2VydmVyIGlzIHVucmVsaWFibGUgaW4gSUUxMSlcbiAgICB2YXIgY291bnRlciA9IDE7XG4gICAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZmx1c2hDYWxsYmFja3MpO1xuICAgIHZhciB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFN0cmluZyhjb3VudGVyKSk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0ZXh0Tm9kZSwge1xuICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZVxuICAgIH0pO1xuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvdW50ZXIgPSAoY291bnRlciArIDEpICUgMjtcbiAgICAgIHRleHROb2RlLmRhdGEgPSBTdHJpbmcoY291bnRlcik7XG4gICAgfTtcbiAgICBpc1VzaW5nTWljcm9UYXNrID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShzZXRJbW1lZGlhdGUpKSB7XG4gICAgLy8gRmFsbGJhY2sgdG8gc2V0SW1tZWRpYXRlLlxuICAgIC8vIFRlY2hpbmljYWxseSBpdCBsZXZlcmFnZXMgdGhlIChtYWNybykgdGFzayBxdWV1ZSxcbiAgICAvLyBidXQgaXQgaXMgc3RpbGwgYSBiZXR0ZXIgY2hvaWNlIHRoYW4gc2V0VGltZW91dC5cbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzZXRJbW1lZGlhdGUoZmx1c2hDYWxsYmFja3MpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2sgdG8gc2V0VGltZW91dC5cbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzZXRUaW1lb3V0KGZsdXNoQ2FsbGJhY2tzLCAwKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbmV4dFRpY2sgKGNiLCBjdHgpIHtcbiAgICB2YXIgX3Jlc29sdmU7XG4gICAgY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2IuY2FsbChjdHgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgY3R4LCAnbmV4dFRpY2snKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChfcmVzb2x2ZSkge1xuICAgICAgICBfcmVzb2x2ZShjdHgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghcGVuZGluZykge1xuICAgICAgcGVuZGluZyA9IHRydWU7XG4gICAgICB0aW1lckZ1bmMoKTtcbiAgICB9XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgaWYgKCFjYiAmJiB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIHZhciBtYXJrO1xuICB2YXIgbWVhc3VyZTtcblxuICB7XG4gICAgdmFyIHBlcmYgPSBpbkJyb3dzZXIgJiYgd2luZG93LnBlcmZvcm1hbmNlO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChcbiAgICAgIHBlcmYgJiZcbiAgICAgIHBlcmYubWFyayAmJlxuICAgICAgcGVyZi5tZWFzdXJlICYmXG4gICAgICBwZXJmLmNsZWFyTWFya3MgJiZcbiAgICAgIHBlcmYuY2xlYXJNZWFzdXJlc1xuICAgICkge1xuICAgICAgbWFyayA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHBlcmYubWFyayh0YWcpOyB9O1xuICAgICAgbWVhc3VyZSA9IGZ1bmN0aW9uIChuYW1lLCBzdGFydFRhZywgZW5kVGFnKSB7XG4gICAgICAgIHBlcmYubWVhc3VyZShuYW1lLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICAgICAgcGVyZi5jbGVhck1hcmtzKHN0YXJ0VGFnKTtcbiAgICAgICAgcGVyZi5jbGVhck1hcmtzKGVuZFRhZyk7XG4gICAgICAgIC8vIHBlcmYuY2xlYXJNZWFzdXJlcyhuYW1lKVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGggUHJveHkgKi9cblxuICB2YXIgaW5pdFByb3h5O1xuXG4gIHtcbiAgICB2YXIgYWxsb3dlZEdsb2JhbHMgPSBtYWtlTWFwKFxuICAgICAgJ0luZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4sJyArXG4gICAgICAncGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsJyArXG4gICAgICAnTWF0aCxOdW1iZXIsRGF0ZSxBcnJheSxPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLCcgK1xuICAgICAgJ3JlcXVpcmUnIC8vIGZvciBXZWJwYWNrL0Jyb3dzZXJpZnlcbiAgICApO1xuXG4gICAgdmFyIHdhcm5Ob25QcmVzZW50ID0gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIlByb3BlcnR5IG9yIG1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgbm90IGRlZmluZWQgb24gdGhlIGluc3RhbmNlIGJ1dCBcIiArXG4gICAgICAgICdyZWZlcmVuY2VkIGR1cmluZyByZW5kZXIuIE1ha2Ugc3VyZSB0aGF0IHRoaXMgcHJvcGVydHkgaXMgcmVhY3RpdmUsICcgK1xuICAgICAgICAnZWl0aGVyIGluIHRoZSBkYXRhIG9wdGlvbiwgb3IgZm9yIGNsYXNzLWJhc2VkIGNvbXBvbmVudHMsIGJ5ICcgK1xuICAgICAgICAnaW5pdGlhbGl6aW5nIHRoZSBwcm9wZXJ0eS4gJyArXG4gICAgICAgICdTZWU6IGh0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL3JlYWN0aXZpdHkuaHRtbCNEZWNsYXJpbmctUmVhY3RpdmUtUHJvcGVydGllcy4nLFxuICAgICAgICB0YXJnZXRcbiAgICAgICk7XG4gICAgfTtcblxuICAgIHZhciB3YXJuUmVzZXJ2ZWRQcmVmaXggPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiUHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIG11c3QgYmUgYWNjZXNzZWQgd2l0aCBcXFwiJGRhdGEuXCIgKyBrZXkgKyBcIlxcXCIgYmVjYXVzZSBcIiArXG4gICAgICAgICdwcm9wZXJ0aWVzIHN0YXJ0aW5nIHdpdGggXCIkXCIgb3IgXCJfXCIgYXJlIG5vdCBwcm94aWVkIGluIHRoZSBWdWUgaW5zdGFuY2UgdG8gJyArXG4gICAgICAgICdwcmV2ZW50IGNvbmZsaWN0cyB3aXRoIFZ1ZSBpbnRlcm5hbHMnICtcbiAgICAgICAgJ1NlZTogaHR0cHM6Ly92dWVqcy5vcmcvdjIvYXBpLyNkYXRhJyxcbiAgICAgICAgdGFyZ2V0XG4gICAgICApO1xuICAgIH07XG5cbiAgICB2YXIgaGFzUHJveHkgPVxuICAgICAgdHlwZW9mIFByb3h5ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm94eSk7XG5cbiAgICBpZiAoaGFzUHJveHkpIHtcbiAgICAgIHZhciBpc0J1aWx0SW5Nb2RpZmllciA9IG1ha2VNYXAoJ3N0b3AscHJldmVudCxzZWxmLGN0cmwsc2hpZnQsYWx0LG1ldGEsZXhhY3QnKTtcbiAgICAgIGNvbmZpZy5rZXlDb2RlcyA9IG5ldyBQcm94eShjb25maWcua2V5Q29kZXMsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgICAgICAgIGlmIChpc0J1aWx0SW5Nb2RpZmllcihrZXkpKSB7XG4gICAgICAgICAgICB3YXJuKChcIkF2b2lkIG92ZXJ3cml0aW5nIGJ1aWx0LWluIG1vZGlmaWVyIGluIGNvbmZpZy5rZXlDb2RlczogLlwiICsga2V5KSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgaGFzSGFuZGxlciA9IHtcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzICh0YXJnZXQsIGtleSkge1xuICAgICAgICB2YXIgaGFzID0ga2V5IGluIHRhcmdldDtcbiAgICAgICAgdmFyIGlzQWxsb3dlZCA9IGFsbG93ZWRHbG9iYWxzKGtleSkgfHxcbiAgICAgICAgICAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYga2V5LmNoYXJBdCgwKSA9PT0gJ18nICYmICEoa2V5IGluIHRhcmdldC4kZGF0YSkpO1xuICAgICAgICBpZiAoIWhhcyAmJiAhaXNBbGxvd2VkKSB7XG4gICAgICAgICAgaWYgKGtleSBpbiB0YXJnZXQuJGRhdGEpIHsgd2FyblJlc2VydmVkUHJlZml4KHRhcmdldCwga2V5KTsgfVxuICAgICAgICAgIGVsc2UgeyB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFzIHx8ICFpc0FsbG93ZWRcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGdldEhhbmRsZXIgPSB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCAodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmICEoa2V5IGluIHRhcmdldCkpIHtcbiAgICAgICAgICBpZiAoa2V5IGluIHRhcmdldC4kZGF0YSkgeyB3YXJuUmVzZXJ2ZWRQcmVmaXgodGFyZ2V0LCBrZXkpOyB9XG4gICAgICAgICAgZWxzZSB7IHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXRba2V5XVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpbml0UHJveHkgPSBmdW5jdGlvbiBpbml0UHJveHkgKHZtKSB7XG4gICAgICBpZiAoaGFzUHJveHkpIHtcbiAgICAgICAgLy8gZGV0ZXJtaW5lIHdoaWNoIHByb3h5IGhhbmRsZXIgdG8gdXNlXG4gICAgICAgIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gICAgICAgIHZhciBoYW5kbGVycyA9IG9wdGlvbnMucmVuZGVyICYmIG9wdGlvbnMucmVuZGVyLl93aXRoU3RyaXBwZWRcbiAgICAgICAgICA/IGdldEhhbmRsZXJcbiAgICAgICAgICA6IGhhc0hhbmRsZXI7XG4gICAgICAgIHZtLl9yZW5kZXJQcm94eSA9IG5ldyBQcm94eSh2bSwgaGFuZGxlcnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qICAqL1xuXG4gIHZhciBzZWVuT2JqZWN0cyA9IG5ldyBfU2V0KCk7XG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIGFuIG9iamVjdCB0byBldm9rZSBhbGwgY29udmVydGVkXG4gICAqIGdldHRlcnMsIHNvIHRoYXQgZXZlcnkgbmVzdGVkIHByb3BlcnR5IGluc2lkZSB0aGUgb2JqZWN0XG4gICAqIGlzIGNvbGxlY3RlZCBhcyBhIFwiZGVlcFwiIGRlcGVuZGVuY3kuXG4gICAqL1xuICBmdW5jdGlvbiB0cmF2ZXJzZSAodmFsKSB7XG4gICAgX3RyYXZlcnNlKHZhbCwgc2Vlbk9iamVjdHMpO1xuICAgIHNlZW5PYmplY3RzLmNsZWFyKCk7XG4gIH1cblxuICBmdW5jdGlvbiBfdHJhdmVyc2UgKHZhbCwgc2Vlbikge1xuICAgIHZhciBpLCBrZXlzO1xuICAgIHZhciBpc0EgPSBBcnJheS5pc0FycmF5KHZhbCk7XG4gICAgaWYgKCghaXNBICYmICFpc09iamVjdCh2YWwpKSB8fCBPYmplY3QuaXNGcm96ZW4odmFsKSB8fCB2YWwgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICh2YWwuX19vYl9fKSB7XG4gICAgICB2YXIgZGVwSWQgPSB2YWwuX19vYl9fLmRlcC5pZDtcbiAgICAgIGlmIChzZWVuLmhhcyhkZXBJZCkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBzZWVuLmFkZChkZXBJZCk7XG4gICAgfVxuICAgIGlmIChpc0EpIHtcbiAgICAgIGkgPSB2YWwubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2ldLCBzZWVuKTsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHsgX3RyYXZlcnNlKHZhbFtrZXlzW2ldXSwgc2Vlbik7IH1cbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICB2YXIgbm9ybWFsaXplRXZlbnQgPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgcGFzc2l2ZSA9IG5hbWUuY2hhckF0KDApID09PSAnJic7XG4gICAgbmFtZSA9IHBhc3NpdmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgICB2YXIgb25jZSQkMSA9IG5hbWUuY2hhckF0KDApID09PSAnfic7IC8vIFByZWZpeGVkIGxhc3QsIGNoZWNrZWQgZmlyc3RcbiAgICBuYW1lID0gb25jZSQkMSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICAgIHZhciBjYXB0dXJlID0gbmFtZS5jaGFyQXQoMCkgPT09ICchJztcbiAgICBuYW1lID0gY2FwdHVyZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgb25jZTogb25jZSQkMSxcbiAgICAgIGNhcHR1cmU6IGNhcHR1cmUsXG4gICAgICBwYXNzaXZlOiBwYXNzaXZlXG4gICAgfVxuICB9KTtcblxuICBmdW5jdGlvbiBjcmVhdGVGbkludm9rZXIgKGZucywgdm0pIHtcbiAgICBmdW5jdGlvbiBpbnZva2VyICgpIHtcbiAgICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgICAgdmFyIGZucyA9IGludm9rZXIuZm5zO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZm5zKSkge1xuICAgICAgICB2YXIgY2xvbmVkID0gZm5zLnNsaWNlKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xvbmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoY2xvbmVkW2ldLCBudWxsLCBhcmd1bWVudHMkMSwgdm0sIFwidi1vbiBoYW5kbGVyXCIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZXR1cm4gaGFuZGxlciByZXR1cm4gdmFsdWUgZm9yIHNpbmdsZSBoYW5kbGVyc1xuICAgICAgICByZXR1cm4gaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoZm5zLCBudWxsLCBhcmd1bWVudHMsIHZtLCBcInYtb24gaGFuZGxlclwiKVxuICAgICAgfVxuICAgIH1cbiAgICBpbnZva2VyLmZucyA9IGZucztcbiAgICByZXR1cm4gaW52b2tlclxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlTGlzdGVuZXJzIChcbiAgICBvbixcbiAgICBvbGRPbixcbiAgICBhZGQsXG4gICAgcmVtb3ZlJCQxLFxuICAgIGNyZWF0ZU9uY2VIYW5kbGVyLFxuICAgIHZtXG4gICkge1xuICAgIHZhciBuYW1lLCBkZWYkJDEsIGN1ciwgb2xkLCBldmVudDtcbiAgICBmb3IgKG5hbWUgaW4gb24pIHtcbiAgICAgIGRlZiQkMSA9IGN1ciA9IG9uW25hbWVdO1xuICAgICAgb2xkID0gb2xkT25bbmFtZV07XG4gICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgICAgaWYgKGlzVW5kZWYoY3VyKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiSW52YWxpZCBoYW5kbGVyIGZvciBldmVudCBcXFwiXCIgKyAoZXZlbnQubmFtZSkgKyBcIlxcXCI6IGdvdCBcIiArIFN0cmluZyhjdXIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKGlzVW5kZWYob2xkKSkge1xuICAgICAgICBpZiAoaXNVbmRlZihjdXIuZm5zKSkge1xuICAgICAgICAgIGN1ciA9IG9uW25hbWVdID0gY3JlYXRlRm5JbnZva2VyKGN1ciwgdm0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1RydWUoZXZlbnQub25jZSkpIHtcbiAgICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZU9uY2VIYW5kbGVyKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQuY2FwdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQuY2FwdHVyZSwgZXZlbnQucGFzc2l2ZSwgZXZlbnQucGFyYW1zKTtcbiAgICAgIH0gZWxzZSBpZiAoY3VyICE9PSBvbGQpIHtcbiAgICAgICAgb2xkLmZucyA9IGN1cjtcbiAgICAgICAgb25bbmFtZV0gPSBvbGQ7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobmFtZSBpbiBvbGRPbikge1xuICAgICAgaWYgKGlzVW5kZWYob25bbmFtZV0pKSB7XG4gICAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgICAgIHJlbW92ZSQkMShldmVudC5uYW1lLCBvbGRPbltuYW1lXSwgZXZlbnQuY2FwdHVyZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gbWVyZ2VWTm9kZUhvb2sgKGRlZiwgaG9va0tleSwgaG9vaykge1xuICAgIGlmIChkZWYgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgICAgZGVmID0gZGVmLmRhdGEuaG9vayB8fCAoZGVmLmRhdGEuaG9vayA9IHt9KTtcbiAgICB9XG4gICAgdmFyIGludm9rZXI7XG4gICAgdmFyIG9sZEhvb2sgPSBkZWZbaG9va0tleV07XG5cbiAgICBmdW5jdGlvbiB3cmFwcGVkSG9vayAoKSB7XG4gICAgICBob29rLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAvLyBpbXBvcnRhbnQ6IHJlbW92ZSBtZXJnZWQgaG9vayB0byBlbnN1cmUgaXQncyBjYWxsZWQgb25seSBvbmNlXG4gICAgICAvLyBhbmQgcHJldmVudCBtZW1vcnkgbGVha1xuICAgICAgcmVtb3ZlKGludm9rZXIuZm5zLCB3cmFwcGVkSG9vayk7XG4gICAgfVxuXG4gICAgaWYgKGlzVW5kZWYob2xkSG9vaykpIHtcbiAgICAgIC8vIG5vIGV4aXN0aW5nIGhvb2tcbiAgICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW3dyYXBwZWRIb29rXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzRGVmKG9sZEhvb2suZm5zKSAmJiBpc1RydWUob2xkSG9vay5tZXJnZWQpKSB7XG4gICAgICAgIC8vIGFscmVhZHkgYSBtZXJnZWQgaW52b2tlclxuICAgICAgICBpbnZva2VyID0gb2xkSG9vaztcbiAgICAgICAgaW52b2tlci5mbnMucHVzaCh3cmFwcGVkSG9vayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBleGlzdGluZyBwbGFpbiBob29rXG4gICAgICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW29sZEhvb2ssIHdyYXBwZWRIb29rXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW52b2tlci5tZXJnZWQgPSB0cnVlO1xuICAgIGRlZltob29rS2V5XSA9IGludm9rZXI7XG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhIChcbiAgICBkYXRhLFxuICAgIEN0b3IsXG4gICAgdGFnXG4gICkge1xuICAgIC8vIHdlIGFyZSBvbmx5IGV4dHJhY3RpbmcgcmF3IHZhbHVlcyBoZXJlLlxuICAgIC8vIHZhbGlkYXRpb24gYW5kIGRlZmF1bHQgdmFsdWVzIGFyZSBoYW5kbGVkIGluIHRoZSBjaGlsZFxuICAgIC8vIGNvbXBvbmVudCBpdHNlbGYuXG4gICAgdmFyIHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xuICAgIGlmIChpc1VuZGVmKHByb3BPcHRpb25zKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciByZXMgPSB7fTtcbiAgICB2YXIgYXR0cnMgPSBkYXRhLmF0dHJzO1xuICAgIHZhciBwcm9wcyA9IGRhdGEucHJvcHM7XG4gICAgaWYgKGlzRGVmKGF0dHJzKSB8fCBpc0RlZihwcm9wcykpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgICB2YXIgYWx0S2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIga2V5SW5Mb3dlckNhc2UgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBrZXkgIT09IGtleUluTG93ZXJDYXNlICYmXG4gICAgICAgICAgICBhdHRycyAmJiBoYXNPd24oYXR0cnMsIGtleUluTG93ZXJDYXNlKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdGlwKFxuICAgICAgICAgICAgICBcIlByb3AgXFxcIlwiICsga2V5SW5Mb3dlckNhc2UgKyBcIlxcXCIgaXMgcGFzc2VkIHRvIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgICAgIChmb3JtYXRDb21wb25lbnROYW1lKHRhZyB8fCBDdG9yKSkgKyBcIiwgYnV0IHRoZSBkZWNsYXJlZCBwcm9wIG5hbWUgaXNcIiArXG4gICAgICAgICAgICAgIFwiIFxcXCJcIiArIGtleSArIFwiXFxcIi4gXCIgK1xuICAgICAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIGNhbWVsQ2FzZWQgXCIgK1xuICAgICAgICAgICAgICBcInByb3BzIG5lZWQgdG8gdXNlIHRoZWlyIGtlYmFiLWNhc2UgZXF1aXZhbGVudHMgd2hlbiB1c2luZyBpbi1ET00gXCIgK1xuICAgICAgICAgICAgICBcInRlbXBsYXRlcy4gWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgYWx0S2V5ICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaGVja1Byb3AocmVzLCBwcm9wcywga2V5LCBhbHRLZXksIHRydWUpIHx8XG4gICAgICAgIGNoZWNrUHJvcChyZXMsIGF0dHJzLCBrZXksIGFsdEtleSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cblxuICBmdW5jdGlvbiBjaGVja1Byb3AgKFxuICAgIHJlcyxcbiAgICBoYXNoLFxuICAgIGtleSxcbiAgICBhbHRLZXksXG4gICAgcHJlc2VydmVcbiAgKSB7XG4gICAgaWYgKGlzRGVmKGhhc2gpKSB7XG4gICAgICBpZiAoaGFzT3duKGhhc2gsIGtleSkpIHtcbiAgICAgICAgcmVzW2tleV0gPSBoYXNoW2tleV07XG4gICAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgICBkZWxldGUgaGFzaFtrZXldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9IGVsc2UgaWYgKGhhc093bihoYXNoLCBhbHRLZXkpKSB7XG4gICAgICAgIHJlc1trZXldID0gaGFzaFthbHRLZXldO1xuICAgICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgICAgZGVsZXRlIGhhc2hbYWx0S2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qICAqL1xuXG4gIC8vIFRoZSB0ZW1wbGF0ZSBjb21waWxlciBhdHRlbXB0cyB0byBtaW5pbWl6ZSB0aGUgbmVlZCBmb3Igbm9ybWFsaXphdGlvbiBieVxuICAvLyBzdGF0aWNhbGx5IGFuYWx5emluZyB0aGUgdGVtcGxhdGUgYXQgY29tcGlsZSB0aW1lLlxuICAvL1xuICAvLyBGb3IgcGxhaW4gSFRNTCBtYXJrdXAsIG5vcm1hbGl6YXRpb24gY2FuIGJlIGNvbXBsZXRlbHkgc2tpcHBlZCBiZWNhdXNlIHRoZVxuICAvLyBnZW5lcmF0ZWQgcmVuZGVyIGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gcmV0dXJuIEFycmF5PFZOb2RlPi4gVGhlcmUgYXJlXG4gIC8vIHR3byBjYXNlcyB3aGVyZSBleHRyYSBub3JtYWxpemF0aW9uIGlzIG5lZWRlZDpcblxuICAvLyAxLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb21wb25lbnRzIC0gYmVjYXVzZSBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gIC8vIG1heSByZXR1cm4gYW4gQXJyYXkgaW5zdGVhZCBvZiBhIHNpbmdsZSByb290LiBJbiB0aGlzIGNhc2UsIGp1c3QgYSBzaW1wbGVcbiAgLy8gbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQgLSBpZiBhbnkgY2hpbGQgaXMgYW4gQXJyYXksIHdlIGZsYXR0ZW4gdGhlIHdob2xlXG4gIC8vIHRoaW5nIHdpdGggQXJyYXkucHJvdG90eXBlLmNvbmNhdC4gSXQgaXMgZ3VhcmFudGVlZCB0byBiZSBvbmx5IDEtbGV2ZWwgZGVlcFxuICAvLyBiZWNhdXNlIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhbHJlYWR5IG5vcm1hbGl6ZSB0aGVpciBvd24gY2hpbGRyZW4uXG4gIGZ1bmN0aW9uIHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuW2ldKSkge1xuICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgY2hpbGRyZW4pXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaGlsZHJlblxuICB9XG5cbiAgLy8gMi4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29uc3RydWN0cyB0aGF0IGFsd2F5cyBnZW5lcmF0ZWQgbmVzdGVkIEFycmF5cyxcbiAgLy8gZS5nLiA8dGVtcGxhdGU+LCA8c2xvdD4sIHYtZm9yLCBvciB3aGVuIHRoZSBjaGlsZHJlbiBpcyBwcm92aWRlZCBieSB1c2VyXG4gIC8vIHdpdGggaGFuZC13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMgLyBKU1guIEluIHN1Y2ggY2FzZXMgYSBmdWxsIG5vcm1hbGl6YXRpb25cbiAgLy8gaXMgbmVlZGVkIHRvIGNhdGVyIHRvIGFsbCBwb3NzaWJsZSB0eXBlcyBvZiBjaGlsZHJlbiB2YWx1ZXMuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICAgIHJldHVybiBpc1ByaW1pdGl2ZShjaGlsZHJlbilcbiAgICAgID8gW2NyZWF0ZVRleHRWTm9kZShjaGlsZHJlbildXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pXG4gICAgICAgID8gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjaGlsZHJlbilcbiAgICAgICAgOiB1bmRlZmluZWRcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVGV4dE5vZGUgKG5vZGUpIHtcbiAgICByZXR1cm4gaXNEZWYobm9kZSkgJiYgaXNEZWYobm9kZS50ZXh0KSAmJiBpc0ZhbHNlKG5vZGUuaXNDb21tZW50KVxuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplQXJyYXlDaGlsZHJlbiAoY2hpbGRyZW4sIG5lc3RlZEluZGV4KSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIHZhciBpLCBjLCBsYXN0SW5kZXgsIGxhc3Q7XG4gICAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoaXNVbmRlZihjKSB8fCB0eXBlb2YgYyA9PT0gJ2Jvb2xlYW4nKSB7IGNvbnRpbnVlIH1cbiAgICAgIGxhc3RJbmRleCA9IHJlcy5sZW5ndGggLSAxO1xuICAgICAgbGFzdCA9IHJlc1tsYXN0SW5kZXhdO1xuICAgICAgLy8gIG5lc3RlZFxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYykpIHtcbiAgICAgICAgaWYgKGMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGMgPSBub3JtYWxpemVBcnJheUNoaWxkcmVuKGMsICgobmVzdGVkSW5kZXggfHwgJycpICsgXCJfXCIgKyBpKSk7XG4gICAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICAgIGlmIChpc1RleHROb2RlKGNbMF0pICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIChjWzBdKS50ZXh0KTtcbiAgICAgICAgICAgIGMuc2hpZnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzLnB1c2guYXBwbHkocmVzLCBjKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZShjKSkge1xuICAgICAgICBpZiAoaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgICAvLyB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgU1NSIGh5ZHJhdGlvbiBiZWNhdXNlIHRleHQgbm9kZXMgYXJlXG4gICAgICAgICAgLy8gZXNzZW50aWFsbHkgbWVyZ2VkIHdoZW4gcmVuZGVyZWQgdG8gSFRNTCBzdHJpbmdzXG4gICAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYyk7XG4gICAgICAgIH0gZWxzZSBpZiAoYyAhPT0gJycpIHtcbiAgICAgICAgICAvLyBjb252ZXJ0IHByaW1pdGl2ZSB0byB2bm9kZVxuICAgICAgICAgIHJlcy5wdXNoKGNyZWF0ZVRleHRWTm9kZShjKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1RleHROb2RlKGMpICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYy50ZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBkZWZhdWx0IGtleSBmb3IgbmVzdGVkIGFycmF5IGNoaWxkcmVuIChsaWtlbHkgZ2VuZXJhdGVkIGJ5IHYtZm9yKVxuICAgICAgICAgIGlmIChpc1RydWUoY2hpbGRyZW4uX2lzVkxpc3QpICYmXG4gICAgICAgICAgICBpc0RlZihjLnRhZykgJiZcbiAgICAgICAgICAgIGlzVW5kZWYoYy5rZXkpICYmXG4gICAgICAgICAgICBpc0RlZihuZXN0ZWRJbmRleCkpIHtcbiAgICAgICAgICAgIGMua2V5ID0gXCJfX3ZsaXN0XCIgKyBuZXN0ZWRJbmRleCArIFwiX1wiICsgaSArIFwiX19cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzLnB1c2goYyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gaW5pdFByb3ZpZGUgKHZtKSB7XG4gICAgdmFyIHByb3ZpZGUgPSB2bS4kb3B0aW9ucy5wcm92aWRlO1xuICAgIGlmIChwcm92aWRlKSB7XG4gICAgICB2bS5fcHJvdmlkZWQgPSB0eXBlb2YgcHJvdmlkZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHByb3ZpZGUuY2FsbCh2bSlcbiAgICAgICAgOiBwcm92aWRlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRJbmplY3Rpb25zICh2bSkge1xuICAgIHZhciByZXN1bHQgPSByZXNvbHZlSW5qZWN0KHZtLiRvcHRpb25zLmluamVjdCwgdm0pO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XG4gICAgICBPYmplY3Qua2V5cyhyZXN1bHQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICB7XG4gICAgICAgICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sIGtleSwgcmVzdWx0W2tleV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgIFwiQXZvaWQgbXV0YXRpbmcgYW4gaW5qZWN0ZWQgdmFsdWUgZGlyZWN0bHkgc2luY2UgdGhlIGNoYW5nZXMgd2lsbCBiZSBcIiArXG4gICAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHByb3ZpZGVkIGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICAgIFwiaW5qZWN0aW9uIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgICB2bVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZUluamVjdCAoaW5qZWN0LCB2bSkge1xuICAgIGlmIChpbmplY3QpIHtcbiAgICAgIC8vIGluamVjdCBpcyA6YW55IGJlY2F1c2UgZmxvdyBpcyBub3Qgc21hcnQgZW5vdWdoIHRvIGZpZ3VyZSBvdXQgY2FjaGVkXG4gICAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHZhciBrZXlzID0gaGFzU3ltYm9sXG4gICAgICAgID8gUmVmbGVjdC5vd25LZXlzKGluamVjdClcbiAgICAgICAgOiBPYmplY3Qua2V5cyhpbmplY3QpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgIC8vICM2NTc0IGluIGNhc2UgdGhlIGluamVjdCBvYmplY3QgaXMgb2JzZXJ2ZWQuLi5cbiAgICAgICAgaWYgKGtleSA9PT0gJ19fb2JfXycpIHsgY29udGludWUgfVxuICAgICAgICB2YXIgcHJvdmlkZUtleSA9IGluamVjdFtrZXldLmZyb207XG4gICAgICAgIHZhciBzb3VyY2UgPSB2bTtcbiAgICAgICAgd2hpbGUgKHNvdXJjZSkge1xuICAgICAgICAgIGlmIChzb3VyY2UuX3Byb3ZpZGVkICYmIGhhc093bihzb3VyY2UuX3Byb3ZpZGVkLCBwcm92aWRlS2V5KSkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBzb3VyY2UuX3Byb3ZpZGVkW3Byb3ZpZGVLZXldO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgICAgc291cmNlID0gc291cmNlLiRwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgICBpZiAoJ2RlZmF1bHQnIGluIGluamVjdFtrZXldKSB7XG4gICAgICAgICAgICB2YXIgcHJvdmlkZURlZmF1bHQgPSBpbmplY3Rba2V5XS5kZWZhdWx0O1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB0eXBlb2YgcHJvdmlkZURlZmF1bHQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgPyBwcm92aWRlRGVmYXVsdC5jYWxsKHZtKVxuICAgICAgICAgICAgICA6IHByb3ZpZGVEZWZhdWx0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3YXJuKChcIkluamVjdGlvbiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgbm90IGZvdW5kXCIpLCB2bSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cblxuXG4gIC8qKlxuICAgKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIHJhdyBjaGlsZHJlbiBWTm9kZXMgaW50byBhIHNsb3Qgb2JqZWN0LlxuICAgKi9cbiAgZnVuY3Rpb24gcmVzb2x2ZVNsb3RzIChcbiAgICBjaGlsZHJlbixcbiAgICBjb250ZXh0XG4gICkge1xuICAgIGlmICghY2hpbGRyZW4gfHwgIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHt9XG4gICAgfVxuICAgIHZhciBzbG90cyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIHZhciBkYXRhID0gY2hpbGQuZGF0YTtcbiAgICAgIC8vIHJlbW92ZSBzbG90IGF0dHJpYnV0ZSBpZiB0aGUgbm9kZSBpcyByZXNvbHZlZCBhcyBhIFZ1ZSBzbG90IG5vZGVcbiAgICAgIGlmIChkYXRhICYmIGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy5zbG90KSB7XG4gICAgICAgIGRlbGV0ZSBkYXRhLmF0dHJzLnNsb3Q7XG4gICAgICB9XG4gICAgICAvLyBuYW1lZCBzbG90cyBzaG91bGQgb25seSBiZSByZXNwZWN0ZWQgaWYgdGhlIHZub2RlIHdhcyByZW5kZXJlZCBpbiB0aGVcbiAgICAgIC8vIHNhbWUgY29udGV4dC5cbiAgICAgIGlmICgoY2hpbGQuY29udGV4dCA9PT0gY29udGV4dCB8fCBjaGlsZC5mbkNvbnRleHQgPT09IGNvbnRleHQpICYmXG4gICAgICAgIGRhdGEgJiYgZGF0YS5zbG90ICE9IG51bGxcbiAgICAgICkge1xuICAgICAgICB2YXIgbmFtZSA9IGRhdGEuc2xvdDtcbiAgICAgICAgdmFyIHNsb3QgPSAoc2xvdHNbbmFtZV0gfHwgKHNsb3RzW25hbWVdID0gW10pKTtcbiAgICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICAgIHNsb3QucHVzaC5hcHBseShzbG90LCBjaGlsZC5jaGlsZHJlbiB8fCBbXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2xvdC5wdXNoKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKHNsb3RzLmRlZmF1bHQgfHwgKHNsb3RzLmRlZmF1bHQgPSBbXSkpLnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBpZ25vcmUgc2xvdHMgdGhhdCBjb250YWlucyBvbmx5IHdoaXRlc3BhY2VcbiAgICBmb3IgKHZhciBuYW1lJDEgaW4gc2xvdHMpIHtcbiAgICAgIGlmIChzbG90c1tuYW1lJDFdLmV2ZXJ5KGlzV2hpdGVzcGFjZSkpIHtcbiAgICAgICAgZGVsZXRlIHNsb3RzW25hbWUkMV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzbG90c1xuICB9XG5cbiAgZnVuY3Rpb24gaXNXaGl0ZXNwYWNlIChub2RlKSB7XG4gICAgcmV0dXJuIChub2RlLmlzQ29tbWVudCAmJiAhbm9kZS5hc3luY0ZhY3RvcnkpIHx8IG5vZGUudGV4dCA9PT0gJyAnXG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBub3JtYWxpemVTY29wZWRTbG90cyAoXG4gICAgc2xvdHMsXG4gICAgbm9ybWFsU2xvdHMsXG4gICAgcHJldlNsb3RzXG4gICkge1xuICAgIHZhciByZXM7XG4gICAgdmFyIGhhc05vcm1hbFNsb3RzID0gT2JqZWN0LmtleXMobm9ybWFsU2xvdHMpLmxlbmd0aCA+IDA7XG4gICAgdmFyIGlzU3RhYmxlID0gc2xvdHMgPyAhIXNsb3RzLiRzdGFibGUgOiAhaGFzTm9ybWFsU2xvdHM7XG4gICAgdmFyIGtleSA9IHNsb3RzICYmIHNsb3RzLiRrZXk7XG4gICAgaWYgKCFzbG90cykge1xuICAgICAgcmVzID0ge307XG4gICAgfSBlbHNlIGlmIChzbG90cy5fbm9ybWFsaXplZCkge1xuICAgICAgLy8gZmFzdCBwYXRoIDE6IGNoaWxkIGNvbXBvbmVudCByZS1yZW5kZXIgb25seSwgcGFyZW50IGRpZCBub3QgY2hhbmdlXG4gICAgICByZXR1cm4gc2xvdHMuX25vcm1hbGl6ZWRcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgaXNTdGFibGUgJiZcbiAgICAgIHByZXZTbG90cyAmJlxuICAgICAgcHJldlNsb3RzICE9PSBlbXB0eU9iamVjdCAmJlxuICAgICAga2V5ID09PSBwcmV2U2xvdHMuJGtleSAmJlxuICAgICAgIWhhc05vcm1hbFNsb3RzICYmXG4gICAgICAhcHJldlNsb3RzLiRoYXNOb3JtYWxcbiAgICApIHtcbiAgICAgIC8vIGZhc3QgcGF0aCAyOiBzdGFibGUgc2NvcGVkIHNsb3RzIHcvIG5vIG5vcm1hbCBzbG90cyB0byBwcm94eSxcbiAgICAgIC8vIG9ubHkgbmVlZCB0byBub3JtYWxpemUgb25jZVxuICAgICAgcmV0dXJuIHByZXZTbG90c1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSB7fTtcbiAgICAgIGZvciAodmFyIGtleSQxIGluIHNsb3RzKSB7XG4gICAgICAgIGlmIChzbG90c1trZXkkMV0gJiYga2V5JDFbMF0gIT09ICckJykge1xuICAgICAgICAgIHJlc1trZXkkMV0gPSBub3JtYWxpemVTY29wZWRTbG90KG5vcm1hbFNsb3RzLCBrZXkkMSwgc2xvdHNba2V5JDFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBleHBvc2Ugbm9ybWFsIHNsb3RzIG9uIHNjb3BlZFNsb3RzXG4gICAgZm9yICh2YXIga2V5JDIgaW4gbm9ybWFsU2xvdHMpIHtcbiAgICAgIGlmICghKGtleSQyIGluIHJlcykpIHtcbiAgICAgICAgcmVzW2tleSQyXSA9IHByb3h5Tm9ybWFsU2xvdChub3JtYWxTbG90cywga2V5JDIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBhdm9yaWF6IHNlZW1zIHRvIG1vY2sgYSBub24tZXh0ZW5zaWJsZSAkc2NvcGVkU2xvdHMgb2JqZWN0XG4gICAgLy8gYW5kIHdoZW4gdGhhdCBpcyBwYXNzZWQgZG93biB0aGlzIHdvdWxkIGNhdXNlIGFuIGVycm9yXG4gICAgaWYgKHNsb3RzICYmIE9iamVjdC5pc0V4dGVuc2libGUoc2xvdHMpKSB7XG4gICAgICAoc2xvdHMpLl9ub3JtYWxpemVkID0gcmVzO1xuICAgIH1cbiAgICBkZWYocmVzLCAnJHN0YWJsZScsIGlzU3RhYmxlKTtcbiAgICBkZWYocmVzLCAnJGtleScsIGtleSk7XG4gICAgZGVmKHJlcywgJyRoYXNOb3JtYWwnLCBoYXNOb3JtYWxTbG90cyk7XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplU2NvcGVkU2xvdChub3JtYWxTbG90cywga2V5LCBmbikge1xuICAgIHZhciBub3JtYWxpemVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHJlcyA9IGFyZ3VtZW50cy5sZW5ndGggPyBmbi5hcHBseShudWxsLCBhcmd1bWVudHMpIDogZm4oe30pO1xuICAgICAgcmVzID0gcmVzICYmIHR5cGVvZiByZXMgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHJlcylcbiAgICAgICAgPyBbcmVzXSAvLyBzaW5nbGUgdm5vZGVcbiAgICAgICAgOiBub3JtYWxpemVDaGlsZHJlbihyZXMpO1xuICAgICAgcmV0dXJuIHJlcyAmJiAoXG4gICAgICAgIHJlcy5sZW5ndGggPT09IDAgfHxcbiAgICAgICAgKHJlcy5sZW5ndGggPT09IDEgJiYgcmVzWzBdLmlzQ29tbWVudCkgLy8gIzk2NThcbiAgICAgICkgPyB1bmRlZmluZWRcbiAgICAgICAgOiByZXNcbiAgICB9O1xuICAgIC8vIHRoaXMgaXMgYSBzbG90IHVzaW5nIHRoZSBuZXcgdi1zbG90IHN5bnRheCB3aXRob3V0IHNjb3BlLiBhbHRob3VnaCBpdCBpc1xuICAgIC8vIGNvbXBpbGVkIGFzIGEgc2NvcGVkIHNsb3QsIHJlbmRlciBmbiB1c2VycyB3b3VsZCBleHBlY3QgaXQgdG8gYmUgcHJlc2VudFxuICAgIC8vIG9uIHRoaXMuJHNsb3RzIGJlY2F1c2UgdGhlIHVzYWdlIGlzIHNlbWFudGljYWxseSBhIG5vcm1hbCBzbG90LlxuICAgIGlmIChmbi5wcm94eSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5vcm1hbFNsb3RzLCBrZXksIHtcbiAgICAgICAgZ2V0OiBub3JtYWxpemVkLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbm9ybWFsaXplZFxuICB9XG5cbiAgZnVuY3Rpb24gcHJveHlOb3JtYWxTbG90KHNsb3RzLCBrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gc2xvdHNba2V5XTsgfVxuICB9XG5cbiAgLyogICovXG5cbiAgLyoqXG4gICAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgdi1mb3IgbGlzdHMuXG4gICAqL1xuICBmdW5jdGlvbiByZW5kZXJMaXN0IChcbiAgICB2YWwsXG4gICAgcmVuZGVyXG4gICkge1xuICAgIHZhciByZXQsIGksIGwsIGtleXMsIGtleTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpIHx8IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXQgPSBuZXcgQXJyYXkodmFsLmxlbmd0aCk7XG4gICAgICBmb3IgKGkgPSAwLCBsID0gdmFsLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICByZXRbaV0gPSByZW5kZXIodmFsW2ldLCBpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgICByZXQgPSBuZXcgQXJyYXkodmFsKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWw7IGkrKykge1xuICAgICAgICByZXRbaV0gPSByZW5kZXIoaSArIDEsIGkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgICAgaWYgKGhhc1N5bWJvbCAmJiB2YWxbU3ltYm9sLml0ZXJhdG9yXSkge1xuICAgICAgICByZXQgPSBbXTtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gdmFsW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgd2hpbGUgKCFyZXN1bHQuZG9uZSkge1xuICAgICAgICAgIHJldC5wdXNoKHJlbmRlcihyZXN1bHQudmFsdWUsIHJldC5sZW5ndGgpKTtcbiAgICAgICAgICByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgICAgICByZXQgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxba2V5XSwga2V5LCBpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWlzRGVmKHJldCkpIHtcbiAgICAgIHJldCA9IFtdO1xuICAgIH1cbiAgICAocmV0KS5faXNWTGlzdCA9IHRydWU7XG4gICAgcmV0dXJuIHJldFxuICB9XG5cbiAgLyogICovXG5cbiAgLyoqXG4gICAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgPHNsb3Q+XG4gICAqL1xuICBmdW5jdGlvbiByZW5kZXJTbG90IChcbiAgICBuYW1lLFxuICAgIGZhbGxiYWNrLFxuICAgIHByb3BzLFxuICAgIGJpbmRPYmplY3RcbiAgKSB7XG4gICAgdmFyIHNjb3BlZFNsb3RGbiA9IHRoaXMuJHNjb3BlZFNsb3RzW25hbWVdO1xuICAgIHZhciBub2RlcztcbiAgICBpZiAoc2NvcGVkU2xvdEZuKSB7IC8vIHNjb3BlZCBzbG90XG4gICAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuICAgICAgaWYgKGJpbmRPYmplY3QpIHtcbiAgICAgICAgaWYgKCFpc09iamVjdChiaW5kT2JqZWN0KSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAnc2xvdCB2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCcsXG4gICAgICAgICAgICB0aGlzXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBwcm9wcyA9IGV4dGVuZChleHRlbmQoe30sIGJpbmRPYmplY3QpLCBwcm9wcyk7XG4gICAgICB9XG4gICAgICBub2RlcyA9IHNjb3BlZFNsb3RGbihwcm9wcykgfHwgZmFsbGJhY2s7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGVzID0gdGhpcy4kc2xvdHNbbmFtZV0gfHwgZmFsbGJhY2s7XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldCA9IHByb3BzICYmIHByb3BzLnNsb3Q7XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJywgeyBzbG90OiB0YXJnZXQgfSwgbm9kZXMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub2Rlc1xuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIC8qKlxuICAgKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIGZpbHRlcnNcbiAgICovXG4gIGZ1bmN0aW9uIHJlc29sdmVGaWx0ZXIgKGlkKSB7XG4gICAgcmV0dXJuIHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnZmlsdGVycycsIGlkLCB0cnVlKSB8fCBpZGVudGl0eVxuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gaXNLZXlOb3RNYXRjaCAoZXhwZWN0LCBhY3R1YWwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShleHBlY3QpKSB7XG4gICAgICByZXR1cm4gZXhwZWN0LmluZGV4T2YoYWN0dWFsKSA9PT0gLTFcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGV4cGVjdCAhPT0gYWN0dWFsXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJ1bnRpbWUgaGVscGVyIGZvciBjaGVja2luZyBrZXlDb2RlcyBmcm9tIGNvbmZpZy5cbiAgICogZXhwb3NlZCBhcyBWdWUucHJvdG90eXBlLl9rXG4gICAqIHBhc3NpbmcgaW4gZXZlbnRLZXlOYW1lIGFzIGxhc3QgYXJndW1lbnQgc2VwYXJhdGVseSBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICAgKi9cbiAgZnVuY3Rpb24gY2hlY2tLZXlDb2RlcyAoXG4gICAgZXZlbnRLZXlDb2RlLFxuICAgIGtleSxcbiAgICBidWlsdEluS2V5Q29kZSxcbiAgICBldmVudEtleU5hbWUsXG4gICAgYnVpbHRJbktleU5hbWVcbiAgKSB7XG4gICAgdmFyIG1hcHBlZEtleUNvZGUgPSBjb25maWcua2V5Q29kZXNba2V5XSB8fCBidWlsdEluS2V5Q29kZTtcbiAgICBpZiAoYnVpbHRJbktleU5hbWUgJiYgZXZlbnRLZXlOYW1lICYmICFjb25maWcua2V5Q29kZXNba2V5XSkge1xuICAgICAgcmV0dXJuIGlzS2V5Tm90TWF0Y2goYnVpbHRJbktleU5hbWUsIGV2ZW50S2V5TmFtZSlcbiAgICB9IGVsc2UgaWYgKG1hcHBlZEtleUNvZGUpIHtcbiAgICAgIHJldHVybiBpc0tleU5vdE1hdGNoKG1hcHBlZEtleUNvZGUsIGV2ZW50S2V5Q29kZSlcbiAgICB9IGVsc2UgaWYgKGV2ZW50S2V5TmFtZSkge1xuICAgICAgcmV0dXJuIGh5cGhlbmF0ZShldmVudEtleU5hbWUpICE9PSBrZXlcbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICAvKipcbiAgICogUnVudGltZSBoZWxwZXIgZm9yIG1lcmdpbmcgdi1iaW5kPVwib2JqZWN0XCIgaW50byBhIFZOb2RlJ3MgZGF0YS5cbiAgICovXG4gIGZ1bmN0aW9uIGJpbmRPYmplY3RQcm9wcyAoXG4gICAgZGF0YSxcbiAgICB0YWcsXG4gICAgdmFsdWUsXG4gICAgYXNQcm9wLFxuICAgIGlzU3luY1xuICApIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ3YtYmluZCB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IG9yIEFycmF5IHZhbHVlJyxcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICB2YWx1ZSA9IHRvT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGFzaDtcbiAgICAgICAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBrZXkgPT09ICdjbGFzcycgfHxcbiAgICAgICAgICAgIGtleSA9PT0gJ3N0eWxlJyB8fFxuICAgICAgICAgICAgaXNSZXNlcnZlZEF0dHJpYnV0ZShrZXkpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBoYXNoID0gZGF0YTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMudHlwZTtcbiAgICAgICAgICAgIGhhc2ggPSBhc1Byb3AgfHwgY29uZmlnLm11c3RVc2VQcm9wKHRhZywgdHlwZSwga2V5KVxuICAgICAgICAgICAgICA/IGRhdGEuZG9tUHJvcHMgfHwgKGRhdGEuZG9tUHJvcHMgPSB7fSlcbiAgICAgICAgICAgICAgOiBkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgY2FtZWxpemVkS2V5ID0gY2FtZWxpemUoa2V5KTtcbiAgICAgICAgICB2YXIgaHlwaGVuYXRlZEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgICAgIGlmICghKGNhbWVsaXplZEtleSBpbiBoYXNoKSAmJiAhKGh5cGhlbmF0ZWRLZXkgaW4gaGFzaCkpIHtcbiAgICAgICAgICAgIGhhc2hba2V5XSA9IHZhbHVlW2tleV07XG5cbiAgICAgICAgICAgIGlmIChpc1N5bmMpIHtcbiAgICAgICAgICAgICAgdmFyIG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcbiAgICAgICAgICAgICAgb25bKFwidXBkYXRlOlwiICsga2V5KV0gPSBmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFsdWVba2V5XSA9ICRldmVudDtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSBsb29wKCBrZXkgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGFcbiAgfVxuXG4gIC8qICAqL1xuXG4gIC8qKlxuICAgKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHN0YXRpYyB0cmVlcy5cbiAgICovXG4gIGZ1bmN0aW9uIHJlbmRlclN0YXRpYyAoXG4gICAgaW5kZXgsXG4gICAgaXNJbkZvclxuICApIHtcbiAgICB2YXIgY2FjaGVkID0gdGhpcy5fc3RhdGljVHJlZXMgfHwgKHRoaXMuX3N0YXRpY1RyZWVzID0gW10pO1xuICAgIHZhciB0cmVlID0gY2FjaGVkW2luZGV4XTtcbiAgICAvLyBpZiBoYXMgYWxyZWFkeS1yZW5kZXJlZCBzdGF0aWMgdHJlZSBhbmQgbm90IGluc2lkZSB2LWZvcixcbiAgICAvLyB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgdHJlZS5cbiAgICBpZiAodHJlZSAmJiAhaXNJbkZvcikge1xuICAgICAgcmV0dXJuIHRyZWVcbiAgICB9XG4gICAgLy8gb3RoZXJ3aXNlLCByZW5kZXIgYSBmcmVzaCB0cmVlLlxuICAgIHRyZWUgPSBjYWNoZWRbaW5kZXhdID0gdGhpcy4kb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnNbaW5kZXhdLmNhbGwoXG4gICAgICB0aGlzLl9yZW5kZXJQcm94eSxcbiAgICAgIG51bGwsXG4gICAgICB0aGlzIC8vIGZvciByZW5kZXIgZm5zIGdlbmVyYXRlZCBmb3IgZnVuY3Rpb25hbCBjb21wb25lbnQgdGVtcGxhdGVzXG4gICAgKTtcbiAgICBtYXJrU3RhdGljKHRyZWUsIChcIl9fc3RhdGljX19cIiArIGluZGV4KSwgZmFsc2UpO1xuICAgIHJldHVybiB0cmVlXG4gIH1cblxuICAvKipcbiAgICogUnVudGltZSBoZWxwZXIgZm9yIHYtb25jZS5cbiAgICogRWZmZWN0aXZlbHkgaXQgbWVhbnMgbWFya2luZyB0aGUgbm9kZSBhcyBzdGF0aWMgd2l0aCBhIHVuaXF1ZSBrZXkuXG4gICAqL1xuICBmdW5jdGlvbiBtYXJrT25jZSAoXG4gICAgdHJlZSxcbiAgICBpbmRleCxcbiAgICBrZXlcbiAgKSB7XG4gICAgbWFya1N0YXRpYyh0cmVlLCAoXCJfX29uY2VfX1wiICsgaW5kZXggKyAoa2V5ID8gKFwiX1wiICsga2V5KSA6IFwiXCIpKSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHRyZWVcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtTdGF0aWMgKFxuICAgIHRyZWUsXG4gICAga2V5LFxuICAgIGlzT25jZVxuICApIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmVlKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0cmVlW2ldICYmIHR5cGVvZiB0cmVlW2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIG1hcmtTdGF0aWNOb2RlKHRyZWVbaV0sIChrZXkgKyBcIl9cIiArIGkpLCBpc09uY2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hcmtTdGF0aWNOb2RlKHRyZWUsIGtleSwgaXNPbmNlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrU3RhdGljTm9kZSAobm9kZSwga2V5LCBpc09uY2UpIHtcbiAgICBub2RlLmlzU3RhdGljID0gdHJ1ZTtcbiAgICBub2RlLmtleSA9IGtleTtcbiAgICBub2RlLmlzT25jZSA9IGlzT25jZTtcbiAgfVxuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIGJpbmRPYmplY3RMaXN0ZW5lcnMgKGRhdGEsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ3Ytb24gd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCB2YWx1ZScsXG4gICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG9uID0gZGF0YS5vbiA9IGRhdGEub24gPyBleHRlbmQoe30sIGRhdGEub24pIDoge307XG4gICAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgIHZhciBleGlzdGluZyA9IG9uW2tleV07XG4gICAgICAgICAgdmFyIG91cnMgPSB2YWx1ZVtrZXldO1xuICAgICAgICAgIG9uW2tleV0gPSBleGlzdGluZyA/IFtdLmNvbmNhdChleGlzdGluZywgb3VycykgOiBvdXJzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkYXRhXG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiByZXNvbHZlU2NvcGVkU2xvdHMgKFxuICAgIGZucywgLy8gc2VlIGZsb3cvdm5vZGVcbiAgICByZXMsXG4gICAgLy8gdGhlIGZvbGxvd2luZyBhcmUgYWRkZWQgaW4gMi42XG4gICAgaGFzRHluYW1pY0tleXMsXG4gICAgY29udGVudEhhc2hLZXlcbiAgKSB7XG4gICAgcmVzID0gcmVzIHx8IHsgJHN0YWJsZTogIWhhc0R5bmFtaWNLZXlzIH07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzbG90ID0gZm5zW2ldO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2xvdCkpIHtcbiAgICAgICAgcmVzb2x2ZVNjb3BlZFNsb3RzKHNsb3QsIHJlcywgaGFzRHluYW1pY0tleXMpO1xuICAgICAgfSBlbHNlIGlmIChzbG90KSB7XG4gICAgICAgIC8vIG1hcmtlciBmb3IgcmV2ZXJzZSBwcm94eWluZyB2LXNsb3Qgd2l0aG91dCBzY29wZSBvbiB0aGlzLiRzbG90c1xuICAgICAgICBpZiAoc2xvdC5wcm94eSkge1xuICAgICAgICAgIHNsb3QuZm4ucHJveHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc1tzbG90LmtleV0gPSBzbG90LmZuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29udGVudEhhc2hLZXkpIHtcbiAgICAgIChyZXMpLiRrZXkgPSBjb250ZW50SGFzaEtleTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gYmluZER5bmFtaWNLZXlzIChiYXNlT2JqLCB2YWx1ZXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgdmFyIGtleSA9IHZhbHVlc1tpXTtcbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiBrZXkpIHtcbiAgICAgICAgYmFzZU9ialt2YWx1ZXNbaV1dID0gdmFsdWVzW2kgKyAxXTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5ICE9PSAnJyAmJiBrZXkgIT09IG51bGwpIHtcbiAgICAgICAgLy8gbnVsbCBpcyBhIHNwZWljYWwgdmFsdWUgZm9yIGV4cGxpY2l0bHkgcmVtb3ZpbmcgYSBiaW5kaW5nXG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiSW52YWxpZCB2YWx1ZSBmb3IgZHluYW1pYyBkaXJlY3RpdmUgYXJndW1lbnQgKGV4cGVjdGVkIHN0cmluZyBvciBudWxsKTogXCIgKyBrZXkpLFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJhc2VPYmpcbiAgfVxuXG4gIC8vIGhlbHBlciB0byBkeW5hbWljYWxseSBhcHBlbmQgbW9kaWZpZXIgcnVudGltZSBtYXJrZXJzIHRvIGV2ZW50IG5hbWVzLlxuICAvLyBlbnN1cmUgb25seSBhcHBlbmQgd2hlbiB2YWx1ZSBpcyBhbHJlYWR5IHN0cmluZywgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgY2FzdFxuICAvLyB0byBzdHJpbmcgYW5kIGNhdXNlIHRoZSB0eXBlIGNoZWNrIHRvIG1pc3MuXG4gIGZ1bmN0aW9uIHByZXBlbmRNb2RpZmllciAodmFsdWUsIHN5bWJvbCkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gc3ltYm9sICsgdmFsdWUgOiB2YWx1ZVxuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gaW5zdGFsbFJlbmRlckhlbHBlcnMgKHRhcmdldCkge1xuICAgIHRhcmdldC5fbyA9IG1hcmtPbmNlO1xuICAgIHRhcmdldC5fbiA9IHRvTnVtYmVyO1xuICAgIHRhcmdldC5fcyA9IHRvU3RyaW5nO1xuICAgIHRhcmdldC5fbCA9IHJlbmRlckxpc3Q7XG4gICAgdGFyZ2V0Ll90ID0gcmVuZGVyU2xvdDtcbiAgICB0YXJnZXQuX3EgPSBsb29zZUVxdWFsO1xuICAgIHRhcmdldC5faSA9IGxvb3NlSW5kZXhPZjtcbiAgICB0YXJnZXQuX20gPSByZW5kZXJTdGF0aWM7XG4gICAgdGFyZ2V0Ll9mID0gcmVzb2x2ZUZpbHRlcjtcbiAgICB0YXJnZXQuX2sgPSBjaGVja0tleUNvZGVzO1xuICAgIHRhcmdldC5fYiA9IGJpbmRPYmplY3RQcm9wcztcbiAgICB0YXJnZXQuX3YgPSBjcmVhdGVUZXh0Vk5vZGU7XG4gICAgdGFyZ2V0Ll9lID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgICB0YXJnZXQuX3UgPSByZXNvbHZlU2NvcGVkU2xvdHM7XG4gICAgdGFyZ2V0Ll9nID0gYmluZE9iamVjdExpc3RlbmVycztcbiAgICB0YXJnZXQuX2QgPSBiaW5kRHluYW1pY0tleXM7XG4gICAgdGFyZ2V0Ll9wID0gcHJlcGVuZE1vZGlmaWVyO1xuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gRnVuY3Rpb25hbFJlbmRlckNvbnRleHQgKFxuICAgIGRhdGEsXG4gICAgcHJvcHMsXG4gICAgY2hpbGRyZW4sXG4gICAgcGFyZW50LFxuICAgIEN0b3JcbiAgKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgICAvLyBlbnN1cmUgdGhlIGNyZWF0ZUVsZW1lbnQgZnVuY3Rpb24gaW4gZnVuY3Rpb25hbCBjb21wb25lbnRzXG4gICAgLy8gZ2V0cyBhIHVuaXF1ZSBjb250ZXh0IC0gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIGNvcnJlY3QgbmFtZWQgc2xvdCBjaGVja1xuICAgIHZhciBjb250ZXh0Vm07XG4gICAgaWYgKGhhc093bihwYXJlbnQsICdfdWlkJykpIHtcbiAgICAgIGNvbnRleHRWbSA9IE9iamVjdC5jcmVhdGUocGFyZW50KTtcbiAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgY29udGV4dFZtLl9vcmlnaW5hbCA9IHBhcmVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdGhlIGNvbnRleHQgdm0gcGFzc2VkIGluIGlzIGEgZnVuY3Rpb25hbCBjb250ZXh0IGFzIHdlbGwuXG4gICAgICAvLyBpbiB0aGlzIGNhc2Ugd2Ugd2FudCB0byBtYWtlIHN1cmUgd2UgYXJlIGFibGUgdG8gZ2V0IGEgaG9sZCB0byB0aGVcbiAgICAgIC8vIHJlYWwgY29udGV4dCBpbnN0YW5jZS5cbiAgICAgIGNvbnRleHRWbSA9IHBhcmVudDtcbiAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgcGFyZW50ID0gcGFyZW50Ll9vcmlnaW5hbDtcbiAgICB9XG4gICAgdmFyIGlzQ29tcGlsZWQgPSBpc1RydWUob3B0aW9ucy5fY29tcGlsZWQpO1xuICAgIHZhciBuZWVkTm9ybWFsaXphdGlvbiA9ICFpc0NvbXBpbGVkO1xuXG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMubGlzdGVuZXJzID0gZGF0YS5vbiB8fCBlbXB0eU9iamVjdDtcbiAgICB0aGlzLmluamVjdGlvbnMgPSByZXNvbHZlSW5qZWN0KG9wdGlvbnMuaW5qZWN0LCBwYXJlbnQpO1xuICAgIHRoaXMuc2xvdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMkMS4kc2xvdHMpIHtcbiAgICAgICAgbm9ybWFsaXplU2NvcGVkU2xvdHMoXG4gICAgICAgICAgZGF0YS5zY29wZWRTbG90cyxcbiAgICAgICAgICB0aGlzJDEuJHNsb3RzID0gcmVzb2x2ZVNsb3RzKGNoaWxkcmVuLCBwYXJlbnQpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcyQxLiRzbG90c1xuICAgIH07XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3Njb3BlZFNsb3RzJywgKHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgICAgIHJldHVybiBub3JtYWxpemVTY29wZWRTbG90cyhkYXRhLnNjb3BlZFNsb3RzLCB0aGlzLnNsb3RzKCkpXG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgLy8gc3VwcG9ydCBmb3IgY29tcGlsZWQgZnVuY3Rpb25hbCB0ZW1wbGF0ZVxuICAgIGlmIChpc0NvbXBpbGVkKSB7XG4gICAgICAvLyBleHBvc2luZyAkb3B0aW9ucyBmb3IgcmVuZGVyU3RhdGljKClcbiAgICAgIHRoaXMuJG9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgLy8gcHJlLXJlc29sdmUgc2xvdHMgZm9yIHJlbmRlclNsb3QoKVxuICAgICAgdGhpcy4kc2xvdHMgPSB0aGlzLnNsb3RzKCk7XG4gICAgICB0aGlzLiRzY29wZWRTbG90cyA9IG5vcm1hbGl6ZVNjb3BlZFNsb3RzKGRhdGEuc2NvcGVkU2xvdHMsIHRoaXMuJHNsb3RzKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5fc2NvcGVJZCkge1xuICAgICAgdGhpcy5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XG4gICAgICAgIHZhciB2bm9kZSA9IGNyZWF0ZUVsZW1lbnQoY29udGV4dFZtLCBhLCBiLCBjLCBkLCBuZWVkTm9ybWFsaXphdGlvbik7XG4gICAgICAgIGlmICh2bm9kZSAmJiAhQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICAgICAgICB2bm9kZS5mblNjb3BlSWQgPSBvcHRpb25zLl9zY29wZUlkO1xuICAgICAgICAgIHZub2RlLmZuQ29udGV4dCA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdm5vZGVcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudChjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTsgfTtcbiAgICB9XG4gIH1cblxuICBpbnN0YWxsUmVuZGVySGVscGVycyhGdW5jdGlvbmFsUmVuZGVyQ29udGV4dC5wcm90b3R5cGUpO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQgKFxuICAgIEN0b3IsXG4gICAgcHJvcHNEYXRhLFxuICAgIGRhdGEsXG4gICAgY29udGV4dFZtLFxuICAgIGNoaWxkcmVuXG4gICkge1xuICAgIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBwcm9wT3B0aW9ucyA9IG9wdGlvbnMucHJvcHM7XG4gICAgaWYgKGlzRGVmKHByb3BPcHRpb25zKSkge1xuICAgICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhIHx8IGVtcHR5T2JqZWN0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzRGVmKGRhdGEuYXR0cnMpKSB7IG1lcmdlUHJvcHMocHJvcHMsIGRhdGEuYXR0cnMpOyB9XG4gICAgICBpZiAoaXNEZWYoZGF0YS5wcm9wcykpIHsgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5wcm9wcyk7IH1cbiAgICB9XG5cbiAgICB2YXIgcmVuZGVyQ29udGV4dCA9IG5ldyBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dChcbiAgICAgIGRhdGEsXG4gICAgICBwcm9wcyxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgY29udGV4dFZtLFxuICAgICAgQ3RvclxuICAgICk7XG5cbiAgICB2YXIgdm5vZGUgPSBvcHRpb25zLnJlbmRlci5jYWxsKG51bGwsIHJlbmRlckNvbnRleHQuX2MsIHJlbmRlckNvbnRleHQpO1xuXG4gICAgaWYgKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICAgIHJldHVybiBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0KHZub2RlLCBkYXRhLCByZW5kZXJDb250ZXh0LnBhcmVudCwgb3B0aW9ucywgcmVuZGVyQ29udGV4dClcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgICB2YXIgdm5vZGVzID0gbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUpIHx8IFtdO1xuICAgICAgdmFyIHJlcyA9IG5ldyBBcnJheSh2bm9kZXMubGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc1tpXSA9IGNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQodm5vZGVzW2ldLCBkYXRhLCByZW5kZXJDb250ZXh0LnBhcmVudCwgb3B0aW9ucywgcmVuZGVyQ29udGV4dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCAodm5vZGUsIGRhdGEsIGNvbnRleHRWbSwgb3B0aW9ucywgcmVuZGVyQ29udGV4dCkge1xuICAgIC8vICM3ODE3IGNsb25lIG5vZGUgYmVmb3JlIHNldHRpbmcgZm5Db250ZXh0LCBvdGhlcndpc2UgaWYgdGhlIG5vZGUgaXMgcmV1c2VkXG4gICAgLy8gKGUuZy4gaXQgd2FzIGZyb20gYSBjYWNoZWQgbm9ybWFsIHNsb3QpIHRoZSBmbkNvbnRleHQgY2F1c2VzIG5hbWVkIHNsb3RzXG4gICAgLy8gdGhhdCBzaG91bGQgbm90IGJlIG1hdGNoZWQgdG8gbWF0Y2guXG4gICAgdmFyIGNsb25lID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gICAgY2xvbmUuZm5Db250ZXh0ID0gY29udGV4dFZtO1xuICAgIGNsb25lLmZuT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAge1xuICAgICAgKGNsb25lLmRldnRvb2xzTWV0YSA9IGNsb25lLmRldnRvb2xzTWV0YSB8fCB7fSkucmVuZGVyQ29udGV4dCA9IHJlbmRlckNvbnRleHQ7XG4gICAgfVxuICAgIGlmIChkYXRhLnNsb3QpIHtcbiAgICAgIChjbG9uZS5kYXRhIHx8IChjbG9uZS5kYXRhID0ge30pKS5zbG90ID0gZGF0YS5zbG90O1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmVcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlUHJvcHMgKHRvLCBmcm9tKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGZyb20pIHtcbiAgICAgIHRvW2NhbWVsaXplKGtleSldID0gZnJvbVtrZXldO1xuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIC8qICAqL1xuXG4gIC8qICAqL1xuXG4gIC8qICAqL1xuXG4gIC8vIGlubGluZSBob29rcyB0byBiZSBpbnZva2VkIG9uIGNvbXBvbmVudCBWTm9kZXMgZHVyaW5nIHBhdGNoXG4gIHZhciBjb21wb25lbnRWTm9kZUhvb2tzID0ge1xuICAgIGluaXQ6IGZ1bmN0aW9uIGluaXQgKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICAgIGlmIChcbiAgICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgJiZcbiAgICAgICAgIXZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCAmJlxuICAgICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZVxuICAgICAgKSB7XG4gICAgICAgIC8vIGtlcHQtYWxpdmUgY29tcG9uZW50cywgdHJlYXQgYXMgYSBwYXRjaFxuICAgICAgICB2YXIgbW91bnRlZE5vZGUgPSB2bm9kZTsgLy8gd29yayBhcm91bmQgZmxvd1xuICAgICAgICBjb21wb25lbnRWTm9kZUhvb2tzLnByZXBhdGNoKG1vdW50ZWROb2RlLCBtb3VudGVkTm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUoXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgYWN0aXZlSW5zdGFuY2VcbiAgICAgICAgKTtcbiAgICAgICAgY2hpbGQuJG1vdW50KGh5ZHJhdGluZyA/IHZub2RlLmVsbSA6IHVuZGVmaW5lZCwgaHlkcmF0aW5nKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcHJlcGF0Y2g6IGZ1bmN0aW9uIHByZXBhdGNoIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICAgIHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICB1cGRhdGVDaGlsZENvbXBvbmVudChcbiAgICAgICAgY2hpbGQsXG4gICAgICAgIG9wdGlvbnMucHJvcHNEYXRhLCAvLyB1cGRhdGVkIHByb3BzXG4gICAgICAgIG9wdGlvbnMubGlzdGVuZXJzLCAvLyB1cGRhdGVkIGxpc3RlbmVyc1xuICAgICAgICB2bm9kZSwgLy8gbmV3IHBhcmVudCB2bm9kZVxuICAgICAgICBvcHRpb25zLmNoaWxkcmVuIC8vIG5ldyBjaGlsZHJlblxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgaW5zZXJ0OiBmdW5jdGlvbiBpbnNlcnQgKHZub2RlKSB7XG4gICAgICB2YXIgY29udGV4dCA9IHZub2RlLmNvbnRleHQ7XG4gICAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCkge1xuICAgICAgICBjb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgY2FsbEhvb2soY29tcG9uZW50SW5zdGFuY2UsICdtb3VudGVkJyk7XG4gICAgICB9XG4gICAgICBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgICAgaWYgKGNvbnRleHQuX2lzTW91bnRlZCkge1xuICAgICAgICAgIC8vIHZ1ZS1yb3V0ZXIjMTIxMlxuICAgICAgICAgIC8vIER1cmluZyB1cGRhdGVzLCBhIGtlcHQtYWxpdmUgY29tcG9uZW50J3MgY2hpbGQgY29tcG9uZW50cyBtYXlcbiAgICAgICAgICAvLyBjaGFuZ2UsIHNvIGRpcmVjdGx5IHdhbGtpbmcgdGhlIHRyZWUgaGVyZSBtYXkgY2FsbCBhY3RpdmF0ZWQgaG9va3NcbiAgICAgICAgICAvLyBvbiBpbmNvcnJlY3QgY2hpbGRyZW4uIEluc3RlYWQgd2UgcHVzaCB0aGVtIGludG8gYSBxdWV1ZSB3aGljaCB3aWxsXG4gICAgICAgICAgLy8gYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSB3aG9sZSBwYXRjaCBwcm9jZXNzIGVuZGVkLlxuICAgICAgICAgIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcbiAgICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgaWYgKCFjb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQpIHtcbiAgICAgICAgaWYgKCF2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgICAgIGNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIGhvb2tzVG9NZXJnZSA9IE9iamVjdC5rZXlzKGNvbXBvbmVudFZOb2RlSG9va3MpO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAoXG4gICAgQ3RvcixcbiAgICBkYXRhLFxuICAgIGNvbnRleHQsXG4gICAgY2hpbGRyZW4sXG4gICAgdGFnXG4gICkge1xuICAgIGlmIChpc1VuZGVmKEN0b3IpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgYmFzZUN0b3IgPSBjb250ZXh0LiRvcHRpb25zLl9iYXNlO1xuXG4gICAgLy8gcGxhaW4gb3B0aW9ucyBvYmplY3Q6IHR1cm4gaXQgaW50byBhIGNvbnN0cnVjdG9yXG4gICAgaWYgKGlzT2JqZWN0KEN0b3IpKSB7XG4gICAgICBDdG9yID0gYmFzZUN0b3IuZXh0ZW5kKEN0b3IpO1xuICAgIH1cblxuICAgIC8vIGlmIGF0IHRoaXMgc3RhZ2UgaXQncyBub3QgYSBjb25zdHJ1Y3RvciBvciBhbiBhc3luYyBjb21wb25lbnQgZmFjdG9yeSxcbiAgICAvLyByZWplY3QuXG4gICAgaWYgKHR5cGVvZiBDdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB7XG4gICAgICAgIHdhcm4oKFwiSW52YWxpZCBDb21wb25lbnQgZGVmaW5pdGlvbjogXCIgKyAoU3RyaW5nKEN0b3IpKSksIGNvbnRleHQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gYXN5bmMgY29tcG9uZW50XG4gICAgdmFyIGFzeW5jRmFjdG9yeTtcbiAgICBpZiAoaXNVbmRlZihDdG9yLmNpZCkpIHtcbiAgICAgIGFzeW5jRmFjdG9yeSA9IEN0b3I7XG4gICAgICBDdG9yID0gcmVzb2x2ZUFzeW5jQ29tcG9uZW50KGFzeW5jRmFjdG9yeSwgYmFzZUN0b3IpO1xuICAgICAgaWYgKEN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciBub2RlIGZvciBhc3luYyBjb21wb25lbnQsIHdoaWNoIGlzIHJlbmRlcmVkXG4gICAgICAgIC8vIGFzIGEgY29tbWVudCBub2RlIGJ1dCBwcmVzZXJ2ZXMgYWxsIHRoZSByYXcgaW5mb3JtYXRpb24gZm9yIHRoZSBub2RlLlxuICAgICAgICAvLyB0aGUgaW5mb3JtYXRpb24gd2lsbCBiZSB1c2VkIGZvciBhc3luYyBzZXJ2ZXItcmVuZGVyaW5nIGFuZCBoeWRyYXRpb24uXG4gICAgICAgIHJldHVybiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyKFxuICAgICAgICAgIGFzeW5jRmFjdG9yeSxcbiAgICAgICAgICBkYXRhLFxuICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgdGFnXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkYXRhID0gZGF0YSB8fCB7fTtcblxuICAgIC8vIHJlc29sdmUgY29uc3RydWN0b3Igb3B0aW9ucyBpbiBjYXNlIGdsb2JhbCBtaXhpbnMgYXJlIGFwcGxpZWQgYWZ0ZXJcbiAgICAvLyBjb21wb25lbnQgY29uc3RydWN0b3IgY3JlYXRpb25cbiAgICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3IpO1xuXG4gICAgLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGRhdGEgaW50byBwcm9wcyAmIGV2ZW50c1xuICAgIGlmIChpc0RlZihkYXRhLm1vZGVsKSkge1xuICAgICAgdHJhbnNmb3JtTW9kZWwoQ3Rvci5vcHRpb25zLCBkYXRhKTtcbiAgICB9XG5cbiAgICAvLyBleHRyYWN0IHByb3BzXG4gICAgdmFyIHByb3BzRGF0YSA9IGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEoZGF0YSwgQ3RvciwgdGFnKTtcblxuICAgIC8vIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gICAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuZnVuY3Rpb25hbCkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50KEN0b3IsIHByb3BzRGF0YSwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pXG4gICAgfVxuXG4gICAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMsIHNpbmNlIHRoZXNlIG5lZWRzIHRvIGJlIHRyZWF0ZWQgYXNcbiAgICAvLyBjaGlsZCBjb21wb25lbnQgbGlzdGVuZXJzIGluc3RlYWQgb2YgRE9NIGxpc3RlbmVyc1xuICAgIHZhciBsaXN0ZW5lcnMgPSBkYXRhLm9uO1xuICAgIC8vIHJlcGxhY2Ugd2l0aCBsaXN0ZW5lcnMgd2l0aCAubmF0aXZlIG1vZGlmaWVyXG4gICAgLy8gc28gaXQgZ2V0cyBwcm9jZXNzZWQgZHVyaW5nIHBhcmVudCBjb21wb25lbnQgcGF0Y2guXG4gICAgZGF0YS5vbiA9IGRhdGEubmF0aXZlT247XG5cbiAgICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5hYnN0cmFjdCkpIHtcbiAgICAgIC8vIGFic3RyYWN0IGNvbXBvbmVudHMgZG8gbm90IGtlZXAgYW55dGhpbmdcbiAgICAgIC8vIG90aGVyIHRoYW4gcHJvcHMgJiBsaXN0ZW5lcnMgJiBzbG90XG5cbiAgICAgIC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICAgIHZhciBzbG90ID0gZGF0YS5zbG90O1xuICAgICAgZGF0YSA9IHt9O1xuICAgICAgaWYgKHNsb3QpIHtcbiAgICAgICAgZGF0YS5zbG90ID0gc2xvdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpbnN0YWxsIGNvbXBvbmVudCBtYW5hZ2VtZW50IGhvb2tzIG9udG8gdGhlIHBsYWNlaG9sZGVyIG5vZGVcbiAgICBpbnN0YWxsQ29tcG9uZW50SG9va3MoZGF0YSk7XG5cbiAgICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciB2bm9kZVxuICAgIHZhciBuYW1lID0gQ3Rvci5vcHRpb25zLm5hbWUgfHwgdGFnO1xuICAgIHZhciB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAgIChcInZ1ZS1jb21wb25lbnQtXCIgKyAoQ3Rvci5jaWQpICsgKG5hbWUgPyAoXCItXCIgKyBuYW1lKSA6ICcnKSksXG4gICAgICBkYXRhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0LFxuICAgICAgeyBDdG9yOiBDdG9yLCBwcm9wc0RhdGE6IHByb3BzRGF0YSwgbGlzdGVuZXJzOiBsaXN0ZW5lcnMsIHRhZzogdGFnLCBjaGlsZHJlbjogY2hpbGRyZW4gfSxcbiAgICAgIGFzeW5jRmFjdG9yeVxuICAgICk7XG5cbiAgICByZXR1cm4gdm5vZGVcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUgKFxuICAgIHZub2RlLCAvLyB3ZSBrbm93IGl0J3MgTW91bnRlZENvbXBvbmVudFZOb2RlIGJ1dCBmbG93IGRvZXNuJ3RcbiAgICBwYXJlbnQgLy8gYWN0aXZlSW5zdGFuY2UgaW4gbGlmZWN5Y2xlIHN0YXRlXG4gICkge1xuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgX2lzQ29tcG9uZW50OiB0cnVlLFxuICAgICAgX3BhcmVudFZub2RlOiB2bm9kZSxcbiAgICAgIHBhcmVudDogcGFyZW50XG4gICAgfTtcbiAgICAvLyBjaGVjayBpbmxpbmUtdGVtcGxhdGUgcmVuZGVyIGZ1bmN0aW9uc1xuICAgIHZhciBpbmxpbmVUZW1wbGF0ZSA9IHZub2RlLmRhdGEuaW5saW5lVGVtcGxhdGU7XG4gICAgaWYgKGlzRGVmKGlubGluZVRlbXBsYXRlKSkge1xuICAgICAgb3B0aW9ucy5yZW5kZXIgPSBpbmxpbmVUZW1wbGF0ZS5yZW5kZXI7XG4gICAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGlubGluZVRlbXBsYXRlLnN0YXRpY1JlbmRlckZucztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyB2bm9kZS5jb21wb25lbnRPcHRpb25zLkN0b3Iob3B0aW9ucylcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc3RhbGxDb21wb25lbnRIb29rcyAoZGF0YSkge1xuICAgIHZhciBob29rcyA9IGRhdGEuaG9vayB8fCAoZGF0YS5ob29rID0ge30pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3NUb01lcmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gaG9va3NUb01lcmdlW2ldO1xuICAgICAgdmFyIGV4aXN0aW5nID0gaG9va3Nba2V5XTtcbiAgICAgIHZhciB0b01lcmdlID0gY29tcG9uZW50Vk5vZGVIb29rc1trZXldO1xuICAgICAgaWYgKGV4aXN0aW5nICE9PSB0b01lcmdlICYmICEoZXhpc3RpbmcgJiYgZXhpc3RpbmcuX21lcmdlZCkpIHtcbiAgICAgICAgaG9va3Nba2V5XSA9IGV4aXN0aW5nID8gbWVyZ2VIb29rJDEodG9NZXJnZSwgZXhpc3RpbmcpIDogdG9NZXJnZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZUhvb2skMSAoZjEsIGYyKSB7XG4gICAgdmFyIG1lcmdlZCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAvLyBmbG93IGNvbXBsYWlucyBhYm91dCBleHRyYSBhcmdzIHdoaWNoIGlzIHdoeSB3ZSB1c2UgYW55XG4gICAgICBmMShhLCBiKTtcbiAgICAgIGYyKGEsIGIpO1xuICAgIH07XG4gICAgbWVyZ2VkLl9tZXJnZWQgPSB0cnVlO1xuICAgIHJldHVybiBtZXJnZWRcbiAgfVxuXG4gIC8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBpbmZvICh2YWx1ZSBhbmQgY2FsbGJhY2spIGludG9cbiAgLy8gcHJvcCBhbmQgZXZlbnQgaGFuZGxlciByZXNwZWN0aXZlbHkuXG4gIGZ1bmN0aW9uIHRyYW5zZm9ybU1vZGVsIChvcHRpb25zLCBkYXRhKSB7XG4gICAgdmFyIHByb3AgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLnByb3ApIHx8ICd2YWx1ZSc7XG4gICAgdmFyIGV2ZW50ID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5ldmVudCkgfHwgJ2lucHV0J1xuICAgIDsoZGF0YS5hdHRycyB8fCAoZGF0YS5hdHRycyA9IHt9KSlbcHJvcF0gPSBkYXRhLm1vZGVsLnZhbHVlO1xuICAgIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XG4gICAgdmFyIGV4aXN0aW5nID0gb25bZXZlbnRdO1xuICAgIHZhciBjYWxsYmFjayA9IGRhdGEubW9kZWwuY2FsbGJhY2s7XG4gICAgaWYgKGlzRGVmKGV4aXN0aW5nKSkge1xuICAgICAgaWYgKFxuICAgICAgICBBcnJheS5pc0FycmF5KGV4aXN0aW5nKVxuICAgICAgICAgID8gZXhpc3RpbmcuaW5kZXhPZihjYWxsYmFjaykgPT09IC0xXG4gICAgICAgICAgOiBleGlzdGluZyAhPT0gY2FsbGJhY2tcbiAgICAgICkge1xuICAgICAgICBvbltldmVudF0gPSBbY2FsbGJhY2tdLmNvbmNhdChleGlzdGluZyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9uW2V2ZW50XSA9IGNhbGxiYWNrO1xuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIHZhciBTSU1QTEVfTk9STUFMSVpFID0gMTtcbiAgdmFyIEFMV0FZU19OT1JNQUxJWkUgPSAyO1xuXG4gIC8vIHdyYXBwZXIgZnVuY3Rpb24gZm9yIHByb3ZpZGluZyBhIG1vcmUgZmxleGlibGUgaW50ZXJmYWNlXG4gIC8vIHdpdGhvdXQgZ2V0dGluZyB5ZWxsZWQgYXQgYnkgZmxvd1xuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50IChcbiAgICBjb250ZXh0LFxuICAgIHRhZyxcbiAgICBkYXRhLFxuICAgIGNoaWxkcmVuLFxuICAgIG5vcm1hbGl6YXRpb25UeXBlLFxuICAgIGFsd2F5c05vcm1hbGl6ZVxuICApIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSB8fCBpc1ByaW1pdGl2ZShkYXRhKSkge1xuICAgICAgbm9ybWFsaXphdGlvblR5cGUgPSBjaGlsZHJlbjtcbiAgICAgIGNoaWxkcmVuID0gZGF0YTtcbiAgICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChpc1RydWUoYWx3YXlzTm9ybWFsaXplKSkge1xuICAgICAgbm9ybWFsaXphdGlvblR5cGUgPSBBTFdBWVNfTk9STUFMSVpFO1xuICAgIH1cbiAgICByZXR1cm4gX2NyZWF0ZUVsZW1lbnQoY29udGV4dCwgdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUpXG4gIH1cblxuICBmdW5jdGlvbiBfY3JlYXRlRWxlbWVudCAoXG4gICAgY29udGV4dCxcbiAgICB0YWcsXG4gICAgZGF0YSxcbiAgICBjaGlsZHJlbixcbiAgICBub3JtYWxpemF0aW9uVHlwZVxuICApIHtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoKGRhdGEpLl9fb2JfXykpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiQXZvaWQgdXNpbmcgb2JzZXJ2ZWQgZGF0YSBvYmplY3QgYXMgdm5vZGUgZGF0YTogXCIgKyAoSlNPTi5zdHJpbmdpZnkoZGF0YSkpICsgXCJcXG5cIiArXG4gICAgICAgICdBbHdheXMgY3JlYXRlIGZyZXNoIHZub2RlIGRhdGEgb2JqZWN0cyBpbiBlYWNoIHJlbmRlciEnLFxuICAgICAgICBjb250ZXh0XG4gICAgICApO1xuICAgICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICAgIH1cbiAgICAvLyBvYmplY3Qgc3ludGF4IGluIHYtYmluZFxuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLmlzKSkge1xuICAgICAgdGFnID0gZGF0YS5pcztcbiAgICB9XG4gICAgaWYgKCF0YWcpIHtcbiAgICAgIC8vIGluIGNhc2Ugb2YgY29tcG9uZW50IDppcyBzZXQgdG8gZmFsc3kgdmFsdWVcbiAgICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgICB9XG4gICAgLy8gd2FybiBhZ2FpbnN0IG5vbi1wcmltaXRpdmUga2V5XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEua2V5KSAmJiAhaXNQcmltaXRpdmUoZGF0YS5rZXkpXG4gICAgKSB7XG4gICAgICB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ0F2b2lkIHVzaW5nIG5vbi1wcmltaXRpdmUgdmFsdWUgYXMga2V5LCAnICtcbiAgICAgICAgICAndXNlIHN0cmluZy9udW1iZXIgdmFsdWUgaW5zdGVhZC4nLFxuICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gc3VwcG9ydCBzaW5nbGUgZnVuY3Rpb24gY2hpbGRyZW4gYXMgZGVmYXVsdCBzY29wZWQgc2xvdFxuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJlxuICAgICAgdHlwZW9mIGNoaWxkcmVuWzBdID09PSAnZnVuY3Rpb24nXG4gICAgKSB7XG4gICAgICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgICAgIGRhdGEuc2NvcGVkU2xvdHMgPSB7IGRlZmF1bHQ6IGNoaWxkcmVuWzBdIH07XG4gICAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xuICAgIH1cbiAgICBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IEFMV0FZU19OT1JNQUxJWkUpIHtcbiAgICAgIGNoaWxkcmVuID0gbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICAgIH0gZWxzZSBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IFNJTVBMRV9OT1JNQUxJWkUpIHtcbiAgICAgIGNoaWxkcmVuID0gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICAgIH1cbiAgICB2YXIgdm5vZGUsIG5zO1xuICAgIGlmICh0eXBlb2YgdGFnID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIEN0b3I7XG4gICAgICBucyA9IChjb250ZXh0LiR2bm9kZSAmJiBjb250ZXh0LiR2bm9kZS5ucykgfHwgY29uZmlnLmdldFRhZ05hbWVzcGFjZSh0YWcpO1xuICAgICAgaWYgKGNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICAgICAgLy8gcGxhdGZvcm0gYnVpbHQtaW4gZWxlbWVudHNcbiAgICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgICAgY29uZmlnLnBhcnNlUGxhdGZvcm1UYWdOYW1lKHRhZyksIGRhdGEsIGNoaWxkcmVuLFxuICAgICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKCghZGF0YSB8fCAhZGF0YS5wcmUpICYmIGlzRGVmKEN0b3IgPSByZXNvbHZlQXNzZXQoY29udGV4dC4kb3B0aW9ucywgJ2NvbXBvbmVudHMnLCB0YWcpKSkge1xuICAgICAgICAvLyBjb21wb25lbnRcbiAgICAgICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQoQ3RvciwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4sIHRhZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB1bmtub3duIG9yIHVubGlzdGVkIG5hbWVzcGFjZWQgZWxlbWVudHNcbiAgICAgICAgLy8gY2hlY2sgYXQgcnVudGltZSBiZWNhdXNlIGl0IG1heSBnZXQgYXNzaWduZWQgYSBuYW1lc3BhY2Ugd2hlbiBpdHNcbiAgICAgICAgLy8gcGFyZW50IG5vcm1hbGl6ZXMgY2hpbGRyZW5cbiAgICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgICAgdGFnLCBkYXRhLCBjaGlsZHJlbixcbiAgICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBkaXJlY3QgY29tcG9uZW50IG9wdGlvbnMgLyBjb25zdHJ1Y3RvclxuICAgICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQodGFnLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbik7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgcmV0dXJuIHZub2RlXG4gICAgfSBlbHNlIGlmIChpc0RlZih2bm9kZSkpIHtcbiAgICAgIGlmIChpc0RlZihucykpIHsgYXBwbHlOUyh2bm9kZSwgbnMpOyB9XG4gICAgICBpZiAoaXNEZWYoZGF0YSkpIHsgcmVnaXN0ZXJEZWVwQmluZGluZ3MoZGF0YSk7IH1cbiAgICAgIHJldHVybiB2bm9kZVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYXBwbHlOUyAodm5vZGUsIG5zLCBmb3JjZSkge1xuICAgIHZub2RlLm5zID0gbnM7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgICAvLyB1c2UgZGVmYXVsdCBuYW1lc3BhY2UgaW5zaWRlIGZvcmVpZ25PYmplY3RcbiAgICAgIG5zID0gdW5kZWZpbmVkO1xuICAgICAgZm9yY2UgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoaXNEZWYodm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgaWYgKGlzRGVmKGNoaWxkLnRhZykgJiYgKFxuICAgICAgICAgIGlzVW5kZWYoY2hpbGQubnMpIHx8IChpc1RydWUoZm9yY2UpICYmIGNoaWxkLnRhZyAhPT0gJ3N2ZycpKSkge1xuICAgICAgICAgIGFwcGx5TlMoY2hpbGQsIG5zLCBmb3JjZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyByZWYgIzUzMThcbiAgLy8gbmVjZXNzYXJ5IHRvIGVuc3VyZSBwYXJlbnQgcmUtcmVuZGVyIHdoZW4gZGVlcCBiaW5kaW5ncyBsaWtlIDpzdHlsZSBhbmRcbiAgLy8gOmNsYXNzIGFyZSB1c2VkIG9uIHNsb3Qgbm9kZXNcbiAgZnVuY3Rpb24gcmVnaXN0ZXJEZWVwQmluZGluZ3MgKGRhdGEpIHtcbiAgICBpZiAoaXNPYmplY3QoZGF0YS5zdHlsZSkpIHtcbiAgICAgIHRyYXZlcnNlKGRhdGEuc3R5bGUpO1xuICAgIH1cbiAgICBpZiAoaXNPYmplY3QoZGF0YS5jbGFzcykpIHtcbiAgICAgIHRyYXZlcnNlKGRhdGEuY2xhc3MpO1xuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIGluaXRSZW5kZXIgKHZtKSB7XG4gICAgdm0uX3Zub2RlID0gbnVsbDsgLy8gdGhlIHJvb3Qgb2YgdGhlIGNoaWxkIHRyZWVcbiAgICB2bS5fc3RhdGljVHJlZXMgPSBudWxsOyAvLyB2LW9uY2UgY2FjaGVkIHRyZWVzXG4gICAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcbiAgICB2YXIgcGFyZW50Vm5vZGUgPSB2bS4kdm5vZGUgPSBvcHRpb25zLl9wYXJlbnRWbm9kZTsgLy8gdGhlIHBsYWNlaG9sZGVyIG5vZGUgaW4gcGFyZW50IHRyZWVcbiAgICB2YXIgcmVuZGVyQ29udGV4dCA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmNvbnRleHQ7XG4gICAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLCByZW5kZXJDb250ZXh0KTtcbiAgICB2bS4kc2NvcGVkU2xvdHMgPSBlbXB0eU9iamVjdDtcbiAgICAvLyBiaW5kIHRoZSBjcmVhdGVFbGVtZW50IGZuIHRvIHRoaXMgaW5zdGFuY2VcbiAgICAvLyBzbyB0aGF0IHdlIGdldCBwcm9wZXIgcmVuZGVyIGNvbnRleHQgaW5zaWRlIGl0LlxuICAgIC8vIGFyZ3Mgb3JkZXI6IHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlLCBhbHdheXNOb3JtYWxpemVcbiAgICAvLyBpbnRlcm5hbCB2ZXJzaW9uIGlzIHVzZWQgYnkgcmVuZGVyIGZ1bmN0aW9ucyBjb21waWxlZCBmcm9tIHRlbXBsYXRlc1xuICAgIHZtLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIGZhbHNlKTsgfTtcbiAgICAvLyBub3JtYWxpemF0aW9uIGlzIGFsd2F5cyBhcHBsaWVkIGZvciB0aGUgcHVibGljIHZlcnNpb24sIHVzZWQgaW5cbiAgICAvLyB1c2VyLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucy5cbiAgICB2bS4kY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCB0cnVlKTsgfTtcblxuICAgIC8vICRhdHRycyAmICRsaXN0ZW5lcnMgYXJlIGV4cG9zZWQgZm9yIGVhc2llciBIT0MgY3JlYXRpb24uXG4gICAgLy8gdGhleSBuZWVkIHRvIGJlIHJlYWN0aXZlIHNvIHRoYXQgSE9DcyB1c2luZyB0aGVtIGFyZSBhbHdheXMgdXBkYXRlZFxuICAgIHZhciBwYXJlbnREYXRhID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuZGF0YTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAge1xuICAgICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sICckYXR0cnMnLCBwYXJlbnREYXRhICYmIHBhcmVudERhdGEuYXR0cnMgfHwgZW1wdHlPYmplY3QsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuKFwiJGF0dHJzIGlzIHJlYWRvbmx5LlwiLCB2bSk7XG4gICAgICB9LCB0cnVlKTtcbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCAnJGxpc3RlbmVycycsIG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyB8fCBlbXB0eU9iamVjdCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ICYmIHdhcm4oXCIkbGlzdGVuZXJzIGlzIHJlYWRvbmx5LlwiLCB2bSk7XG4gICAgICB9LCB0cnVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gbnVsbDtcblxuICBmdW5jdGlvbiByZW5kZXJNaXhpbiAoVnVlKSB7XG4gICAgLy8gaW5zdGFsbCBydW50aW1lIGNvbnZlbmllbmNlIGhlbHBlcnNcbiAgICBpbnN0YWxsUmVuZGVySGVscGVycyhWdWUucHJvdG90eXBlKTtcblxuICAgIFZ1ZS5wcm90b3R5cGUuJG5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICByZXR1cm4gbmV4dFRpY2soZm4sIHRoaXMpXG4gICAgfTtcblxuICAgIFZ1ZS5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB2bSA9IHRoaXM7XG4gICAgICB2YXIgcmVmID0gdm0uJG9wdGlvbnM7XG4gICAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICAgIHZhciBfcGFyZW50Vm5vZGUgPSByZWYuX3BhcmVudFZub2RlO1xuXG4gICAgICBpZiAoX3BhcmVudFZub2RlKSB7XG4gICAgICAgIHZtLiRzY29wZWRTbG90cyA9IG5vcm1hbGl6ZVNjb3BlZFNsb3RzKFxuICAgICAgICAgIF9wYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzLFxuICAgICAgICAgIHZtLiRzbG90cyxcbiAgICAgICAgICB2bS4kc2NvcGVkU2xvdHNcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gc2V0IHBhcmVudCB2bm9kZS4gdGhpcyBhbGxvd3MgcmVuZGVyIGZ1bmN0aW9ucyB0byBoYXZlIGFjY2Vzc1xuICAgICAgLy8gdG8gdGhlIGRhdGEgb24gdGhlIHBsYWNlaG9sZGVyIG5vZGUuXG4gICAgICB2bS4kdm5vZGUgPSBfcGFyZW50Vm5vZGU7XG4gICAgICAvLyByZW5kZXIgc2VsZlxuICAgICAgdmFyIHZub2RlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhlcmUncyBubyBuZWVkIHRvIG1haW50YWluIGEgc3RhY2sgYmVjYXVlcyBhbGwgcmVuZGVyIGZucyBhcmUgY2FsbGVkXG4gICAgICAgIC8vIHNlcGFyYXRlbHkgZnJvbSBvbmUgYW5vdGhlci4gTmVzdGVkIGNvbXBvbmVudCdzIHJlbmRlciBmbnMgYXJlIGNhbGxlZFxuICAgICAgICAvLyB3aGVuIHBhcmVudCBjb21wb25lbnQgaXMgcGF0Y2hlZC5cbiAgICAgICAgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gdm07XG4gICAgICAgIHZub2RlID0gcmVuZGVyLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcInJlbmRlclwiKTtcbiAgICAgICAgLy8gcmV0dXJuIGVycm9yIHJlbmRlciByZXN1bHQsXG4gICAgICAgIC8vIG9yIHByZXZpb3VzIHZub2RlIHRvIHByZXZlbnQgcmVuZGVyIGVycm9yIGNhdXNpbmcgYmxhbmsgY29tcG9uZW50XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmICh2bS4kb3B0aW9ucy5yZW5kZXJFcnJvcikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2bm9kZSA9IHZtLiRvcHRpb25zLnJlbmRlckVycm9yLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCwgZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwicmVuZGVyRXJyb3JcIik7XG4gICAgICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IG51bGw7XG4gICAgICB9XG4gICAgICAvLyBpZiB0aGUgcmV0dXJuZWQgYXJyYXkgY29udGFpbnMgb25seSBhIHNpbmdsZSBub2RlLCBhbGxvdyBpdFxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpICYmIHZub2RlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB2bm9kZSA9IHZub2RlWzBdO1xuICAgICAgfVxuICAgICAgLy8gcmV0dXJuIGVtcHR5IHZub2RlIGluIGNhc2UgdGhlIHJlbmRlciBmdW5jdGlvbiBlcnJvcmVkIG91dFxuICAgICAgaWYgKCEodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgICdNdWx0aXBsZSByb290IG5vZGVzIHJldHVybmVkIGZyb20gcmVuZGVyIGZ1bmN0aW9uLiBSZW5kZXIgZnVuY3Rpb24gJyArXG4gICAgICAgICAgICAnc2hvdWxkIHJldHVybiBhIHNpbmdsZSByb290IG5vZGUuJyxcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2bm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgICAgIH1cbiAgICAgIC8vIHNldCBwYXJlbnRcbiAgICAgIHZub2RlLnBhcmVudCA9IF9wYXJlbnRWbm9kZTtcbiAgICAgIHJldHVybiB2bm9kZVxuICAgIH07XG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBlbnN1cmVDdG9yIChjb21wLCBiYXNlKSB7XG4gICAgaWYgKFxuICAgICAgY29tcC5fX2VzTW9kdWxlIHx8XG4gICAgICAoaGFzU3ltYm9sICYmIGNvbXBbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ01vZHVsZScpXG4gICAgKSB7XG4gICAgICBjb21wID0gY29tcC5kZWZhdWx0O1xuICAgIH1cbiAgICByZXR1cm4gaXNPYmplY3QoY29tcClcbiAgICAgID8gYmFzZS5leHRlbmQoY29tcClcbiAgICAgIDogY29tcFxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQXN5bmNQbGFjZWhvbGRlciAoXG4gICAgZmFjdG9yeSxcbiAgICBkYXRhLFxuICAgIGNvbnRleHQsXG4gICAgY2hpbGRyZW4sXG4gICAgdGFnXG4gICkge1xuICAgIHZhciBub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICAgIG5vZGUuYXN5bmNGYWN0b3J5ID0gZmFjdG9yeTtcbiAgICBub2RlLmFzeW5jTWV0YSA9IHsgZGF0YTogZGF0YSwgY29udGV4dDogY29udGV4dCwgY2hpbGRyZW46IGNoaWxkcmVuLCB0YWc6IHRhZyB9O1xuICAgIHJldHVybiBub2RlXG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlQXN5bmNDb21wb25lbnQgKFxuICAgIGZhY3RvcnksXG4gICAgYmFzZUN0b3JcbiAgKSB7XG4gICAgaWYgKGlzVHJ1ZShmYWN0b3J5LmVycm9yKSAmJiBpc0RlZihmYWN0b3J5LmVycm9yQ29tcCkpIHtcbiAgICAgIHJldHVybiBmYWN0b3J5LmVycm9yQ29tcFxuICAgIH1cblxuICAgIGlmIChpc0RlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgcmV0dXJuIGZhY3RvcnkucmVzb2x2ZWRcbiAgICB9XG5cbiAgICB2YXIgb3duZXIgPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XG4gICAgaWYgKG93bmVyICYmIGlzRGVmKGZhY3Rvcnkub3duZXJzKSAmJiBmYWN0b3J5Lm93bmVycy5pbmRleE9mKG93bmVyKSA9PT0gLTEpIHtcbiAgICAgIC8vIGFscmVhZHkgcGVuZGluZ1xuICAgICAgZmFjdG9yeS5vd25lcnMucHVzaChvd25lcik7XG4gICAgfVxuXG4gICAgaWYgKGlzVHJ1ZShmYWN0b3J5LmxvYWRpbmcpICYmIGlzRGVmKGZhY3RvcnkubG9hZGluZ0NvbXApKSB7XG4gICAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nQ29tcFxuICAgIH1cblxuICAgIGlmIChvd25lciAmJiAhaXNEZWYoZmFjdG9yeS5vd25lcnMpKSB7XG4gICAgICB2YXIgb3duZXJzID0gZmFjdG9yeS5vd25lcnMgPSBbb3duZXJdO1xuICAgICAgdmFyIHN5bmMgPSB0cnVlO1xuICAgICAgdmFyIHRpbWVyTG9hZGluZyA9IG51bGw7XG4gICAgICB2YXIgdGltZXJUaW1lb3V0ID0gbnVsbFxuXG4gICAgICA7KG93bmVyKS4kb24oJ2hvb2s6ZGVzdHJveWVkJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVtb3ZlKG93bmVycywgb3duZXIpOyB9KTtcblxuICAgICAgdmFyIGZvcmNlUmVuZGVyID0gZnVuY3Rpb24gKHJlbmRlckNvbXBsZXRlZCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG93bmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAob3duZXJzW2ldKS4kZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZW5kZXJDb21wbGV0ZWQpIHtcbiAgICAgICAgICBvd25lcnMubGVuZ3RoID0gMDtcbiAgICAgICAgICBpZiAodGltZXJMb2FkaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXJMb2FkaW5nKTtcbiAgICAgICAgICAgIHRpbWVyTG9hZGluZyA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aW1lclRpbWVvdXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lclRpbWVvdXQpO1xuICAgICAgICAgICAgdGltZXJUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciByZXNvbHZlID0gb25jZShmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgIC8vIGNhY2hlIHJlc29sdmVkXG4gICAgICAgIGZhY3RvcnkucmVzb2x2ZWQgPSBlbnN1cmVDdG9yKHJlcywgYmFzZUN0b3IpO1xuICAgICAgICAvLyBpbnZva2UgY2FsbGJhY2tzIG9ubHkgaWYgdGhpcyBpcyBub3QgYSBzeW5jaHJvbm91cyByZXNvbHZlXG4gICAgICAgIC8vIChhc3luYyByZXNvbHZlcyBhcmUgc2hpbW1lZCBhcyBzeW5jaHJvbm91cyBkdXJpbmcgU1NSKVxuICAgICAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgICBmb3JjZVJlbmRlcih0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvd25lcnMubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHZhciByZWplY3QgPSBvbmNlKGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIkZhaWxlZCB0byByZXNvbHZlIGFzeW5jIGNvbXBvbmVudDogXCIgKyAoU3RyaW5nKGZhY3RvcnkpKSArXG4gICAgICAgICAgKHJlYXNvbiA/IChcIlxcblJlYXNvbjogXCIgKyByZWFzb24pIDogJycpXG4gICAgICAgICk7XG4gICAgICAgIGlmIChpc0RlZihmYWN0b3J5LmVycm9yQ29tcCkpIHtcbiAgICAgICAgICBmYWN0b3J5LmVycm9yID0gdHJ1ZTtcbiAgICAgICAgICBmb3JjZVJlbmRlcih0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHZhciByZXMgPSBmYWN0b3J5KHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICAgIGlmIChpc09iamVjdChyZXMpKSB7XG4gICAgICAgIGlmIChpc1Byb21pc2UocmVzKSkge1xuICAgICAgICAgIC8vICgpID0+IFByb21pc2VcbiAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgICAgcmVzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaXNQcm9taXNlKHJlcy5jb21wb25lbnQpKSB7XG4gICAgICAgICAgcmVzLmNvbXBvbmVudC50aGVuKHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICAgICAgICBpZiAoaXNEZWYocmVzLmVycm9yKSkge1xuICAgICAgICAgICAgZmFjdG9yeS5lcnJvckNvbXAgPSBlbnN1cmVDdG9yKHJlcy5lcnJvciwgYmFzZUN0b3IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpc0RlZihyZXMubG9hZGluZykpIHtcbiAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZ0NvbXAgPSBlbnN1cmVDdG9yKHJlcy5sb2FkaW5nLCBiYXNlQ3Rvcik7XG4gICAgICAgICAgICBpZiAocmVzLmRlbGF5ID09PSAwKSB7XG4gICAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aW1lckxvYWRpbmcgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aW1lckxvYWRpbmcgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpICYmIGlzVW5kZWYoZmFjdG9yeS5lcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBmb3JjZVJlbmRlcihmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LCByZXMuZGVsYXkgfHwgMjAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNEZWYocmVzLnRpbWVvdXQpKSB7XG4gICAgICAgICAgICB0aW1lclRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdGltZXJUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgICAgICBcInRpbWVvdXQgKFwiICsgKHJlcy50aW1lb3V0KSArIFwibXMpXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCByZXMudGltZW91dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN5bmMgPSBmYWxzZTtcbiAgICAgIC8vIHJldHVybiBpbiBjYXNlIHJlc29sdmVkIHN5bmNocm9ub3VzbHlcbiAgICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmdcbiAgICAgICAgPyBmYWN0b3J5LmxvYWRpbmdDb21wXG4gICAgICAgIDogZmFjdG9yeS5yZXNvbHZlZFxuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIGlzQXN5bmNQbGFjZWhvbGRlciAobm9kZSkge1xuICAgIHJldHVybiBub2RlLmlzQ29tbWVudCAmJiBub2RlLmFzeW5jRmFjdG9yeVxuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCAoY2hpbGRyZW4pIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGMgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgaWYgKGlzRGVmKGMpICYmIChpc0RlZihjLmNvbXBvbmVudE9wdGlvbnMpIHx8IGlzQXN5bmNQbGFjZWhvbGRlcihjKSkpIHtcbiAgICAgICAgICByZXR1cm4gY1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gaW5pdEV2ZW50cyAodm0pIHtcbiAgICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2bS5faGFzSG9va0V2ZW50ID0gZmFsc2U7XG4gICAgLy8gaW5pdCBwYXJlbnQgYXR0YWNoZWQgZXZlbnRzXG4gICAgdmFyIGxpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMpO1xuICAgIH1cbiAgfVxuXG4gIHZhciB0YXJnZXQ7XG5cbiAgZnVuY3Rpb24gYWRkIChldmVudCwgZm4pIHtcbiAgICB0YXJnZXQuJG9uKGV2ZW50LCBmbik7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmUkMSAoZXZlbnQsIGZuKSB7XG4gICAgdGFyZ2V0LiRvZmYoZXZlbnQsIGZuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9uY2VIYW5kbGVyIChldmVudCwgZm4pIHtcbiAgICB2YXIgX3RhcmdldCA9IHRhcmdldDtcbiAgICByZXR1cm4gZnVuY3Rpb24gb25jZUhhbmRsZXIgKCkge1xuICAgICAgdmFyIHJlcyA9IGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAocmVzICE9PSBudWxsKSB7XG4gICAgICAgIF90YXJnZXQuJG9mZihldmVudCwgb25jZUhhbmRsZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyAoXG4gICAgdm0sXG4gICAgbGlzdGVuZXJzLFxuICAgIG9sZExpc3RlbmVyc1xuICApIHtcbiAgICB0YXJnZXQgPSB2bTtcbiAgICB1cGRhdGVMaXN0ZW5lcnMobGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMgfHwge30sIGFkZCwgcmVtb3ZlJDEsIGNyZWF0ZU9uY2VIYW5kbGVyLCB2bSk7XG4gICAgdGFyZ2V0ID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgZnVuY3Rpb24gZXZlbnRzTWl4aW4gKFZ1ZSkge1xuICAgIHZhciBob29rUkUgPSAvXmhvb2s6LztcbiAgICBWdWUucHJvdG90eXBlLiRvbiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICAgIHZhciB2bSA9IHRoaXM7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB2bS4kb24oZXZlbnRbaV0sIGZuKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKHZtLl9ldmVudHNbZXZlbnRdIHx8ICh2bS5fZXZlbnRzW2V2ZW50XSA9IFtdKSkucHVzaChmbik7XG4gICAgICAgIC8vIG9wdGltaXplIGhvb2s6ZXZlbnQgY29zdCBieSB1c2luZyBhIGJvb2xlYW4gZmxhZyBtYXJrZWQgYXQgcmVnaXN0cmF0aW9uXG4gICAgICAgIC8vIGluc3RlYWQgb2YgYSBoYXNoIGxvb2t1cFxuICAgICAgICBpZiAoaG9va1JFLnRlc3QoZXZlbnQpKSB7XG4gICAgICAgICAgdm0uX2hhc0hvb2tFdmVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2bVxuICAgIH07XG5cbiAgICBWdWUucHJvdG90eXBlLiRvbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgICAgdmFyIHZtID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIG9uICgpIHtcbiAgICAgICAgdm0uJG9mZihldmVudCwgb24pO1xuICAgICAgICBmbi5hcHBseSh2bSwgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIG9uLmZuID0gZm47XG4gICAgICB2bS4kb24oZXZlbnQsIG9uKTtcbiAgICAgIHJldHVybiB2bVxuICAgIH07XG5cbiAgICBWdWUucHJvdG90eXBlLiRvZmYgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgICB2YXIgdm0gPSB0aGlzO1xuICAgICAgLy8gYWxsXG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHJldHVybiB2bVxuICAgICAgfVxuICAgICAgLy8gYXJyYXkgb2YgZXZlbnRzXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgICAgZm9yICh2YXIgaSQxID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSQxIDwgbDsgaSQxKyspIHtcbiAgICAgICAgICB2bS4kb2ZmKGV2ZW50W2kkMV0sIGZuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdm1cbiAgICAgIH1cbiAgICAgIC8vIHNwZWNpZmljIGV2ZW50XG4gICAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG4gICAgICBpZiAoIWNicykge1xuICAgICAgICByZXR1cm4gdm1cbiAgICAgIH1cbiAgICAgIGlmICghZm4pIHtcbiAgICAgICAgdm0uX2V2ZW50c1tldmVudF0gPSBudWxsO1xuICAgICAgICByZXR1cm4gdm1cbiAgICAgIH1cbiAgICAgIC8vIHNwZWNpZmljIGhhbmRsZXJcbiAgICAgIHZhciBjYjtcbiAgICAgIHZhciBpID0gY2JzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgY2IgPSBjYnNbaV07XG4gICAgICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICAgICAgY2JzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdm1cbiAgICB9O1xuXG4gICAgVnVlLnByb3RvdHlwZS4kZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgdmFyIHZtID0gdGhpcztcbiAgICAgIHtcbiAgICAgICAgdmFyIGxvd2VyQ2FzZUV2ZW50ID0gZXZlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKGxvd2VyQ2FzZUV2ZW50ICE9PSBldmVudCAmJiB2bS5fZXZlbnRzW2xvd2VyQ2FzZUV2ZW50XSkge1xuICAgICAgICAgIHRpcChcbiAgICAgICAgICAgIFwiRXZlbnQgXFxcIlwiICsgbG93ZXJDYXNlRXZlbnQgKyBcIlxcXCIgaXMgZW1pdHRlZCBpbiBjb21wb25lbnQgXCIgK1xuICAgICAgICAgICAgKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSArIFwiIGJ1dCB0aGUgaGFuZGxlciBpcyByZWdpc3RlcmVkIGZvciBcXFwiXCIgKyBldmVudCArIFwiXFxcIi4gXCIgK1xuICAgICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCB5b3UgY2Fubm90IHVzZSBcIiArXG4gICAgICAgICAgICBcInYtb24gdG8gbGlzdGVuIHRvIGNhbWVsQ2FzZSBldmVudHMgd2hlbiB1c2luZyBpbi1ET00gdGVtcGxhdGVzLiBcIiArXG4gICAgICAgICAgICBcIllvdSBzaG91bGQgcHJvYmFibHkgdXNlIFxcXCJcIiArIChoeXBoZW5hdGUoZXZlbnQpKSArIFwiXFxcIiBpbnN0ZWFkIG9mIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgICAgaWYgKGNicykge1xuICAgICAgICBjYnMgPSBjYnMubGVuZ3RoID4gMSA/IHRvQXJyYXkoY2JzKSA6IGNicztcbiAgICAgICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgICAgIHZhciBpbmZvID0gXCJldmVudCBoYW5kbGVyIGZvciBcXFwiXCIgKyBldmVudCArIFwiXFxcIlwiO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhjYnNbaV0sIHZtLCBhcmdzLCB2bSwgaW5mbyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2bVxuICAgIH07XG4gIH1cblxuICAvKiAgKi9cblxuICB2YXIgYWN0aXZlSW5zdGFuY2UgPSBudWxsO1xuICB2YXIgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gc2V0QWN0aXZlSW5zdGFuY2Uodm0pIHtcbiAgICB2YXIgcHJldkFjdGl2ZUluc3RhbmNlID0gYWN0aXZlSW5zdGFuY2U7XG4gICAgYWN0aXZlSW5zdGFuY2UgPSB2bTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgYWN0aXZlSW5zdGFuY2UgPSBwcmV2QWN0aXZlSW5zdGFuY2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdExpZmVjeWNsZSAodm0pIHtcbiAgICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuXG4gICAgLy8gbG9jYXRlIGZpcnN0IG5vbi1hYnN0cmFjdCBwYXJlbnRcbiAgICB2YXIgcGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gICAgaWYgKHBhcmVudCAmJiAhb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgICAgd2hpbGUgKHBhcmVudC4kb3B0aW9ucy5hYnN0cmFjdCAmJiBwYXJlbnQuJHBhcmVudCkge1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcbiAgICAgIH1cbiAgICAgIHBhcmVudC4kY2hpbGRyZW4ucHVzaCh2bSk7XG4gICAgfVxuXG4gICAgdm0uJHBhcmVudCA9IHBhcmVudDtcbiAgICB2bS4kcm9vdCA9IHBhcmVudCA/IHBhcmVudC4kcm9vdCA6IHZtO1xuXG4gICAgdm0uJGNoaWxkcmVuID0gW107XG4gICAgdm0uJHJlZnMgPSB7fTtcblxuICAgIHZtLl93YXRjaGVyID0gbnVsbDtcbiAgICB2bS5faW5hY3RpdmUgPSBudWxsO1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICAgIHZtLl9pc01vdW50ZWQgPSBmYWxzZTtcbiAgICB2bS5faXNEZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gbGlmZWN5Y2xlTWl4aW4gKFZ1ZSkge1xuICAgIFZ1ZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgICB2YXIgdm0gPSB0aGlzO1xuICAgICAgdmFyIHByZXZFbCA9IHZtLiRlbDtcbiAgICAgIHZhciBwcmV2Vm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICB2YXIgcmVzdG9yZUFjdGl2ZUluc3RhbmNlID0gc2V0QWN0aXZlSW5zdGFuY2Uodm0pO1xuICAgICAgdm0uX3Zub2RlID0gdm5vZGU7XG4gICAgICAvLyBWdWUucHJvdG90eXBlLl9fcGF0Y2hfXyBpcyBpbmplY3RlZCBpbiBlbnRyeSBwb2ludHNcbiAgICAgIC8vIGJhc2VkIG9uIHRoZSByZW5kZXJpbmcgYmFja2VuZCB1c2VkLlxuICAgICAgaWYgKCFwcmV2Vm5vZGUpIHtcbiAgICAgICAgLy8gaW5pdGlhbCByZW5kZXJcbiAgICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKHZtLiRlbCwgdm5vZGUsIGh5ZHJhdGluZywgZmFsc2UgLyogcmVtb3ZlT25seSAqLyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB1cGRhdGVzXG4gICAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhwcmV2Vm5vZGUsIHZub2RlKTtcbiAgICAgIH1cbiAgICAgIHJlc3RvcmVBY3RpdmVJbnN0YW5jZSgpO1xuICAgICAgLy8gdXBkYXRlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgICBpZiAocHJldkVsKSB7XG4gICAgICAgIHByZXZFbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICh2bS4kZWwpIHtcbiAgICAgICAgdm0uJGVsLl9fdnVlX18gPSB2bTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIHBhcmVudCBpcyBhbiBIT0MsIHVwZGF0ZSBpdHMgJGVsIGFzIHdlbGxcbiAgICAgIGlmICh2bS4kdm5vZGUgJiYgdm0uJHBhcmVudCAmJiB2bS4kdm5vZGUgPT09IHZtLiRwYXJlbnQuX3Zub2RlKSB7XG4gICAgICAgIHZtLiRwYXJlbnQuJGVsID0gdm0uJGVsO1xuICAgICAgfVxuICAgICAgLy8gdXBkYXRlZCBob29rIGlzIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyIHRvIGVuc3VyZSB0aGF0IGNoaWxkcmVuIGFyZVxuICAgICAgLy8gdXBkYXRlZCBpbiBhIHBhcmVudCdzIHVwZGF0ZWQgaG9vay5cbiAgICB9O1xuXG4gICAgVnVlLnByb3RvdHlwZS4kZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdm0gPSB0aGlzO1xuICAgICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICAgIHZtLl93YXRjaGVyLnVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBWdWUucHJvdG90eXBlLiRkZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZtID0gdGhpcztcbiAgICAgIGlmICh2bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlRGVzdHJveScpO1xuICAgICAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSBwYXJlbnRcbiAgICAgIHZhciBwYXJlbnQgPSB2bS4kcGFyZW50O1xuICAgICAgaWYgKHBhcmVudCAmJiAhcGFyZW50Ll9pc0JlaW5nRGVzdHJveWVkICYmICF2bS4kb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgICAgICByZW1vdmUocGFyZW50LiRjaGlsZHJlbiwgdm0pO1xuICAgICAgfVxuICAgICAgLy8gdGVhcmRvd24gd2F0Y2hlcnNcbiAgICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgICB2bS5fd2F0Y2hlci50ZWFyZG93bigpO1xuICAgICAgfVxuICAgICAgdmFyIGkgPSB2bS5fd2F0Y2hlcnMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICB2bS5fd2F0Y2hlcnNbaV0udGVhcmRvd24oKTtcbiAgICAgIH1cbiAgICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgZnJvbSBkYXRhIG9iXG4gICAgICAvLyBmcm96ZW4gb2JqZWN0IG1heSBub3QgaGF2ZSBvYnNlcnZlci5cbiAgICAgIGlmICh2bS5fZGF0YS5fX29iX18pIHtcbiAgICAgICAgdm0uX2RhdGEuX19vYl9fLnZtQ291bnQtLTtcbiAgICAgIH1cbiAgICAgIC8vIGNhbGwgdGhlIGxhc3QgaG9vay4uLlxuICAgICAgdm0uX2lzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgIC8vIGludm9rZSBkZXN0cm95IGhvb2tzIG9uIGN1cnJlbnQgcmVuZGVyZWQgdHJlZVxuICAgICAgdm0uX19wYXRjaF9fKHZtLl92bm9kZSwgbnVsbCk7XG4gICAgICAvLyBmaXJlIGRlc3Ryb3llZCBob29rXG4gICAgICBjYWxsSG9vayh2bSwgJ2Rlc3Ryb3llZCcpO1xuICAgICAgLy8gdHVybiBvZmYgYWxsIGluc3RhbmNlIGxpc3RlbmVycy5cbiAgICAgIHZtLiRvZmYoKTtcbiAgICAgIC8vIHJlbW92ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgICAgaWYgKHZtLiRlbCkge1xuICAgICAgICB2bS4kZWwuX192dWVfXyA9IG51bGw7XG4gICAgICB9XG4gICAgICAvLyByZWxlYXNlIGNpcmN1bGFyIHJlZmVyZW5jZSAoIzY3NTkpXG4gICAgICBpZiAodm0uJHZub2RlKSB7XG4gICAgICAgIHZtLiR2bm9kZS5wYXJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBtb3VudENvbXBvbmVudCAoXG4gICAgdm0sXG4gICAgZWwsXG4gICAgaHlkcmF0aW5nXG4gICkge1xuICAgIHZtLiRlbCA9IGVsO1xuICAgIGlmICghdm0uJG9wdGlvbnMucmVuZGVyKSB7XG4gICAgICB2bS4kb3B0aW9ucy5yZW5kZXIgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICAgICAge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCh2bS4kb3B0aW9ucy50ZW1wbGF0ZSAmJiB2bS4kb3B0aW9ucy50ZW1wbGF0ZS5jaGFyQXQoMCkgIT09ICcjJykgfHxcbiAgICAgICAgICB2bS4kb3B0aW9ucy5lbCB8fCBlbCkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAnWW91IGFyZSB1c2luZyB0aGUgcnVudGltZS1vbmx5IGJ1aWxkIG9mIFZ1ZSB3aGVyZSB0aGUgdGVtcGxhdGUgJyArXG4gICAgICAgICAgICAnY29tcGlsZXIgaXMgbm90IGF2YWlsYWJsZS4gRWl0aGVyIHByZS1jb21waWxlIHRoZSB0ZW1wbGF0ZXMgaW50byAnICtcbiAgICAgICAgICAgICdyZW5kZXIgZnVuY3Rpb25zLCBvciB1c2UgdGhlIGNvbXBpbGVyLWluY2x1ZGVkIGJ1aWxkLicsXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgICdGYWlsZWQgdG8gbW91bnQgY29tcG9uZW50OiB0ZW1wbGF0ZSBvciByZW5kZXIgZnVuY3Rpb24gbm90IGRlZmluZWQuJyxcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZU1vdW50Jyk7XG5cbiAgICB2YXIgdXBkYXRlQ29tcG9uZW50O1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmFtZSA9IHZtLl9uYW1lO1xuICAgICAgICB2YXIgaWQgPSB2bS5fdWlkO1xuICAgICAgICB2YXIgc3RhcnRUYWcgPSBcInZ1ZS1wZXJmLXN0YXJ0OlwiICsgaWQ7XG4gICAgICAgIHZhciBlbmRUYWcgPSBcInZ1ZS1wZXJmLWVuZDpcIiArIGlkO1xuXG4gICAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgICB2YXIgdm5vZGUgPSB2bS5fcmVuZGVyKCk7XG4gICAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyBuYW1lICsgXCIgcmVuZGVyXCIpLCBzdGFydFRhZywgZW5kVGFnKTtcblxuICAgICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgICAgdm0uX3VwZGF0ZSh2bm9kZSwgaHlkcmF0aW5nKTtcbiAgICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgICBtZWFzdXJlKChcInZ1ZSBcIiArIG5hbWUgKyBcIiBwYXRjaFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZtLl91cGRhdGUodm0uX3JlbmRlcigpLCBoeWRyYXRpbmcpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyB3ZSBzZXQgdGhpcyB0byB2bS5fd2F0Y2hlciBpbnNpZGUgdGhlIHdhdGNoZXIncyBjb25zdHJ1Y3RvclxuICAgIC8vIHNpbmNlIHRoZSB3YXRjaGVyJ3MgaW5pdGlhbCBwYXRjaCBtYXkgY2FsbCAkZm9yY2VVcGRhdGUgKGUuZy4gaW5zaWRlIGNoaWxkXG4gICAgLy8gY29tcG9uZW50J3MgbW91bnRlZCBob29rKSwgd2hpY2ggcmVsaWVzIG9uIHZtLl93YXRjaGVyIGJlaW5nIGFscmVhZHkgZGVmaW5lZFxuICAgIG5ldyBXYXRjaGVyKHZtLCB1cGRhdGVDb21wb25lbnQsIG5vb3AsIHtcbiAgICAgIGJlZm9yZTogZnVuY3Rpb24gYmVmb3JlICgpIHtcbiAgICAgICAgaWYgKHZtLl9pc01vdW50ZWQgJiYgIXZtLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlVXBkYXRlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB0cnVlIC8qIGlzUmVuZGVyV2F0Y2hlciAqLyk7XG4gICAgaHlkcmF0aW5nID0gZmFsc2U7XG5cbiAgICAvLyBtYW51YWxseSBtb3VudGVkIGluc3RhbmNlLCBjYWxsIG1vdW50ZWQgb24gc2VsZlxuICAgIC8vIG1vdW50ZWQgaXMgY2FsbGVkIGZvciByZW5kZXItY3JlYXRlZCBjaGlsZCBjb21wb25lbnRzIGluIGl0cyBpbnNlcnRlZCBob29rXG4gICAgaWYgKHZtLiR2bm9kZSA9PSBudWxsKSB7XG4gICAgICB2bS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgIGNhbGxIb29rKHZtLCAnbW91bnRlZCcpO1xuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNoaWxkQ29tcG9uZW50IChcbiAgICB2bSxcbiAgICBwcm9wc0RhdGEsXG4gICAgbGlzdGVuZXJzLFxuICAgIHBhcmVudFZub2RlLFxuICAgIHJlbmRlckNoaWxkcmVuXG4gICkge1xuICAgIHtcbiAgICAgIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgY29tcG9uZW50IGhhcyBzbG90IGNoaWxkcmVuXG4gICAgLy8gd2UgbmVlZCB0byBkbyB0aGlzIGJlZm9yZSBvdmVyd3JpdGluZyAkb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4uXG5cbiAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgZHluYW1pYyBzY29wZWRTbG90cyAoaGFuZC13cml0dGVuIG9yIGNvbXBpbGVkIGJ1dCB3aXRoXG4gICAgLy8gZHluYW1pYyBzbG90IG5hbWVzKS4gU3RhdGljIHNjb3BlZCBzbG90cyBjb21waWxlZCBmcm9tIHRlbXBsYXRlIGhhcyB0aGVcbiAgICAvLyBcIiRzdGFibGVcIiBtYXJrZXIuXG4gICAgdmFyIG5ld1Njb3BlZFNsb3RzID0gcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cztcbiAgICB2YXIgb2xkU2NvcGVkU2xvdHMgPSB2bS4kc2NvcGVkU2xvdHM7XG4gICAgdmFyIGhhc0R5bmFtaWNTY29wZWRTbG90ID0gISEoXG4gICAgICAobmV3U2NvcGVkU2xvdHMgJiYgIW5ld1Njb3BlZFNsb3RzLiRzdGFibGUpIHx8XG4gICAgICAob2xkU2NvcGVkU2xvdHMgIT09IGVtcHR5T2JqZWN0ICYmICFvbGRTY29wZWRTbG90cy4kc3RhYmxlKSB8fFxuICAgICAgKG5ld1Njb3BlZFNsb3RzICYmIHZtLiRzY29wZWRTbG90cy4ka2V5ICE9PSBuZXdTY29wZWRTbG90cy4ka2V5KVxuICAgICk7XG5cbiAgICAvLyBBbnkgc3RhdGljIHNsb3QgY2hpbGRyZW4gZnJvbSB0aGUgcGFyZW50IG1heSBoYXZlIGNoYW5nZWQgZHVyaW5nIHBhcmVudCdzXG4gICAgLy8gdXBkYXRlLiBEeW5hbWljIHNjb3BlZCBzbG90cyBtYXkgYWxzbyBoYXZlIGNoYW5nZWQuIEluIHN1Y2ggY2FzZXMsIGEgZm9yY2VkXG4gICAgLy8gdXBkYXRlIGlzIG5lY2Vzc2FyeSB0byBlbnN1cmUgY29ycmVjdG5lc3MuXG4gICAgdmFyIG5lZWRzRm9yY2VVcGRhdGUgPSAhIShcbiAgICAgIHJlbmRlckNoaWxkcmVuIHx8ICAgICAgICAgICAgICAgLy8gaGFzIG5ldyBzdGF0aWMgc2xvdHNcbiAgICAgIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiB8fCAgLy8gaGFzIG9sZCBzdGF0aWMgc2xvdHNcbiAgICAgIGhhc0R5bmFtaWNTY29wZWRTbG90XG4gICAgKTtcblxuICAgIHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZSA9IHBhcmVudFZub2RlO1xuICAgIHZtLiR2bm9kZSA9IHBhcmVudFZub2RlOyAvLyB1cGRhdGUgdm0ncyBwbGFjZWhvbGRlciBub2RlIHdpdGhvdXQgcmUtcmVuZGVyXG5cbiAgICBpZiAodm0uX3Zub2RlKSB7IC8vIHVwZGF0ZSBjaGlsZCB0cmVlJ3MgcGFyZW50XG4gICAgICB2bS5fdm5vZGUucGFyZW50ID0gcGFyZW50Vm5vZGU7XG4gICAgfVxuICAgIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiA9IHJlbmRlckNoaWxkcmVuO1xuXG4gICAgLy8gdXBkYXRlICRhdHRycyBhbmQgJGxpc3RlbmVycyBoYXNoXG4gICAgLy8gdGhlc2UgYXJlIGFsc28gcmVhY3RpdmUgc28gdGhleSBtYXkgdHJpZ2dlciBjaGlsZCB1cGRhdGUgaWYgdGhlIGNoaWxkXG4gICAgLy8gdXNlZCB0aGVtIGR1cmluZyByZW5kZXJcbiAgICB2bS4kYXR0cnMgPSBwYXJlbnRWbm9kZS5kYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0O1xuICAgIHZtLiRsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3Q7XG5cbiAgICAvLyB1cGRhdGUgcHJvcHNcbiAgICBpZiAocHJvcHNEYXRhICYmIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgICB0b2dnbGVPYnNlcnZpbmcoZmFsc2UpO1xuICAgICAgdmFyIHByb3BzID0gdm0uX3Byb3BzO1xuICAgICAgdmFyIHByb3BLZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzIHx8IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0gcHJvcEtleXNbaV07XG4gICAgICAgIHZhciBwcm9wT3B0aW9ucyA9IHZtLiRvcHRpb25zLnByb3BzOyAvLyB3dGYgZmxvdz9cbiAgICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BPcHRpb25zLCBwcm9wc0RhdGEsIHZtKTtcbiAgICAgIH1cbiAgICAgIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbiAgICAgIC8vIGtlZXAgYSBjb3B5IG9mIHJhdyBwcm9wc0RhdGFcbiAgICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YSA9IHByb3BzRGF0YTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgbGlzdGVuZXJzXG4gICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0O1xuICAgIHZhciBvbGRMaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICAgIHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyk7XG5cbiAgICAvLyByZXNvbHZlIHNsb3RzICsgZm9yY2UgdXBkYXRlIGlmIGhhcyBjaGlsZHJlblxuICAgIGlmIChuZWVkc0ZvcmNlVXBkYXRlKSB7XG4gICAgICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMocmVuZGVyQ2hpbGRyZW4sIHBhcmVudFZub2RlLmNvbnRleHQpO1xuICAgICAgdm0uJGZvcmNlVXBkYXRlKCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNJbkluYWN0aXZlVHJlZSAodm0pIHtcbiAgICB3aGlsZSAodm0gJiYgKHZtID0gdm0uJHBhcmVudCkpIHtcbiAgICAgIGlmICh2bS5faW5hY3RpdmUpIHsgcmV0dXJuIHRydWUgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgICBpZiAoZGlyZWN0KSB7XG4gICAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZtLl9kaXJlY3RJbmFjdGl2ZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICh2bS5faW5hY3RpdmUgfHwgdm0uX2luYWN0aXZlID09PSBudWxsKSB7XG4gICAgICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICAgIH1cbiAgICAgIGNhbGxIb29rKHZtLCAnYWN0aXZhdGVkJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gICAgaWYgKGRpcmVjdCkge1xuICAgICAgdm0uX2RpcmVjdEluYWN0aXZlID0gdHJ1ZTtcbiAgICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF2bS5faW5hY3RpdmUpIHtcbiAgICAgIHZtLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICAgIH1cbiAgICAgIGNhbGxIb29rKHZtLCAnZGVhY3RpdmF0ZWQnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjYWxsSG9vayAodm0sIGhvb2spIHtcbiAgICAvLyAjNzU3MyBkaXNhYmxlIGRlcCBjb2xsZWN0aW9uIHdoZW4gaW52b2tpbmcgbGlmZWN5Y2xlIGhvb2tzXG4gICAgcHVzaFRhcmdldCgpO1xuICAgIHZhciBoYW5kbGVycyA9IHZtLiRvcHRpb25zW2hvb2tdO1xuICAgIHZhciBpbmZvID0gaG9vayArIFwiIGhvb2tcIjtcbiAgICBpZiAoaGFuZGxlcnMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgIGludm9rZVdpdGhFcnJvckhhbmRsaW5nKGhhbmRsZXJzW2ldLCB2bSwgbnVsbCwgdm0sIGluZm8pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodm0uX2hhc0hvb2tFdmVudCkge1xuICAgICAgdm0uJGVtaXQoJ2hvb2s6JyArIGhvb2spO1xuICAgIH1cbiAgICBwb3BUYXJnZXQoKTtcbiAgfVxuXG4gIC8qICAqL1xuXG4gIHZhciBNQVhfVVBEQVRFX0NPVU5UID0gMTAwO1xuXG4gIHZhciBxdWV1ZSA9IFtdO1xuICB2YXIgYWN0aXZhdGVkQ2hpbGRyZW4gPSBbXTtcbiAgdmFyIGhhcyA9IHt9O1xuICB2YXIgY2lyY3VsYXIgPSB7fTtcbiAgdmFyIHdhaXRpbmcgPSBmYWxzZTtcbiAgdmFyIGZsdXNoaW5nID0gZmFsc2U7XG4gIHZhciBpbmRleCA9IDA7XG5cbiAgLyoqXG4gICAqIFJlc2V0IHRoZSBzY2hlZHVsZXIncyBzdGF0ZS5cbiAgICovXG4gIGZ1bmN0aW9uIHJlc2V0U2NoZWR1bGVyU3RhdGUgKCkge1xuICAgIGluZGV4ID0gcXVldWUubGVuZ3RoID0gYWN0aXZhdGVkQ2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgICBoYXMgPSB7fTtcbiAgICB7XG4gICAgICBjaXJjdWxhciA9IHt9O1xuICAgIH1cbiAgICB3YWl0aW5nID0gZmx1c2hpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIEFzeW5jIGVkZ2UgY2FzZSAjNjU2NiByZXF1aXJlcyBzYXZpbmcgdGhlIHRpbWVzdGFtcCB3aGVuIGV2ZW50IGxpc3RlbmVycyBhcmVcbiAgLy8gYXR0YWNoZWQuIEhvd2V2ZXIsIGNhbGxpbmcgcGVyZm9ybWFuY2Uubm93KCkgaGFzIGEgcGVyZiBvdmVyaGVhZCBlc3BlY2lhbGx5XG4gIC8vIGlmIHRoZSBwYWdlIGhhcyB0aG91c2FuZHMgb2YgZXZlbnQgbGlzdGVuZXJzLiBJbnN0ZWFkLCB3ZSB0YWtlIGEgdGltZXN0YW1wXG4gIC8vIGV2ZXJ5IHRpbWUgdGhlIHNjaGVkdWxlciBmbHVzaGVzIGFuZCB1c2UgdGhhdCBmb3IgYWxsIGV2ZW50IGxpc3RlbmVyc1xuICAvLyBhdHRhY2hlZCBkdXJpbmcgdGhhdCBmbHVzaC5cbiAgdmFyIGN1cnJlbnRGbHVzaFRpbWVzdGFtcCA9IDA7XG5cbiAgLy8gQXN5bmMgZWRnZSBjYXNlIGZpeCByZXF1aXJlcyBzdG9yaW5nIGFuIGV2ZW50IGxpc3RlbmVyJ3MgYXR0YWNoIHRpbWVzdGFtcC5cbiAgdmFyIGdldE5vdyA9IERhdGUubm93O1xuXG4gIC8vIERldGVybWluZSB3aGF0IGV2ZW50IHRpbWVzdGFtcCB0aGUgYnJvd3NlciBpcyB1c2luZy4gQW5ub3lpbmdseSwgdGhlXG4gIC8vIHRpbWVzdGFtcCBjYW4gZWl0aGVyIGJlIGhpLXJlcyAocmVsYXRpdmUgdG8gcGFnZSBsb2FkKSBvciBsb3ctcmVzXG4gIC8vIChyZWxhdGl2ZSB0byBVTklYIGVwb2NoKSwgc28gaW4gb3JkZXIgdG8gY29tcGFyZSB0aW1lIHdlIGhhdmUgdG8gdXNlIHRoZVxuICAvLyBzYW1lIHRpbWVzdGFtcCB0eXBlIHdoZW4gc2F2aW5nIHRoZSBmbHVzaCB0aW1lc3RhbXAuXG4gIC8vIEFsbCBJRSB2ZXJzaW9ucyB1c2UgbG93LXJlcyBldmVudCB0aW1lc3RhbXBzLCBhbmQgaGF2ZSBwcm9ibGVtYXRpYyBjbG9ja1xuICAvLyBpbXBsZW1lbnRhdGlvbnMgKCM5NjMyKVxuICBpZiAoaW5Ccm93c2VyICYmICFpc0lFKSB7XG4gICAgdmFyIHBlcmZvcm1hbmNlID0gd2luZG93LnBlcmZvcm1hbmNlO1xuICAgIGlmIChcbiAgICAgIHBlcmZvcm1hbmNlICYmXG4gICAgICB0eXBlb2YgcGVyZm9ybWFuY2Uubm93ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICBnZXROb3coKSA+IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpLnRpbWVTdGFtcFxuICAgICkge1xuICAgICAgLy8gaWYgdGhlIGV2ZW50IHRpbWVzdGFtcCwgYWx0aG91Z2ggZXZhbHVhdGVkIEFGVEVSIHRoZSBEYXRlLm5vdygpLCBpc1xuICAgICAgLy8gc21hbGxlciB0aGFuIGl0LCBpdCBtZWFucyB0aGUgZXZlbnQgaXMgdXNpbmcgYSBoaS1yZXMgdGltZXN0YW1wLFxuICAgICAgLy8gYW5kIHdlIG5lZWQgdG8gdXNlIHRoZSBoaS1yZXMgdmVyc2lvbiBmb3IgZXZlbnQgbGlzdGVuZXIgdGltZXN0YW1wcyBhc1xuICAgICAgLy8gd2VsbC5cbiAgICAgIGdldE5vdyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpOyB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGbHVzaCBib3RoIHF1ZXVlcyBhbmQgcnVuIHRoZSB3YXRjaGVycy5cbiAgICovXG4gIGZ1bmN0aW9uIGZsdXNoU2NoZWR1bGVyUXVldWUgKCkge1xuICAgIGN1cnJlbnRGbHVzaFRpbWVzdGFtcCA9IGdldE5vdygpO1xuICAgIGZsdXNoaW5nID0gdHJ1ZTtcbiAgICB2YXIgd2F0Y2hlciwgaWQ7XG5cbiAgICAvLyBTb3J0IHF1ZXVlIGJlZm9yZSBmbHVzaC5cbiAgICAvLyBUaGlzIGVuc3VyZXMgdGhhdDpcbiAgICAvLyAxLiBDb21wb25lbnRzIGFyZSB1cGRhdGVkIGZyb20gcGFyZW50IHRvIGNoaWxkLiAoYmVjYXVzZSBwYXJlbnQgaXMgYWx3YXlzXG4gICAgLy8gICAgY3JlYXRlZCBiZWZvcmUgdGhlIGNoaWxkKVxuICAgIC8vIDIuIEEgY29tcG9uZW50J3MgdXNlciB3YXRjaGVycyBhcmUgcnVuIGJlZm9yZSBpdHMgcmVuZGVyIHdhdGNoZXIgKGJlY2F1c2VcbiAgICAvLyAgICB1c2VyIHdhdGNoZXJzIGFyZSBjcmVhdGVkIGJlZm9yZSB0aGUgcmVuZGVyIHdhdGNoZXIpXG4gICAgLy8gMy4gSWYgYSBjb21wb25lbnQgaXMgZGVzdHJveWVkIGR1cmluZyBhIHBhcmVudCBjb21wb25lbnQncyB3YXRjaGVyIHJ1bixcbiAgICAvLyAgICBpdHMgd2F0Y2hlcnMgY2FuIGJlIHNraXBwZWQuXG4gICAgcXVldWUuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5pZCAtIGIuaWQ7IH0pO1xuXG4gICAgLy8gZG8gbm90IGNhY2hlIGxlbmd0aCBiZWNhdXNlIG1vcmUgd2F0Y2hlcnMgbWlnaHQgYmUgcHVzaGVkXG4gICAgLy8gYXMgd2UgcnVuIGV4aXN0aW5nIHdhdGNoZXJzXG4gICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgcXVldWUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB3YXRjaGVyID0gcXVldWVbaW5kZXhdO1xuICAgICAgaWYgKHdhdGNoZXIuYmVmb3JlKSB7XG4gICAgICAgIHdhdGNoZXIuYmVmb3JlKCk7XG4gICAgICB9XG4gICAgICBpZCA9IHdhdGNoZXIuaWQ7XG4gICAgICBoYXNbaWRdID0gbnVsbDtcbiAgICAgIHdhdGNoZXIucnVuKCk7XG4gICAgICAvLyBpbiBkZXYgYnVpbGQsIGNoZWNrIGFuZCBzdG9wIGNpcmN1bGFyIHVwZGF0ZXMuXG4gICAgICBpZiAoaGFzW2lkXSAhPSBudWxsKSB7XG4gICAgICAgIGNpcmN1bGFyW2lkXSA9IChjaXJjdWxhcltpZF0gfHwgMCkgKyAxO1xuICAgICAgICBpZiAoY2lyY3VsYXJbaWRdID4gTUFYX1VQREFURV9DT1VOVCkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAnWW91IG1heSBoYXZlIGFuIGluZmluaXRlIHVwZGF0ZSBsb29wICcgKyAoXG4gICAgICAgICAgICAgIHdhdGNoZXIudXNlclxuICAgICAgICAgICAgICAgID8gKFwiaW4gd2F0Y2hlciB3aXRoIGV4cHJlc3Npb24gXFxcIlwiICsgKHdhdGNoZXIuZXhwcmVzc2lvbikgKyBcIlxcXCJcIilcbiAgICAgICAgICAgICAgICA6IFwiaW4gYSBjb21wb25lbnQgcmVuZGVyIGZ1bmN0aW9uLlwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgd2F0Y2hlci52bVxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGtlZXAgY29waWVzIG9mIHBvc3QgcXVldWVzIGJlZm9yZSByZXNldHRpbmcgc3RhdGVcbiAgICB2YXIgYWN0aXZhdGVkUXVldWUgPSBhY3RpdmF0ZWRDaGlsZHJlbi5zbGljZSgpO1xuICAgIHZhciB1cGRhdGVkUXVldWUgPSBxdWV1ZS5zbGljZSgpO1xuXG4gICAgcmVzZXRTY2hlZHVsZXJTdGF0ZSgpO1xuXG4gICAgLy8gY2FsbCBjb21wb25lbnQgdXBkYXRlZCBhbmQgYWN0aXZhdGVkIGhvb2tzXG4gICAgY2FsbEFjdGl2YXRlZEhvb2tzKGFjdGl2YXRlZFF1ZXVlKTtcbiAgICBjYWxsVXBkYXRlZEhvb2tzKHVwZGF0ZWRRdWV1ZSk7XG5cbiAgICAvLyBkZXZ0b29sIGhvb2tcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoZGV2dG9vbHMgJiYgY29uZmlnLmRldnRvb2xzKSB7XG4gICAgICBkZXZ0b29scy5lbWl0KCdmbHVzaCcpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGxVcGRhdGVkSG9va3MgKHF1ZXVlKSB7XG4gICAgdmFyIGkgPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFyIHdhdGNoZXIgPSBxdWV1ZVtpXTtcbiAgICAgIHZhciB2bSA9IHdhdGNoZXIudm07XG4gICAgICBpZiAodm0uX3dhdGNoZXIgPT09IHdhdGNoZXIgJiYgdm0uX2lzTW91bnRlZCAmJiAhdm0uX2lzRGVzdHJveWVkKSB7XG4gICAgICAgIGNhbGxIb29rKHZtLCAndXBkYXRlZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBRdWV1ZSBhIGtlcHQtYWxpdmUgY29tcG9uZW50IHRoYXQgd2FzIGFjdGl2YXRlZCBkdXJpbmcgcGF0Y2guXG4gICAqIFRoZSBxdWV1ZSB3aWxsIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgZW50aXJlIHRyZWUgaGFzIGJlZW4gcGF0Y2hlZC5cbiAgICovXG4gIGZ1bmN0aW9uIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50ICh2bSkge1xuICAgIC8vIHNldHRpbmcgX2luYWN0aXZlIHRvIGZhbHNlIGhlcmUgc28gdGhhdCBhIHJlbmRlciBmdW5jdGlvbiBjYW5cbiAgICAvLyByZWx5IG9uIGNoZWNraW5nIHdoZXRoZXIgaXQncyBpbiBhbiBpbmFjdGl2ZSB0cmVlIChlLmcuIHJvdXRlci12aWV3KVxuICAgIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGFjdGl2YXRlZENoaWxkcmVuLnB1c2godm0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FsbEFjdGl2YXRlZEhvb2tzIChxdWV1ZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHF1ZXVlW2ldLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHF1ZXVlW2ldLCB0cnVlIC8qIHRydWUgKi8pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQdXNoIGEgd2F0Y2hlciBpbnRvIHRoZSB3YXRjaGVyIHF1ZXVlLlxuICAgKiBKb2JzIHdpdGggZHVwbGljYXRlIElEcyB3aWxsIGJlIHNraXBwZWQgdW5sZXNzIGl0J3NcbiAgICogcHVzaGVkIHdoZW4gdGhlIHF1ZXVlIGlzIGJlaW5nIGZsdXNoZWQuXG4gICAqL1xuICBmdW5jdGlvbiBxdWV1ZVdhdGNoZXIgKHdhdGNoZXIpIHtcbiAgICB2YXIgaWQgPSB3YXRjaGVyLmlkO1xuICAgIGlmIChoYXNbaWRdID09IG51bGwpIHtcbiAgICAgIGhhc1tpZF0gPSB0cnVlO1xuICAgICAgaWYgKCFmbHVzaGluZykge1xuICAgICAgICBxdWV1ZS5wdXNoKHdhdGNoZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgYWxyZWFkeSBmbHVzaGluZywgc3BsaWNlIHRoZSB3YXRjaGVyIGJhc2VkIG9uIGl0cyBpZFxuICAgICAgICAvLyBpZiBhbHJlYWR5IHBhc3QgaXRzIGlkLCBpdCB3aWxsIGJlIHJ1biBuZXh0IGltbWVkaWF0ZWx5LlxuICAgICAgICB2YXIgaSA9IHF1ZXVlLmxlbmd0aCAtIDE7XG4gICAgICAgIHdoaWxlIChpID4gaW5kZXggJiYgcXVldWVbaV0uaWQgPiB3YXRjaGVyLmlkKSB7XG4gICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICAgIHF1ZXVlLnNwbGljZShpICsgMSwgMCwgd2F0Y2hlcik7XG4gICAgICB9XG4gICAgICAvLyBxdWV1ZSB0aGUgZmx1c2hcbiAgICAgIGlmICghd2FpdGluZykge1xuICAgICAgICB3YWl0aW5nID0gdHJ1ZTtcblxuICAgICAgICBpZiAoIWNvbmZpZy5hc3luYykge1xuICAgICAgICAgIGZsdXNoU2NoZWR1bGVyUXVldWUoKTtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBuZXh0VGljayhmbHVzaFNjaGVkdWxlclF1ZXVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuXG5cbiAgdmFyIHVpZCQyID0gMDtcblxuICAvKipcbiAgICogQSB3YXRjaGVyIHBhcnNlcyBhbiBleHByZXNzaW9uLCBjb2xsZWN0cyBkZXBlbmRlbmNpZXMsXG4gICAqIGFuZCBmaXJlcyBjYWxsYmFjayB3aGVuIHRoZSBleHByZXNzaW9uIHZhbHVlIGNoYW5nZXMuXG4gICAqIFRoaXMgaXMgdXNlZCBmb3IgYm90aCB0aGUgJHdhdGNoKCkgYXBpIGFuZCBkaXJlY3RpdmVzLlxuICAgKi9cbiAgdmFyIFdhdGNoZXIgPSBmdW5jdGlvbiBXYXRjaGVyIChcbiAgICB2bSxcbiAgICBleHBPckZuLFxuICAgIGNiLFxuICAgIG9wdGlvbnMsXG4gICAgaXNSZW5kZXJXYXRjaGVyXG4gICkge1xuICAgIHRoaXMudm0gPSB2bTtcbiAgICBpZiAoaXNSZW5kZXJXYXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlciA9IHRoaXM7XG4gICAgfVxuICAgIHZtLl93YXRjaGVycy5wdXNoKHRoaXMpO1xuICAgIC8vIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgdGhpcy5kZWVwID0gISFvcHRpb25zLmRlZXA7XG4gICAgICB0aGlzLnVzZXIgPSAhIW9wdGlvbnMudXNlcjtcbiAgICAgIHRoaXMubGF6eSA9ICEhb3B0aW9ucy5sYXp5O1xuICAgICAgdGhpcy5zeW5jID0gISFvcHRpb25zLnN5bmM7XG4gICAgICB0aGlzLmJlZm9yZSA9IG9wdGlvbnMuYmVmb3JlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlZXAgPSB0aGlzLnVzZXIgPSB0aGlzLmxhenkgPSB0aGlzLnN5bmMgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5jYiA9IGNiO1xuICAgIHRoaXMuaWQgPSArK3VpZCQyOyAvLyB1aWQgZm9yIGJhdGNoaW5nXG4gICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgIHRoaXMuZGlydHkgPSB0aGlzLmxhenk7IC8vIGZvciBsYXp5IHdhdGNoZXJzXG4gICAgdGhpcy5kZXBzID0gW107XG4gICAgdGhpcy5uZXdEZXBzID0gW107XG4gICAgdGhpcy5kZXBJZHMgPSBuZXcgX1NldCgpO1xuICAgIHRoaXMubmV3RGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgICB0aGlzLmV4cHJlc3Npb24gPSBleHBPckZuLnRvU3RyaW5nKCk7XG4gICAgLy8gcGFyc2UgZXhwcmVzc2lvbiBmb3IgZ2V0dGVyXG4gICAgaWYgKHR5cGVvZiBleHBPckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLmdldHRlciA9IGV4cE9yRm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZ2V0dGVyID0gcGFyc2VQYXRoKGV4cE9yRm4pO1xuICAgICAgaWYgKCF0aGlzLmdldHRlcikge1xuICAgICAgICB0aGlzLmdldHRlciA9IG5vb3A7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJGYWlsZWQgd2F0Y2hpbmcgcGF0aDogXFxcIlwiICsgZXhwT3JGbiArIFwiXFxcIiBcIiArXG4gICAgICAgICAgJ1dhdGNoZXIgb25seSBhY2NlcHRzIHNpbXBsZSBkb3QtZGVsaW1pdGVkIHBhdGhzLiAnICtcbiAgICAgICAgICAnRm9yIGZ1bGwgY29udHJvbCwgdXNlIGEgZnVuY3Rpb24gaW5zdGVhZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudmFsdWUgPSB0aGlzLmxhenlcbiAgICAgID8gdW5kZWZpbmVkXG4gICAgICA6IHRoaXMuZ2V0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEV2YWx1YXRlIHRoZSBnZXR0ZXIsIGFuZCByZS1jb2xsZWN0IGRlcGVuZGVuY2llcy5cbiAgICovXG4gIFdhdGNoZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgcHVzaFRhcmdldCh0aGlzKTtcbiAgICB2YXIgdmFsdWU7XG4gICAgdmFyIHZtID0gdGhpcy52bTtcbiAgICB0cnkge1xuICAgICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKHRoaXMudXNlcikge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKFwiZ2V0dGVyIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgLy8gXCJ0b3VjaFwiIGV2ZXJ5IHByb3BlcnR5IHNvIHRoZXkgYXJlIGFsbCB0cmFja2VkIGFzXG4gICAgICAvLyBkZXBlbmRlbmNpZXMgZm9yIGRlZXAgd2F0Y2hpbmdcbiAgICAgIGlmICh0aGlzLmRlZXApIHtcbiAgICAgICAgdHJhdmVyc2UodmFsdWUpO1xuICAgICAgfVxuICAgICAgcG9wVGFyZ2V0KCk7XG4gICAgICB0aGlzLmNsZWFudXBEZXBzKCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZVxuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYSBkZXBlbmRlbmN5IHRvIHRoaXMgZGlyZWN0aXZlLlxuICAgKi9cbiAgV2F0Y2hlci5wcm90b3R5cGUuYWRkRGVwID0gZnVuY3Rpb24gYWRkRGVwIChkZXApIHtcbiAgICB2YXIgaWQgPSBkZXAuaWQ7XG4gICAgaWYgKCF0aGlzLm5ld0RlcElkcy5oYXMoaWQpKSB7XG4gICAgICB0aGlzLm5ld0RlcElkcy5hZGQoaWQpO1xuICAgICAgdGhpcy5uZXdEZXBzLnB1c2goZGVwKTtcbiAgICAgIGlmICghdGhpcy5kZXBJZHMuaGFzKGlkKSkge1xuICAgICAgICBkZXAuYWRkU3ViKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2xlYW4gdXAgZm9yIGRlcGVuZGVuY3kgY29sbGVjdGlvbi5cbiAgICovXG4gIFdhdGNoZXIucHJvdG90eXBlLmNsZWFudXBEZXBzID0gZnVuY3Rpb24gY2xlYW51cERlcHMgKCkge1xuICAgIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YXIgZGVwID0gdGhpcy5kZXBzW2ldO1xuICAgICAgaWYgKCF0aGlzLm5ld0RlcElkcy5oYXMoZGVwLmlkKSkge1xuICAgICAgICBkZXAucmVtb3ZlU3ViKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgdG1wID0gdGhpcy5kZXBJZHM7XG4gICAgdGhpcy5kZXBJZHMgPSB0aGlzLm5ld0RlcElkcztcbiAgICB0aGlzLm5ld0RlcElkcyA9IHRtcDtcbiAgICB0aGlzLm5ld0RlcElkcy5jbGVhcigpO1xuICAgIHRtcCA9IHRoaXMuZGVwcztcbiAgICB0aGlzLmRlcHMgPSB0aGlzLm5ld0RlcHM7XG4gICAgdGhpcy5uZXdEZXBzID0gdG1wO1xuICAgIHRoaXMubmV3RGVwcy5sZW5ndGggPSAwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdWJzY3JpYmVyIGludGVyZmFjZS5cbiAgICogV2lsbCBiZSBjYWxsZWQgd2hlbiBhIGRlcGVuZGVuY3kgY2hhbmdlcy5cbiAgICovXG4gIFdhdGNoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAodGhpcy5sYXp5KSB7XG4gICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3luYykge1xuICAgICAgdGhpcy5ydW4oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcXVldWVXYXRjaGVyKHRoaXMpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2NoZWR1bGVyIGpvYiBpbnRlcmZhY2UuXG4gICAqIFdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIuXG4gICAqL1xuICBXYXRjaGVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiBydW4gKCkge1xuICAgIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy5nZXQoKTtcbiAgICAgIGlmIChcbiAgICAgICAgdmFsdWUgIT09IHRoaXMudmFsdWUgfHxcbiAgICAgICAgLy8gRGVlcCB3YXRjaGVycyBhbmQgd2F0Y2hlcnMgb24gT2JqZWN0L0FycmF5cyBzaG91bGQgZmlyZSBldmVuXG4gICAgICAgIC8vIHdoZW4gdGhlIHZhbHVlIGlzIHRoZSBzYW1lLCBiZWNhdXNlIHRoZSB2YWx1ZSBtYXlcbiAgICAgICAgLy8gaGF2ZSBtdXRhdGVkLlxuICAgICAgICBpc09iamVjdCh2YWx1ZSkgfHxcbiAgICAgICAgdGhpcy5kZWVwXG4gICAgICApIHtcbiAgICAgICAgLy8gc2V0IG5ldyB2YWx1ZVxuICAgICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLnVzZXIpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdGhpcy52bSwgKFwiY2FsbGJhY2sgZm9yIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRXZhbHVhdGUgdGhlIHZhbHVlIG9mIHRoZSB3YXRjaGVyLlxuICAgKiBUaGlzIG9ubHkgZ2V0cyBjYWxsZWQgZm9yIGxhenkgd2F0Y2hlcnMuXG4gICAqL1xuICBXYXRjaGVyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlICgpIHtcbiAgICB0aGlzLnZhbHVlID0gdGhpcy5nZXQoKTtcbiAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlcGVuZCBvbiBhbGwgZGVwcyBjb2xsZWN0ZWQgYnkgdGhpcyB3YXRjaGVyLlxuICAgKi9cbiAgV2F0Y2hlci5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdGhpcy5kZXBzW2ldLmRlcGVuZCgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIHNlbGYgZnJvbSBhbGwgZGVwZW5kZW5jaWVzJyBzdWJzY3JpYmVyIGxpc3QuXG4gICAqL1xuICBXYXRjaGVyLnByb3RvdHlwZS50ZWFyZG93biA9IGZ1bmN0aW9uIHRlYXJkb3duICgpIHtcbiAgICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gdm0ncyB3YXRjaGVyIGxpc3RcbiAgICAgIC8vIHRoaXMgaXMgYSBzb21ld2hhdCBleHBlbnNpdmUgb3BlcmF0aW9uIHNvIHdlIHNraXAgaXRcbiAgICAgIC8vIGlmIHRoZSB2bSBpcyBiZWluZyBkZXN0cm95ZWQuXG4gICAgICBpZiAoIXRoaXMudm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgICAgcmVtb3ZlKHRoaXMudm0uX3dhdGNoZXJzLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdGhpcy5kZXBzW2ldLnJlbW92ZVN1Yih0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIC8qICAqL1xuXG4gIHZhciBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24gPSB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBub29wLFxuICAgIHNldDogbm9vcFxuICB9O1xuXG4gIGZ1bmN0aW9uIHByb3h5ICh0YXJnZXQsIHNvdXJjZUtleSwga2V5KSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IGZ1bmN0aW9uIHByb3h5R2V0dGVyICgpIHtcbiAgICAgIHJldHVybiB0aGlzW3NvdXJjZUtleV1ba2V5XVxuICAgIH07XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uIHByb3h5U2V0dGVyICh2YWwpIHtcbiAgICAgIHRoaXNbc291cmNlS2V5XVtrZXldID0gdmFsO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdFN0YXRlICh2bSkge1xuICAgIHZtLl93YXRjaGVycyA9IFtdO1xuICAgIHZhciBvcHRzID0gdm0uJG9wdGlvbnM7XG4gICAgaWYgKG9wdHMucHJvcHMpIHsgaW5pdFByb3BzKHZtLCBvcHRzLnByb3BzKTsgfVxuICAgIGlmIChvcHRzLm1ldGhvZHMpIHsgaW5pdE1ldGhvZHModm0sIG9wdHMubWV0aG9kcyk7IH1cbiAgICBpZiAob3B0cy5kYXRhKSB7XG4gICAgICBpbml0RGF0YSh2bSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ic2VydmUodm0uX2RhdGEgPSB7fSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbiAgICB9XG4gICAgaWYgKG9wdHMuY29tcHV0ZWQpIHsgaW5pdENvbXB1dGVkKHZtLCBvcHRzLmNvbXB1dGVkKTsgfVxuICAgIGlmIChvcHRzLndhdGNoICYmIG9wdHMud2F0Y2ggIT09IG5hdGl2ZVdhdGNoKSB7XG4gICAgICBpbml0V2F0Y2godm0sIG9wdHMud2F0Y2gpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRQcm9wcyAodm0sIHByb3BzT3B0aW9ucykge1xuICAgIHZhciBwcm9wc0RhdGEgPSB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgfHwge307XG4gICAgdmFyIHByb3BzID0gdm0uX3Byb3BzID0ge307XG4gICAgLy8gY2FjaGUgcHJvcCBrZXlzIHNvIHRoYXQgZnV0dXJlIHByb3BzIHVwZGF0ZXMgY2FuIGl0ZXJhdGUgdXNpbmcgQXJyYXlcbiAgICAvLyBpbnN0ZWFkIG9mIGR5bmFtaWMgb2JqZWN0IGtleSBlbnVtZXJhdGlvbi5cbiAgICB2YXIga2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyA9IFtdO1xuICAgIHZhciBpc1Jvb3QgPSAhdm0uJHBhcmVudDtcbiAgICAvLyByb290IGluc3RhbmNlIHByb3BzIHNob3VsZCBiZSBjb252ZXJ0ZWRcbiAgICBpZiAoIWlzUm9vdCkge1xuICAgICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcbiAgICB9XG4gICAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgdmFyIHZhbHVlID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcHNPcHRpb25zLCBwcm9wc0RhdGEsIHZtKTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICB7XG4gICAgICAgIHZhciBoeXBoZW5hdGVkS2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICAgIGlmIChpc1Jlc2VydmVkQXR0cmlidXRlKGh5cGhlbmF0ZWRLZXkpIHx8XG4gICAgICAgICAgICBjb25maWcuaXNSZXNlcnZlZEF0dHIoaHlwaGVuYXRlZEtleSkpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgKFwiXFxcIlwiICsgaHlwaGVuYXRlZEtleSArIFwiXFxcIiBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZSBhbmQgY2Fubm90IGJlIHVzZWQgYXMgY29tcG9uZW50IHByb3AuXCIpLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHByb3BzLCBrZXksIHZhbHVlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKCFpc1Jvb3QgJiYgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhIHByb3AgZGlyZWN0bHkgc2luY2UgdGhlIHZhbHVlIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgICBcIm92ZXJ3cml0dGVuIHdoZW5ldmVyIHRoZSBwYXJlbnQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcbiAgICAgICAgICAgICAgXCJJbnN0ZWFkLCB1c2UgYSBkYXRhIG9yIGNvbXB1dGVkIHByb3BlcnR5IGJhc2VkIG9uIHRoZSBwcm9wJ3MgXCIgK1xuICAgICAgICAgICAgICBcInZhbHVlLiBQcm9wIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgICB2bVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLy8gc3RhdGljIHByb3BzIGFyZSBhbHJlYWR5IHByb3hpZWQgb24gdGhlIGNvbXBvbmVudCdzIHByb3RvdHlwZVxuICAgICAgLy8gZHVyaW5nIFZ1ZS5leHRlbmQoKS4gV2Ugb25seSBuZWVkIHRvIHByb3h5IHByb3BzIGRlZmluZWQgYXRcbiAgICAgIC8vIGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgICAgcHJveHkodm0sIFwiX3Byb3BzXCIsIGtleSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAodmFyIGtleSBpbiBwcm9wc09wdGlvbnMpIGxvb3AoIGtleSApO1xuICAgIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXREYXRhICh2bSkge1xuICAgIHZhciBkYXRhID0gdm0uJG9wdGlvbnMuZGF0YTtcbiAgICBkYXRhID0gdm0uX2RhdGEgPSB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBnZXREYXRhKGRhdGEsIHZtKVxuICAgICAgOiBkYXRhIHx8IHt9O1xuICAgIGlmICghaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgICAgZGF0YSA9IHt9O1xuICAgICAgd2FybihcbiAgICAgICAgJ2RhdGEgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0OlxcbicgK1xuICAgICAgICAnaHR0cHM6Ly92dWVqcy5vcmcvdjIvZ3VpZGUvY29tcG9uZW50cy5odG1sI2RhdGEtTXVzdC1CZS1hLUZ1bmN0aW9uJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICAgIC8vIHByb3h5IGRhdGEgb24gaW5zdGFuY2VcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICAgIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICAgIHZhciBtZXRob2RzID0gdm0uJG9wdGlvbnMubWV0aG9kcztcbiAgICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAge1xuICAgICAgICBpZiAobWV0aG9kcyAmJiBoYXNPd24obWV0aG9kcywga2V5KSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAoXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIGRhdGEgcHJvcGVydHkuXCIpLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJUaGUgZGF0YSBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWNsYXJlZCBhcyBhIHByb3AuIFwiICtcbiAgICAgICAgICBcIlVzZSBwcm9wIGRlZmF1bHQgdmFsdWUgaW5zdGVhZC5cIixcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmICghaXNSZXNlcnZlZChrZXkpKSB7XG4gICAgICAgIHByb3h5KHZtLCBcIl9kYXRhXCIsIGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIG9ic2VydmUgZGF0YVxuICAgIG9ic2VydmUoZGF0YSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldERhdGEgKGRhdGEsIHZtKSB7XG4gICAgLy8gIzc1NzMgZGlzYWJsZSBkZXAgY29sbGVjdGlvbiB3aGVuIGludm9raW5nIGRhdGEgZ2V0dGVyc1xuICAgIHB1c2hUYXJnZXQoKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGRhdGEuY2FsbCh2bSwgdm0pXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwiZGF0YSgpXCIpO1xuICAgICAgcmV0dXJuIHt9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHBvcFRhcmdldCgpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb21wdXRlZFdhdGNoZXJPcHRpb25zID0geyBsYXp5OiB0cnVlIH07XG5cbiAgZnVuY3Rpb24gaW5pdENvbXB1dGVkICh2bSwgY29tcHV0ZWQpIHtcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICB2YXIgd2F0Y2hlcnMgPSB2bS5fY29tcHV0ZWRXYXRjaGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgLy8gY29tcHV0ZWQgcHJvcGVydGllcyBhcmUganVzdCBnZXR0ZXJzIGR1cmluZyBTU1JcbiAgICB2YXIgaXNTU1IgPSBpc1NlcnZlclJlbmRlcmluZygpO1xuXG4gICAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgICB2YXIgdXNlckRlZiA9IGNvbXB1dGVkW2tleV07XG4gICAgICB2YXIgZ2V0dGVyID0gdHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicgPyB1c2VyRGVmIDogdXNlckRlZi5nZXQ7XG4gICAgICBpZiAoZ2V0dGVyID09IG51bGwpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJHZXR0ZXIgaXMgbWlzc2luZyBmb3IgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzU1NSKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBpbnRlcm5hbCB3YXRjaGVyIGZvciB0aGUgY29tcHV0ZWQgcHJvcGVydHkuXG4gICAgICAgIHdhdGNoZXJzW2tleV0gPSBuZXcgV2F0Y2hlcihcbiAgICAgICAgICB2bSxcbiAgICAgICAgICBnZXR0ZXIgfHwgbm9vcCxcbiAgICAgICAgICBub29wLFxuICAgICAgICAgIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnNcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gY29tcG9uZW50LWRlZmluZWQgY29tcHV0ZWQgcHJvcGVydGllcyBhcmUgYWxyZWFkeSBkZWZpbmVkIG9uIHRoZVxuICAgICAgLy8gY29tcG9uZW50IHByb3RvdHlwZS4gV2Ugb25seSBuZWVkIHRvIGRlZmluZSBjb21wdXRlZCBwcm9wZXJ0aWVzIGRlZmluZWRcbiAgICAgIC8vIGF0IGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgICAgZGVmaW5lQ29tcHV0ZWQodm0sIGtleSwgdXNlckRlZik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoa2V5IGluIHZtLiRkYXRhKSB7XG4gICAgICAgICAgd2FybigoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBpbiBkYXRhLlwiKSwgdm0pO1xuICAgICAgICB9IGVsc2UgaWYgKHZtLiRvcHRpb25zLnByb3BzICYmIGtleSBpbiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgICAgICAgIHdhcm4oKFwiVGhlIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgYXMgYSBwcm9wLlwiKSwgdm0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGVmaW5lQ29tcHV0ZWQgKFxuICAgIHRhcmdldCxcbiAgICBrZXksXG4gICAgdXNlckRlZlxuICApIHtcbiAgICB2YXIgc2hvdWxkQ2FjaGUgPSAhaXNTZXJ2ZXJSZW5kZXJpbmcoKTtcbiAgICBpZiAodHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBzaG91bGRDYWNoZVxuICAgICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcbiAgICAgICAgOiBjcmVhdGVHZXR0ZXJJbnZva2VyKHVzZXJEZWYpO1xuICAgICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IG5vb3A7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSB1c2VyRGVmLmdldFxuICAgICAgICA/IHNob3VsZENhY2hlICYmIHVzZXJEZWYuY2FjaGUgIT09IGZhbHNlXG4gICAgICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXG4gICAgICAgICAgOiBjcmVhdGVHZXR0ZXJJbnZva2VyKHVzZXJEZWYuZ2V0KVxuICAgICAgICA6IG5vb3A7XG4gICAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gdXNlckRlZi5zZXQgfHwgbm9vcDtcbiAgICB9XG4gICAgaWYgKHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPT09IG5vb3ApIHtcbiAgICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiQ29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIHdhcyBhc3NpZ25lZCB0byBidXQgaXQgaGFzIG5vIHNldHRlci5cIiksXG4gICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIgKGtleSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBjb21wdXRlZEdldHRlciAoKSB7XG4gICAgICB2YXIgd2F0Y2hlciA9IHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnMgJiYgdGhpcy5fY29tcHV0ZWRXYXRjaGVyc1trZXldO1xuICAgICAgaWYgKHdhdGNoZXIpIHtcbiAgICAgICAgaWYgKHdhdGNoZXIuZGlydHkpIHtcbiAgICAgICAgICB3YXRjaGVyLmV2YWx1YXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgICB3YXRjaGVyLmRlcGVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3YXRjaGVyLnZhbHVlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlR2V0dGVySW52b2tlcihmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiBjb21wdXRlZEdldHRlciAoKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCB0aGlzKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRNZXRob2RzICh2bSwgbWV0aG9kcykge1xuICAgIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICAgIGZvciAodmFyIGtleSBpbiBtZXRob2RzKSB7XG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kc1trZXldICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgdHlwZSBcXFwiXCIgKyAodHlwZW9mIG1ldGhvZHNba2V5XSkgKyBcIlxcXCIgaW4gdGhlIGNvbXBvbmVudCBkZWZpbml0aW9uLiBcIiArXG4gICAgICAgICAgICBcIkRpZCB5b3UgcmVmZXJlbmNlIHRoZSBmdW5jdGlvbiBjb3JyZWN0bHk/XCIsXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAoXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIHByb3AuXCIpLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoa2V5IGluIHZtKSAmJiBpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGNvbmZsaWN0cyB3aXRoIGFuIGV4aXN0aW5nIFZ1ZSBpbnN0YW5jZSBtZXRob2QuIFwiICtcbiAgICAgICAgICAgIFwiQXZvaWQgZGVmaW5pbmcgY29tcG9uZW50IG1ldGhvZHMgdGhhdCBzdGFydCB3aXRoIF8gb3IgJC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZtW2tleV0gPSB0eXBlb2YgbWV0aG9kc1trZXldICE9PSAnZnVuY3Rpb24nID8gbm9vcCA6IGJpbmQobWV0aG9kc1trZXldLCB2bSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdFdhdGNoICh2bSwgd2F0Y2gpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gd2F0Y2gpIHtcbiAgICAgIHZhciBoYW5kbGVyID0gd2F0Y2hba2V5XTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcltpXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlV2F0Y2hlciAoXG4gICAgdm0sXG4gICAgZXhwT3JGbixcbiAgICBoYW5kbGVyLFxuICAgIG9wdGlvbnNcbiAgKSB7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QoaGFuZGxlcikpIHtcbiAgICAgIG9wdGlvbnMgPSBoYW5kbGVyO1xuICAgICAgaGFuZGxlciA9IGhhbmRsZXIuaGFuZGxlcjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnc3RyaW5nJykge1xuICAgICAgaGFuZGxlciA9IHZtW2hhbmRsZXJdO1xuICAgIH1cbiAgICByZXR1cm4gdm0uJHdhdGNoKGV4cE9yRm4sIGhhbmRsZXIsIG9wdGlvbnMpXG4gIH1cblxuICBmdW5jdGlvbiBzdGF0ZU1peGluIChWdWUpIHtcbiAgICAvLyBmbG93IHNvbWVob3cgaGFzIHByb2JsZW1zIHdpdGggZGlyZWN0bHkgZGVjbGFyZWQgZGVmaW5pdGlvbiBvYmplY3RcbiAgICAvLyB3aGVuIHVzaW5nIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgc28gd2UgaGF2ZSB0byBwcm9jZWR1cmFsbHkgYnVpbGQgdXBcbiAgICAvLyB0aGUgb2JqZWN0IGhlcmUuXG4gICAgdmFyIGRhdGFEZWYgPSB7fTtcbiAgICBkYXRhRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RhdGEgfTtcbiAgICB2YXIgcHJvcHNEZWYgPSB7fTtcbiAgICBwcm9wc0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wcm9wcyB9O1xuICAgIHtcbiAgICAgIGRhdGFEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdBdm9pZCByZXBsYWNpbmcgaW5zdGFuY2Ugcm9vdCAkZGF0YS4gJyArXG4gICAgICAgICAgJ1VzZSBuZXN0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluc3RlYWQuJyxcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICB9O1xuICAgICAgcHJvcHNEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB3YXJuKFwiJHByb3BzIGlzIHJlYWRvbmx5LlwiLCB0aGlzKTtcbiAgICAgIH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGRhdGEnLCBkYXRhRGVmKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRwcm9wcycsIHByb3BzRGVmKTtcblxuICAgIFZ1ZS5wcm90b3R5cGUuJHNldCA9IHNldDtcbiAgICBWdWUucHJvdG90eXBlLiRkZWxldGUgPSBkZWw7XG5cbiAgICBWdWUucHJvdG90eXBlLiR3YXRjaCA9IGZ1bmN0aW9uIChcbiAgICAgIGV4cE9yRm4sXG4gICAgICBjYixcbiAgICAgIG9wdGlvbnNcbiAgICApIHtcbiAgICAgIHZhciB2bSA9IHRoaXM7XG4gICAgICBpZiAoaXNQbGFpbk9iamVjdChjYikpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKVxuICAgICAgfVxuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICBvcHRpb25zLnVzZXIgPSB0cnVlO1xuICAgICAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMuaW1tZWRpYXRlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2IuY2FsbCh2bSwgd2F0Y2hlci52YWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZXJyb3IsIHZtLCAoXCJjYWxsYmFjayBmb3IgaW1tZWRpYXRlIHdhdGNoZXIgXFxcIlwiICsgKHdhdGNoZXIuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gdW53YXRjaEZuICgpIHtcbiAgICAgICAgd2F0Y2hlci50ZWFyZG93bigpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKiAgKi9cblxuICB2YXIgdWlkJDMgPSAwO1xuXG4gIGZ1bmN0aW9uIGluaXRNaXhpbiAoVnVlKSB7XG4gICAgVnVlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICB2YXIgdm0gPSB0aGlzO1xuICAgICAgLy8gYSB1aWRcbiAgICAgIHZtLl91aWQgPSB1aWQkMysrO1xuXG4gICAgICB2YXIgc3RhcnRUYWcsIGVuZFRhZztcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICAgIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArICh2bS5fdWlkKTtcbiAgICAgICAgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyAodm0uX3VpZCk7XG4gICAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgfVxuXG4gICAgICAvLyBhIGZsYWcgdG8gYXZvaWQgdGhpcyBiZWluZyBvYnNlcnZlZFxuICAgICAgdm0uX2lzVnVlID0gdHJ1ZTtcbiAgICAgIC8vIG1lcmdlIG9wdGlvbnNcbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2lzQ29tcG9uZW50KSB7XG4gICAgICAgIC8vIG9wdGltaXplIGludGVybmFsIGNvbXBvbmVudCBpbnN0YW50aWF0aW9uXG4gICAgICAgIC8vIHNpbmNlIGR5bmFtaWMgb3B0aW9ucyBtZXJnaW5nIGlzIHByZXR0eSBzbG93LCBhbmQgbm9uZSBvZiB0aGVcbiAgICAgICAgLy8gaW50ZXJuYWwgY29tcG9uZW50IG9wdGlvbnMgbmVlZHMgc3BlY2lhbCB0cmVhdG1lbnQuXG4gICAgICAgIGluaXRJbnRlcm5hbENvbXBvbmVudCh2bSwgb3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bS4kb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICAgICAgICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKHZtLmNvbnN0cnVjdG9yKSxcbiAgICAgICAgICBvcHRpb25zIHx8IHt9LFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAge1xuICAgICAgICBpbml0UHJveHkodm0pO1xuICAgICAgfVxuICAgICAgLy8gZXhwb3NlIHJlYWwgc2VsZlxuICAgICAgdm0uX3NlbGYgPSB2bTtcbiAgICAgIGluaXRMaWZlY3ljbGUodm0pO1xuICAgICAgaW5pdEV2ZW50cyh2bSk7XG4gICAgICBpbml0UmVuZGVyKHZtKTtcbiAgICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlQ3JlYXRlJyk7XG4gICAgICBpbml0SW5qZWN0aW9ucyh2bSk7IC8vIHJlc29sdmUgaW5qZWN0aW9ucyBiZWZvcmUgZGF0YS9wcm9wc1xuICAgICAgaW5pdFN0YXRlKHZtKTtcbiAgICAgIGluaXRQcm92aWRlKHZtKTsgLy8gcmVzb2x2ZSBwcm92aWRlIGFmdGVyIGRhdGEvcHJvcHNcbiAgICAgIGNhbGxIb29rKHZtLCAnY3JlYXRlZCcpO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICB2bS5fbmFtZSA9IGZvcm1hdENvbXBvbmVudE5hbWUodm0sIGZhbHNlKTtcbiAgICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgICBtZWFzdXJlKChcInZ1ZSBcIiArICh2bS5fbmFtZSkgKyBcIiBpbml0XCIpLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZtLiRvcHRpb25zLmVsKSB7XG4gICAgICAgIHZtLiRtb3VudCh2bS4kb3B0aW9ucy5lbCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRJbnRlcm5hbENvbXBvbmVudCAodm0sIG9wdGlvbnMpIHtcbiAgICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh2bS5jb25zdHJ1Y3Rvci5vcHRpb25zKTtcbiAgICAvLyBkb2luZyB0aGlzIGJlY2F1c2UgaXQncyBmYXN0ZXIgdGhhbiBkeW5hbWljIGVudW1lcmF0aW9uLlxuICAgIHZhciBwYXJlbnRWbm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlO1xuICAgIG9wdHMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gICAgb3B0cy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcblxuICAgIHZhciB2bm9kZUNvbXBvbmVudE9wdGlvbnMgPSBwYXJlbnRWbm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIG9wdHMucHJvcHNEYXRhID0gdm5vZGVDb21wb25lbnRPcHRpb25zLnByb3BzRGF0YTtcbiAgICBvcHRzLl9wYXJlbnRMaXN0ZW5lcnMgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMubGlzdGVuZXJzO1xuICAgIG9wdHMuX3JlbmRlckNoaWxkcmVuID0gdm5vZGVDb21wb25lbnRPcHRpb25zLmNoaWxkcmVuO1xuICAgIG9wdHMuX2NvbXBvbmVudFRhZyA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy50YWc7XG5cbiAgICBpZiAob3B0aW9ucy5yZW5kZXIpIHtcbiAgICAgIG9wdHMucmVuZGVyID0gb3B0aW9ucy5yZW5kZXI7XG4gICAgICBvcHRzLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMgKEN0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgICBpZiAoQ3Rvci5zdXBlcikge1xuICAgICAgdmFyIHN1cGVyT3B0aW9ucyA9IHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvci5zdXBlcik7XG4gICAgICB2YXIgY2FjaGVkU3VwZXJPcHRpb25zID0gQ3Rvci5zdXBlck9wdGlvbnM7XG4gICAgICBpZiAoc3VwZXJPcHRpb25zICE9PSBjYWNoZWRTdXBlck9wdGlvbnMpIHtcbiAgICAgICAgLy8gc3VwZXIgb3B0aW9uIGNoYW5nZWQsXG4gICAgICAgIC8vIG5lZWQgdG8gcmVzb2x2ZSBuZXcgb3B0aW9ucy5cbiAgICAgICAgQ3Rvci5zdXBlck9wdGlvbnMgPSBzdXBlck9wdGlvbnM7XG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBhbnkgbGF0ZS1tb2RpZmllZC9hdHRhY2hlZCBvcHRpb25zICgjNDk3NilcbiAgICAgICAgdmFyIG1vZGlmaWVkT3B0aW9ucyA9IHJlc29sdmVNb2RpZmllZE9wdGlvbnMoQ3Rvcik7XG4gICAgICAgIC8vIHVwZGF0ZSBiYXNlIGV4dGVuZCBvcHRpb25zXG4gICAgICAgIGlmIChtb2RpZmllZE9wdGlvbnMpIHtcbiAgICAgICAgICBleHRlbmQoQ3Rvci5leHRlbmRPcHRpb25zLCBtb2RpZmllZE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoc3VwZXJPcHRpb25zLCBDdG9yLmV4dGVuZE9wdGlvbnMpO1xuICAgICAgICBpZiAob3B0aW9ucy5uYW1lKSB7XG4gICAgICAgICAgb3B0aW9ucy5jb21wb25lbnRzW29wdGlvbnMubmFtZV0gPSBDdG9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zXG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlTW9kaWZpZWRPcHRpb25zIChDdG9yKSB7XG4gICAgdmFyIG1vZGlmaWVkO1xuICAgIHZhciBsYXRlc3QgPSBDdG9yLm9wdGlvbnM7XG4gICAgdmFyIHNlYWxlZCA9IEN0b3Iuc2VhbGVkT3B0aW9ucztcbiAgICBmb3IgKHZhciBrZXkgaW4gbGF0ZXN0KSB7XG4gICAgICBpZiAobGF0ZXN0W2tleV0gIT09IHNlYWxlZFtrZXldKSB7XG4gICAgICAgIGlmICghbW9kaWZpZWQpIHsgbW9kaWZpZWQgPSB7fTsgfVxuICAgICAgICBtb2RpZmllZFtrZXldID0gbGF0ZXN0W2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtb2RpZmllZFxuICB9XG5cbiAgZnVuY3Rpb24gVnVlIChvcHRpb25zKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFZ1ZSlcbiAgICApIHtcbiAgICAgIHdhcm4oJ1Z1ZSBpcyBhIGNvbnN0cnVjdG9yIGFuZCBzaG91bGQgYmUgY2FsbGVkIHdpdGggdGhlIGBuZXdgIGtleXdvcmQnKTtcbiAgICB9XG4gICAgdGhpcy5faW5pdChvcHRpb25zKTtcbiAgfVxuXG4gIGluaXRNaXhpbihWdWUpO1xuICBzdGF0ZU1peGluKFZ1ZSk7XG4gIGV2ZW50c01peGluKFZ1ZSk7XG4gIGxpZmVjeWNsZU1peGluKFZ1ZSk7XG4gIHJlbmRlck1peGluKFZ1ZSk7XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gaW5pdFVzZSAoVnVlKSB7XG4gICAgVnVlLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgIHZhciBpbnN0YWxsZWRQbHVnaW5zID0gKHRoaXMuX2luc3RhbGxlZFBsdWdpbnMgfHwgKHRoaXMuX2luc3RhbGxlZFBsdWdpbnMgPSBbXSkpO1xuICAgICAgaWYgKGluc3RhbGxlZFBsdWdpbnMuaW5kZXhPZihwbHVnaW4pID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cblxuICAgICAgLy8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzXG4gICAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICAgIGlmICh0eXBlb2YgcGx1Z2luLmluc3RhbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcGx1Z2luLmluc3RhbGwuYXBwbHkocGx1Z2luLCBhcmdzKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBsdWdpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwbHVnaW4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICB9XG4gICAgICBpbnN0YWxsZWRQbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfTtcbiAgfVxuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIGluaXRNaXhpbiQxIChWdWUpIHtcbiAgICBWdWUubWl4aW4gPSBmdW5jdGlvbiAobWl4aW4pIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG1peGluKTtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfTtcbiAgfVxuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIGluaXRFeHRlbmQgKFZ1ZSkge1xuICAgIC8qKlxuICAgICAqIEVhY2ggaW5zdGFuY2UgY29uc3RydWN0b3IsIGluY2x1ZGluZyBWdWUsIGhhcyBhIHVuaXF1ZVxuICAgICAqIGNpZC4gVGhpcyBlbmFibGVzIHVzIHRvIGNyZWF0ZSB3cmFwcGVkIFwiY2hpbGRcbiAgICAgKiBjb25zdHJ1Y3RvcnNcIiBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZSBhbmQgY2FjaGUgdGhlbS5cbiAgICAgKi9cbiAgICBWdWUuY2lkID0gMDtcbiAgICB2YXIgY2lkID0gMTtcblxuICAgIC8qKlxuICAgICAqIENsYXNzIGluaGVyaXRhbmNlXG4gICAgICovXG4gICAgVnVlLmV4dGVuZCA9IGZ1bmN0aW9uIChleHRlbmRPcHRpb25zKSB7XG4gICAgICBleHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucyB8fCB7fTtcbiAgICAgIHZhciBTdXBlciA9IHRoaXM7XG4gICAgICB2YXIgU3VwZXJJZCA9IFN1cGVyLmNpZDtcbiAgICAgIHZhciBjYWNoZWRDdG9ycyA9IGV4dGVuZE9wdGlvbnMuX0N0b3IgfHwgKGV4dGVuZE9wdGlvbnMuX0N0b3IgPSB7fSk7XG4gICAgICBpZiAoY2FjaGVkQ3RvcnNbU3VwZXJJZF0pIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZEN0b3JzW1N1cGVySWRdXG4gICAgICB9XG5cbiAgICAgIHZhciBuYW1lID0gZXh0ZW5kT3B0aW9ucy5uYW1lIHx8IFN1cGVyLm9wdGlvbnMubmFtZTtcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lKTtcbiAgICAgIH1cblxuICAgICAgdmFyIFN1YiA9IGZ1bmN0aW9uIFZ1ZUNvbXBvbmVudCAob3B0aW9ucykge1xuICAgICAgICB0aGlzLl9pbml0KG9wdGlvbnMpO1xuICAgICAgfTtcbiAgICAgIFN1Yi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN1cGVyLnByb3RvdHlwZSk7XG4gICAgICBTdWIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ViO1xuICAgICAgU3ViLmNpZCA9IGNpZCsrO1xuICAgICAgU3ViLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICAgIFN1cGVyLm9wdGlvbnMsXG4gICAgICAgIGV4dGVuZE9wdGlvbnNcbiAgICAgICk7XG4gICAgICBTdWJbJ3N1cGVyJ10gPSBTdXBlcjtcblxuICAgICAgLy8gRm9yIHByb3BzIGFuZCBjb21wdXRlZCBwcm9wZXJ0aWVzLCB3ZSBkZWZpbmUgdGhlIHByb3h5IGdldHRlcnMgb25cbiAgICAgIC8vIHRoZSBWdWUgaW5zdGFuY2VzIGF0IGV4dGVuc2lvbiB0aW1lLCBvbiB0aGUgZXh0ZW5kZWQgcHJvdG90eXBlLiBUaGlzXG4gICAgICAvLyBhdm9pZHMgT2JqZWN0LmRlZmluZVByb3BlcnR5IGNhbGxzIGZvciBlYWNoIGluc3RhbmNlIGNyZWF0ZWQuXG4gICAgICBpZiAoU3ViLm9wdGlvbnMucHJvcHMpIHtcbiAgICAgICAgaW5pdFByb3BzJDEoU3ViKTtcbiAgICAgIH1cbiAgICAgIGlmIChTdWIub3B0aW9ucy5jb21wdXRlZCkge1xuICAgICAgICBpbml0Q29tcHV0ZWQkMShTdWIpO1xuICAgICAgfVxuXG4gICAgICAvLyBhbGxvdyBmdXJ0aGVyIGV4dGVuc2lvbi9taXhpbi9wbHVnaW4gdXNhZ2VcbiAgICAgIFN1Yi5leHRlbmQgPSBTdXBlci5leHRlbmQ7XG4gICAgICBTdWIubWl4aW4gPSBTdXBlci5taXhpbjtcbiAgICAgIFN1Yi51c2UgPSBTdXBlci51c2U7XG5cbiAgICAgIC8vIGNyZWF0ZSBhc3NldCByZWdpc3RlcnMsIHNvIGV4dGVuZGVkIGNsYXNzZXNcbiAgICAgIC8vIGNhbiBoYXZlIHRoZWlyIHByaXZhdGUgYXNzZXRzIHRvby5cbiAgICAgIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgU3ViW3R5cGVdID0gU3VwZXJbdHlwZV07XG4gICAgICB9KTtcbiAgICAgIC8vIGVuYWJsZSByZWN1cnNpdmUgc2VsZi1sb29rdXBcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIFN1Yi5vcHRpb25zLmNvbXBvbmVudHNbbmFtZV0gPSBTdWI7XG4gICAgICB9XG5cbiAgICAgIC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHN1cGVyIG9wdGlvbnMgYXQgZXh0ZW5zaW9uIHRpbWUuXG4gICAgICAvLyBsYXRlciBhdCBpbnN0YW50aWF0aW9uIHdlIGNhbiBjaGVjayBpZiBTdXBlcidzIG9wdGlvbnMgaGF2ZVxuICAgICAgLy8gYmVlbiB1cGRhdGVkLlxuICAgICAgU3ViLnN1cGVyT3B0aW9ucyA9IFN1cGVyLm9wdGlvbnM7XG4gICAgICBTdWIuZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnM7XG4gICAgICBTdWIuc2VhbGVkT3B0aW9ucyA9IGV4dGVuZCh7fSwgU3ViLm9wdGlvbnMpO1xuXG4gICAgICAvLyBjYWNoZSBjb25zdHJ1Y3RvclxuICAgICAgY2FjaGVkQ3RvcnNbU3VwZXJJZF0gPSBTdWI7XG4gICAgICByZXR1cm4gU3ViXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRQcm9wcyQxIChDb21wKSB7XG4gICAgdmFyIHByb3BzID0gQ29tcC5vcHRpb25zLnByb3BzO1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgcHJveHkoQ29tcC5wcm90b3R5cGUsIFwiX3Byb3BzXCIsIGtleSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdENvbXB1dGVkJDEgKENvbXApIHtcbiAgICB2YXIgY29tcHV0ZWQgPSBDb21wLm9wdGlvbnMuY29tcHV0ZWQ7XG4gICAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgICBkZWZpbmVDb21wdXRlZChDb21wLnByb3RvdHlwZSwga2V5LCBjb21wdXRlZFtrZXldKTtcbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBpbml0QXNzZXRSZWdpc3RlcnMgKFZ1ZSkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhc3NldCByZWdpc3RyYXRpb24gbWV0aG9kcy5cbiAgICAgKi9cbiAgICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBWdWVbdHlwZV0gPSBmdW5jdGlvbiAoXG4gICAgICAgIGlkLFxuICAgICAgICBkZWZpbml0aW9uXG4gICAgICApIHtcbiAgICAgICAgaWYgKCFkZWZpbml0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShpZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBpc1BsYWluT2JqZWN0KGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgICBkZWZpbml0aW9uLm5hbWUgPSBkZWZpbml0aW9uLm5hbWUgfHwgaWQ7XG4gICAgICAgICAgICBkZWZpbml0aW9uID0gdGhpcy5vcHRpb25zLl9iYXNlLmV4dGVuZChkZWZpbml0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdkaXJlY3RpdmUnICYmIHR5cGVvZiBkZWZpbml0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBkZWZpbml0aW9uID0geyBiaW5kOiBkZWZpbml0aW9uLCB1cGRhdGU6IGRlZmluaXRpb24gfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXSA9IGRlZmluaXRpb247XG4gICAgICAgICAgcmV0dXJuIGRlZmluaXRpb25cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qICAqL1xuXG5cblxuICBmdW5jdGlvbiBnZXRDb21wb25lbnROYW1lIChvcHRzKSB7XG4gICAgcmV0dXJuIG9wdHMgJiYgKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcpXG4gIH1cblxuICBmdW5jdGlvbiBtYXRjaGVzIChwYXR0ZXJuLCBuYW1lKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocGF0dGVybikpIHtcbiAgICAgIHJldHVybiBwYXR0ZXJuLmluZGV4T2YobmFtZSkgPiAtMVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gcGF0dGVybi5zcGxpdCgnLCcpLmluZGV4T2YobmFtZSkgPiAtMVxuICAgIH0gZWxzZSBpZiAoaXNSZWdFeHAocGF0dGVybikpIHtcbiAgICAgIHJldHVybiBwYXR0ZXJuLnRlc3QobmFtZSlcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIHBydW5lQ2FjaGUgKGtlZXBBbGl2ZUluc3RhbmNlLCBmaWx0ZXIpIHtcbiAgICB2YXIgY2FjaGUgPSBrZWVwQWxpdmVJbnN0YW5jZS5jYWNoZTtcbiAgICB2YXIga2V5cyA9IGtlZXBBbGl2ZUluc3RhbmNlLmtleXM7XG4gICAgdmFyIF92bm9kZSA9IGtlZXBBbGl2ZUluc3RhbmNlLl92bm9kZTtcbiAgICBmb3IgKHZhciBrZXkgaW4gY2FjaGUpIHtcbiAgICAgIHZhciBjYWNoZWROb2RlID0gY2FjaGVba2V5XTtcbiAgICAgIGlmIChjYWNoZWROb2RlKSB7XG4gICAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjYWNoZWROb2RlLmNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgICBpZiAobmFtZSAmJiAhZmlsdGVyKG5hbWUpKSB7XG4gICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGNhY2hlLCBrZXksIGtleXMsIF92bm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcnVuZUNhY2hlRW50cnkgKFxuICAgIGNhY2hlLFxuICAgIGtleSxcbiAgICBrZXlzLFxuICAgIGN1cnJlbnRcbiAgKSB7XG4gICAgdmFyIGNhY2hlZCQkMSA9IGNhY2hlW2tleV07XG4gICAgaWYgKGNhY2hlZCQkMSAmJiAoIWN1cnJlbnQgfHwgY2FjaGVkJCQxLnRhZyAhPT0gY3VycmVudC50YWcpKSB7XG4gICAgICBjYWNoZWQkJDEuY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgICB9XG4gICAgY2FjaGVba2V5XSA9IG51bGw7XG4gICAgcmVtb3ZlKGtleXMsIGtleSk7XG4gIH1cblxuICB2YXIgcGF0dGVyblR5cGVzID0gW1N0cmluZywgUmVnRXhwLCBBcnJheV07XG5cbiAgdmFyIEtlZXBBbGl2ZSA9IHtcbiAgICBuYW1lOiAna2VlcC1hbGl2ZScsXG4gICAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgICBwcm9wczoge1xuICAgICAgaW5jbHVkZTogcGF0dGVyblR5cGVzLFxuICAgICAgZXhjbHVkZTogcGF0dGVyblR5cGVzLFxuICAgICAgbWF4OiBbU3RyaW5nLCBOdW1iZXJdXG4gICAgfSxcblxuICAgIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQgKCkge1xuICAgICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB0aGlzLmtleXMgPSBbXTtcbiAgICB9LFxuXG4gICAgZGVzdHJveWVkOiBmdW5jdGlvbiBkZXN0cm95ZWQgKCkge1xuICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuY2FjaGUpIHtcbiAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KHRoaXMuY2FjaGUsIGtleSwgdGhpcy5rZXlzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCAoKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgdGhpcy4kd2F0Y2goJ2luY2x1ZGUnLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHBydW5lQ2FjaGUodGhpcyQxLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy4kd2F0Y2goJ2V4Y2x1ZGUnLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHBydW5lQ2FjaGUodGhpcyQxLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gIW1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKCkge1xuICAgICAgdmFyIHNsb3QgPSB0aGlzLiRzbG90cy5kZWZhdWx0O1xuICAgICAgdmFyIHZub2RlID0gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChzbG90KTtcbiAgICAgIHZhciBjb21wb25lbnRPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICAgIGlmIChjb21wb25lbnRPcHRpb25zKSB7XG4gICAgICAgIC8vIGNoZWNrIHBhdHRlcm5cbiAgICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgICB2YXIgcmVmID0gdGhpcztcbiAgICAgICAgdmFyIGluY2x1ZGUgPSByZWYuaW5jbHVkZTtcbiAgICAgICAgdmFyIGV4Y2x1ZGUgPSByZWYuZXhjbHVkZTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIC8vIG5vdCBpbmNsdWRlZFxuICAgICAgICAgIChpbmNsdWRlICYmICghbmFtZSB8fCAhbWF0Y2hlcyhpbmNsdWRlLCBuYW1lKSkpIHx8XG4gICAgICAgICAgLy8gZXhjbHVkZWRcbiAgICAgICAgICAoZXhjbHVkZSAmJiBuYW1lICYmIG1hdGNoZXMoZXhjbHVkZSwgbmFtZSkpXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiB2bm9kZVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlZiQxID0gdGhpcztcbiAgICAgICAgdmFyIGNhY2hlID0gcmVmJDEuY2FjaGU7XG4gICAgICAgIHZhciBrZXlzID0gcmVmJDEua2V5cztcbiAgICAgICAgdmFyIGtleSA9IHZub2RlLmtleSA9PSBudWxsXG4gICAgICAgICAgLy8gc2FtZSBjb25zdHJ1Y3RvciBtYXkgZ2V0IHJlZ2lzdGVyZWQgYXMgZGlmZmVyZW50IGxvY2FsIGNvbXBvbmVudHNcbiAgICAgICAgICAvLyBzbyBjaWQgYWxvbmUgaXMgbm90IGVub3VnaCAoIzMyNjkpXG4gICAgICAgICAgPyBjb21wb25lbnRPcHRpb25zLkN0b3IuY2lkICsgKGNvbXBvbmVudE9wdGlvbnMudGFnID8gKFwiOjpcIiArIChjb21wb25lbnRPcHRpb25zLnRhZykpIDogJycpXG4gICAgICAgICAgOiB2bm9kZS5rZXk7XG4gICAgICAgIGlmIChjYWNoZVtrZXldKSB7XG4gICAgICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjYWNoZVtrZXldLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgICAgIC8vIG1ha2UgY3VycmVudCBrZXkgZnJlc2hlc3RcbiAgICAgICAgICByZW1vdmUoa2V5cywga2V5KTtcbiAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWNoZVtrZXldID0gdm5vZGU7XG4gICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgLy8gcHJ1bmUgb2xkZXN0IGVudHJ5XG4gICAgICAgICAgaWYgKHRoaXMubWF4ICYmIGtleXMubGVuZ3RoID4gcGFyc2VJbnQodGhpcy5tYXgpKSB7XG4gICAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGUsIGtleXNbMF0sIGtleXMsIHRoaXMuX3Zub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm5vZGUgfHwgKHNsb3QgJiYgc2xvdFswXSlcbiAgICB9XG4gIH07XG5cbiAgdmFyIGJ1aWx0SW5Db21wb25lbnRzID0ge1xuICAgIEtlZXBBbGl2ZTogS2VlcEFsaXZlXG4gIH07XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gaW5pdEdsb2JhbEFQSSAoVnVlKSB7XG4gICAgLy8gY29uZmlnXG4gICAgdmFyIGNvbmZpZ0RlZiA9IHt9O1xuICAgIGNvbmZpZ0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25maWc7IH07XG4gICAge1xuICAgICAgY29uZmlnRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnRG8gbm90IHJlcGxhY2UgdGhlIFZ1ZS5jb25maWcgb2JqZWN0LCBzZXQgaW5kaXZpZHVhbCBmaWVsZHMgaW5zdGVhZC4nXG4gICAgICAgICk7XG4gICAgICB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLCAnY29uZmlnJywgY29uZmlnRGVmKTtcblxuICAgIC8vIGV4cG9zZWQgdXRpbCBtZXRob2RzLlxuICAgIC8vIE5PVEU6IHRoZXNlIGFyZSBub3QgY29uc2lkZXJlZCBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJIC0gYXZvaWQgcmVseWluZyBvblxuICAgIC8vIHRoZW0gdW5sZXNzIHlvdSBhcmUgYXdhcmUgb2YgdGhlIHJpc2suXG4gICAgVnVlLnV0aWwgPSB7XG4gICAgICB3YXJuOiB3YXJuLFxuICAgICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgICBtZXJnZU9wdGlvbnM6IG1lcmdlT3B0aW9ucyxcbiAgICAgIGRlZmluZVJlYWN0aXZlOiBkZWZpbmVSZWFjdGl2ZSQkMVxuICAgIH07XG5cbiAgICBWdWUuc2V0ID0gc2V0O1xuICAgIFZ1ZS5kZWxldGUgPSBkZWw7XG4gICAgVnVlLm5leHRUaWNrID0gbmV4dFRpY2s7XG5cbiAgICAvLyAyLjYgZXhwbGljaXQgb2JzZXJ2YWJsZSBBUElcbiAgICBWdWUub2JzZXJ2YWJsZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIG9ic2VydmUob2JqKTtcbiAgICAgIHJldHVybiBvYmpcbiAgICB9O1xuXG4gICAgVnVlLm9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIFZ1ZS5vcHRpb25zW3R5cGUgKyAncyddID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9KTtcblxuICAgIC8vIHRoaXMgaXMgdXNlZCB0byBpZGVudGlmeSB0aGUgXCJiYXNlXCIgY29uc3RydWN0b3IgdG8gZXh0ZW5kIGFsbCBwbGFpbi1vYmplY3RcbiAgICAvLyBjb21wb25lbnRzIHdpdGggaW4gV2VleCdzIG11bHRpLWluc3RhbmNlIHNjZW5hcmlvcy5cbiAgICBWdWUub3B0aW9ucy5fYmFzZSA9IFZ1ZTtcblxuICAgIGV4dGVuZChWdWUub3B0aW9ucy5jb21wb25lbnRzLCBidWlsdEluQ29tcG9uZW50cyk7XG5cbiAgICBpbml0VXNlKFZ1ZSk7XG4gICAgaW5pdE1peGluJDEoVnVlKTtcbiAgICBpbml0RXh0ZW5kKFZ1ZSk7XG4gICAgaW5pdEFzc2V0UmVnaXN0ZXJzKFZ1ZSk7XG4gIH1cblxuICBpbml0R2xvYmFsQVBJKFZ1ZSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckaXNTZXJ2ZXInLCB7XG4gICAgZ2V0OiBpc1NlcnZlclJlbmRlcmluZ1xuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRzc3JDb250ZXh0Jywge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICByZXR1cm4gdGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dFxuICAgIH1cbiAgfSk7XG5cbiAgLy8gZXhwb3NlIEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IGZvciBzc3IgcnVudGltZSBoZWxwZXIgaW5zdGFsbGF0aW9uXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCcsIHtcbiAgICB2YWx1ZTogRnVuY3Rpb25hbFJlbmRlckNvbnRleHRcbiAgfSk7XG5cbiAgVnVlLnZlcnNpb24gPSAnMi42LjEwJztcblxuICAvKiAgKi9cblxuICAvLyB0aGVzZSBhcmUgcmVzZXJ2ZWQgZm9yIHdlYiBiZWNhdXNlIHRoZXkgYXJlIGRpcmVjdGx5IGNvbXBpbGVkIGF3YXlcbiAgLy8gZHVyaW5nIHRlbXBsYXRlIGNvbXBpbGF0aW9uXG4gIHZhciBpc1Jlc2VydmVkQXR0ciA9IG1ha2VNYXAoJ3N0eWxlLGNsYXNzJyk7XG5cbiAgLy8gYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSB1c2luZyBwcm9wcyBmb3IgYmluZGluZ1xuICB2YXIgYWNjZXB0VmFsdWUgPSBtYWtlTWFwKCdpbnB1dCx0ZXh0YXJlYSxvcHRpb24sc2VsZWN0LHByb2dyZXNzJyk7XG4gIHZhciBtdXN0VXNlUHJvcCA9IGZ1bmN0aW9uICh0YWcsIHR5cGUsIGF0dHIpIHtcbiAgICByZXR1cm4gKFxuICAgICAgKGF0dHIgPT09ICd2YWx1ZScgJiYgYWNjZXB0VmFsdWUodGFnKSkgJiYgdHlwZSAhPT0gJ2J1dHRvbicgfHxcbiAgICAgIChhdHRyID09PSAnc2VsZWN0ZWQnICYmIHRhZyA9PT0gJ29wdGlvbicpIHx8XG4gICAgICAoYXR0ciA9PT0gJ2NoZWNrZWQnICYmIHRhZyA9PT0gJ2lucHV0JykgfHxcbiAgICAgIChhdHRyID09PSAnbXV0ZWQnICYmIHRhZyA9PT0gJ3ZpZGVvJylcbiAgICApXG4gIH07XG5cbiAgdmFyIGlzRW51bWVyYXRlZEF0dHIgPSBtYWtlTWFwKCdjb250ZW50ZWRpdGFibGUsZHJhZ2dhYmxlLHNwZWxsY2hlY2snKTtcblxuICB2YXIgaXNWYWxpZENvbnRlbnRFZGl0YWJsZVZhbHVlID0gbWFrZU1hcCgnZXZlbnRzLGNhcmV0LHR5cGluZyxwbGFpbnRleHQtb25seScpO1xuXG4gIHZhciBjb252ZXJ0RW51bWVyYXRlZFZhbHVlID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkgfHwgdmFsdWUgPT09ICdmYWxzZSdcbiAgICAgID8gJ2ZhbHNlJ1xuICAgICAgLy8gYWxsb3cgYXJiaXRyYXJ5IHN0cmluZyB2YWx1ZSBmb3IgY29udGVudGVkaXRhYmxlXG4gICAgICA6IGtleSA9PT0gJ2NvbnRlbnRlZGl0YWJsZScgJiYgaXNWYWxpZENvbnRlbnRFZGl0YWJsZVZhbHVlKHZhbHVlKVxuICAgICAgICA/IHZhbHVlXG4gICAgICAgIDogJ3RydWUnXG4gIH07XG5cbiAgdmFyIGlzQm9vbGVhbkF0dHIgPSBtYWtlTWFwKFxuICAgICdhbGxvd2Z1bGxzY3JlZW4sYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNoZWNrZWQsY29tcGFjdCxjb250cm9scyxkZWNsYXJlLCcgK1xuICAgICdkZWZhdWx0LGRlZmF1bHRjaGVja2VkLGRlZmF1bHRtdXRlZCxkZWZhdWx0c2VsZWN0ZWQsZGVmZXIsZGlzYWJsZWQsJyArXG4gICAgJ2VuYWJsZWQsZm9ybW5vdmFsaWRhdGUsaGlkZGVuLGluZGV0ZXJtaW5hdGUsaW5lcnQsaXNtYXAsaXRlbXNjb3BlLGxvb3AsbXVsdGlwbGUsJyArXG4gICAgJ211dGVkLG5vaHJlZixub3Jlc2l6ZSxub3NoYWRlLG5vdmFsaWRhdGUsbm93cmFwLG9wZW4scGF1c2VvbmV4aXQscmVhZG9ubHksJyArXG4gICAgJ3JlcXVpcmVkLHJldmVyc2VkLHNjb3BlZCxzZWFtbGVzcyxzZWxlY3RlZCxzb3J0YWJsZSx0cmFuc2xhdGUsJyArXG4gICAgJ3RydWVzcGVlZCx0eXBlbXVzdG1hdGNoLHZpc2libGUnXG4gICk7XG5cbiAgdmFyIHhsaW5rTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG5cbiAgdmFyIGlzWGxpbmsgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiBuYW1lLmNoYXJBdCg1KSA9PT0gJzonICYmIG5hbWUuc2xpY2UoMCwgNSkgPT09ICd4bGluaydcbiAgfTtcblxuICB2YXIgZ2V0WGxpbmtQcm9wID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gaXNYbGluayhuYW1lKSA/IG5hbWUuc2xpY2UoNiwgbmFtZS5sZW5ndGgpIDogJydcbiAgfTtcblxuICB2YXIgaXNGYWxzeUF0dHJWYWx1ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gdmFsID09IG51bGwgfHwgdmFsID09PSBmYWxzZVxuICB9O1xuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIGdlbkNsYXNzRm9yVm5vZGUgKHZub2RlKSB7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gICAgdmFyIGNoaWxkTm9kZSA9IHZub2RlO1xuICAgIHdoaWxlIChpc0RlZihjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKGNoaWxkTm9kZSAmJiBjaGlsZE5vZGUuZGF0YSkge1xuICAgICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoY2hpbGROb2RlLmRhdGEsIGRhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAoaXNEZWYocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgICAgaWYgKHBhcmVudE5vZGUgJiYgcGFyZW50Tm9kZS5kYXRhKSB7XG4gICAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShkYXRhLCBwYXJlbnROb2RlLmRhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVuZGVyQ2xhc3MoZGF0YS5zdGF0aWNDbGFzcywgZGF0YS5jbGFzcylcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlQ2xhc3NEYXRhIChjaGlsZCwgcGFyZW50KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXRpY0NsYXNzOiBjb25jYXQoY2hpbGQuc3RhdGljQ2xhc3MsIHBhcmVudC5zdGF0aWNDbGFzcyksXG4gICAgICBjbGFzczogaXNEZWYoY2hpbGQuY2xhc3MpXG4gICAgICAgID8gW2NoaWxkLmNsYXNzLCBwYXJlbnQuY2xhc3NdXG4gICAgICAgIDogcGFyZW50LmNsYXNzXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVyQ2xhc3MgKFxuICAgIHN0YXRpY0NsYXNzLFxuICAgIGR5bmFtaWNDbGFzc1xuICApIHtcbiAgICBpZiAoaXNEZWYoc3RhdGljQ2xhc3MpIHx8IGlzRGVmKGR5bmFtaWNDbGFzcykpIHtcbiAgICAgIHJldHVybiBjb25jYXQoc3RhdGljQ2xhc3MsIHN0cmluZ2lmeUNsYXNzKGR5bmFtaWNDbGFzcykpXG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBmdW5jdGlvbiBjb25jYXQgKGEsIGIpIHtcbiAgICByZXR1cm4gYSA/IGIgPyAoYSArICcgJyArIGIpIDogYSA6IChiIHx8ICcnKVxuICB9XG5cbiAgZnVuY3Rpb24gc3RyaW5naWZ5Q2xhc3MgKHZhbHVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICByZXR1cm4gc3RyaW5naWZ5QXJyYXkodmFsdWUpXG4gICAgfVxuICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBzdHJpbmdpZnlPYmplY3QodmFsdWUpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0cmluZ2lmeUFycmF5ICh2YWx1ZSkge1xuICAgIHZhciByZXMgPSAnJztcbiAgICB2YXIgc3RyaW5naWZpZWQ7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChpc0RlZihzdHJpbmdpZmllZCA9IHN0cmluZ2lmeUNsYXNzKHZhbHVlW2ldKSkgJiYgc3RyaW5naWZpZWQgIT09ICcnKSB7XG4gICAgICAgIGlmIChyZXMpIHsgcmVzICs9ICcgJzsgfVxuICAgICAgICByZXMgKz0gc3RyaW5naWZpZWQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0cmluZ2lmeU9iamVjdCAodmFsdWUpIHtcbiAgICB2YXIgcmVzID0gJyc7XG4gICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWVba2V5XSkge1xuICAgICAgICBpZiAocmVzKSB7IHJlcyArPSAnICc7IH1cbiAgICAgICAgcmVzICs9IGtleTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgLyogICovXG5cbiAgdmFyIG5hbWVzcGFjZU1hcCA9IHtcbiAgICBzdmc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG4gICAgbWF0aDogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnXG4gIH07XG5cbiAgdmFyIGlzSFRNTFRhZyA9IG1ha2VNYXAoXG4gICAgJ2h0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLCcgK1xuICAgICdhZGRyZXNzLGFydGljbGUsYXNpZGUsZm9vdGVyLGhlYWRlcixoMSxoMixoMyxoNCxoNSxoNixoZ3JvdXAsbmF2LHNlY3Rpb24sJyArXG4gICAgJ2RpdixkZCxkbCxkdCxmaWdjYXB0aW9uLGZpZ3VyZSxwaWN0dXJlLGhyLGltZyxsaSxtYWluLG9sLHAscHJlLHVsLCcgK1xuICAgICdhLGIsYWJicixiZGksYmRvLGJyLGNpdGUsY29kZSxkYXRhLGRmbixlbSxpLGtiZCxtYXJrLHEscnAscnQscnRjLHJ1YnksJyArXG4gICAgJ3Msc2FtcCxzbWFsbCxzcGFuLHN0cm9uZyxzdWIsc3VwLHRpbWUsdSx2YXIsd2JyLGFyZWEsYXVkaW8sbWFwLHRyYWNrLHZpZGVvLCcgK1xuICAgICdlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLGNhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucywnICtcbiAgICAnY2FwdGlvbixjb2wsY29sZ3JvdXAsdGFibGUsdGhlYWQsdGJvZHksdGQsdGgsdHIsJyArXG4gICAgJ2J1dHRvbixkYXRhbGlzdCxmaWVsZHNldCxmb3JtLGlucHV0LGxhYmVsLGxlZ2VuZCxtZXRlcixvcHRncm91cCxvcHRpb24sJyArXG4gICAgJ291dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsJyArXG4gICAgJ2RldGFpbHMsZGlhbG9nLG1lbnUsbWVudWl0ZW0sc3VtbWFyeSwnICtcbiAgICAnY29udGVudCxlbGVtZW50LHNoYWRvdyx0ZW1wbGF0ZSxibG9ja3F1b3RlLGlmcmFtZSx0Zm9vdCdcbiAgKTtcblxuICAvLyB0aGlzIG1hcCBpcyBpbnRlbnRpb25hbGx5IHNlbGVjdGl2ZSwgb25seSBjb3ZlcmluZyBTVkcgZWxlbWVudHMgdGhhdCBtYXlcbiAgLy8gY29udGFpbiBjaGlsZCBlbGVtZW50cy5cbiAgdmFyIGlzU1ZHID0gbWFrZU1hcChcbiAgICAnc3ZnLGFuaW1hdGUsY2lyY2xlLGNsaXBwYXRoLGN1cnNvcixkZWZzLGRlc2MsZWxsaXBzZSxmaWx0ZXIsZm9udC1mYWNlLCcgK1xuICAgICdmb3JlaWduT2JqZWN0LGcsZ2x5cGgsaW1hZ2UsbGluZSxtYXJrZXIsbWFzayxtaXNzaW5nLWdseXBoLHBhdGgscGF0dGVybiwnICtcbiAgICAncG9seWdvbixwb2x5bGluZSxyZWN0LHN3aXRjaCxzeW1ib2wsdGV4dCx0ZXh0cGF0aCx0c3Bhbix1c2UsdmlldycsXG4gICAgdHJ1ZVxuICApO1xuXG4gIHZhciBpc1ByZVRhZyA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHRhZyA9PT0gJ3ByZSc7IH07XG5cbiAgdmFyIGlzUmVzZXJ2ZWRUYWcgPSBmdW5jdGlvbiAodGFnKSB7XG4gICAgcmV0dXJuIGlzSFRNTFRhZyh0YWcpIHx8IGlzU1ZHKHRhZylcbiAgfTtcblxuICBmdW5jdGlvbiBnZXRUYWdOYW1lc3BhY2UgKHRhZykge1xuICAgIGlmIChpc1NWRyh0YWcpKSB7XG4gICAgICByZXR1cm4gJ3N2ZydcbiAgICB9XG4gICAgLy8gYmFzaWMgc3VwcG9ydCBmb3IgTWF0aE1MXG4gICAgLy8gbm90ZSBpdCBkb2Vzbid0IHN1cHBvcnQgb3RoZXIgTWF0aE1MIGVsZW1lbnRzIGJlaW5nIGNvbXBvbmVudCByb290c1xuICAgIGlmICh0YWcgPT09ICdtYXRoJykge1xuICAgICAgcmV0dXJuICdtYXRoJ1xuICAgIH1cbiAgfVxuXG4gIHZhciB1bmtub3duRWxlbWVudENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZnVuY3Rpb24gaXNVbmtub3duRWxlbWVudCAodGFnKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFpbkJyb3dzZXIpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmIChpc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICB0YWcgPSB0YWcudG9Mb3dlckNhc2UoKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddICE9IG51bGwpIHtcbiAgICAgIHJldHVybiB1bmtub3duRWxlbWVudENhY2hlW3RhZ11cbiAgICB9XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgIGlmICh0YWcuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI4MjEwMzY0LzEwNzAyNDRcbiAgICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gKFxuICAgICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxVbmtub3duRWxlbWVudCB8fFxuICAgICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxFbGVtZW50XG4gICAgICApKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IC9IVE1MVW5rbm93bkVsZW1lbnQvLnRlc3QoZWwudG9TdHJpbmcoKSkpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlzVGV4dElucHV0VHlwZSA9IG1ha2VNYXAoJ3RleHQsbnVtYmVyLHBhc3N3b3JkLHNlYXJjaCxlbWFpbCx0ZWwsdXJsJyk7XG5cbiAgLyogICovXG5cbiAgLyoqXG4gICAqIFF1ZXJ5IGFuIGVsZW1lbnQgc2VsZWN0b3IgaWYgaXQncyBub3QgYW4gZWxlbWVudCBhbHJlYWR5LlxuICAgKi9cbiAgZnVuY3Rpb24gcXVlcnkgKGVsKSB7XG4gICAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBzZWxlY3RlZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWwpO1xuICAgICAgaWYgKCFzZWxlY3RlZCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdDYW5ub3QgZmluZCBlbGVtZW50OiAnICsgZWxcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZWN0ZWRcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGVsXG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudCQxICh0YWdOYW1lLCB2bm9kZSkge1xuICAgIHZhciBlbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICAgIGlmICh0YWdOYW1lICE9PSAnc2VsZWN0Jykge1xuICAgICAgcmV0dXJuIGVsbVxuICAgIH1cbiAgICAvLyBmYWxzZSBvciBudWxsIHdpbGwgcmVtb3ZlIHRoZSBhdHRyaWJ1dGUgYnV0IHVuZGVmaW5lZCB3aWxsIG5vdFxuICAgIGlmICh2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEuYXR0cnMgJiYgdm5vZGUuZGF0YS5hdHRycy5tdWx0aXBsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBlbG0uc2V0QXR0cmlidXRlKCdtdWx0aXBsZScsICdtdWx0aXBsZScpO1xuICAgIH1cbiAgICByZXR1cm4gZWxtXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMgKG5hbWVzcGFjZSwgdGFnTmFtZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlTWFwW25hbWVzcGFjZV0sIHRhZ05hbWUpXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVUZXh0Tm9kZSAodGV4dCkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ29tbWVudCAodGV4dCkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVDb21tZW50KHRleHQpXG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnRCZWZvcmUgKHBhcmVudE5vZGUsIG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdOb2RlLCByZWZlcmVuY2VOb2RlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUNoaWxkIChub2RlLCBjaGlsZCkge1xuICAgIG5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwZW5kQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gICAgbm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJlbnROb2RlIChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUucGFyZW50Tm9kZVxuICB9XG5cbiAgZnVuY3Rpb24gbmV4dFNpYmxpbmcgKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5uZXh0U2libGluZ1xuICB9XG5cbiAgZnVuY3Rpb24gdGFnTmFtZSAobm9kZSkge1xuICAgIHJldHVybiBub2RlLnRhZ05hbWVcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFRleHRDb250ZW50IChub2RlLCB0ZXh0KSB7XG4gICAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRTdHlsZVNjb3BlIChub2RlLCBzY29wZUlkKSB7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoc2NvcGVJZCwgJycpO1xuICB9XG5cbiAgdmFyIG5vZGVPcHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCQxLFxuICAgIGNyZWF0ZUVsZW1lbnROUzogY3JlYXRlRWxlbWVudE5TLFxuICAgIGNyZWF0ZVRleHROb2RlOiBjcmVhdGVUZXh0Tm9kZSxcbiAgICBjcmVhdGVDb21tZW50OiBjcmVhdGVDb21tZW50LFxuICAgIGluc2VydEJlZm9yZTogaW5zZXJ0QmVmb3JlLFxuICAgIHJlbW92ZUNoaWxkOiByZW1vdmVDaGlsZCxcbiAgICBhcHBlbmRDaGlsZDogYXBwZW5kQ2hpbGQsXG4gICAgcGFyZW50Tm9kZTogcGFyZW50Tm9kZSxcbiAgICBuZXh0U2libGluZzogbmV4dFNpYmxpbmcsXG4gICAgdGFnTmFtZTogdGFnTmFtZSxcbiAgICBzZXRUZXh0Q29udGVudDogc2V0VGV4dENvbnRlbnQsXG4gICAgc2V0U3R5bGVTY29wZTogc2V0U3R5bGVTY29wZVxuICB9KTtcblxuICAvKiAgKi9cblxuICB2YXIgcmVmID0ge1xuICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlIChfLCB2bm9kZSkge1xuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgIH0sXG4gICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICAgICAgaWYgKG9sZFZub2RlLmRhdGEucmVmICE9PSB2bm9kZS5kYXRhLnJlZikge1xuICAgICAgICByZWdpc3RlclJlZihvbGRWbm9kZSwgdHJ1ZSk7XG4gICAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgICByZWdpc3RlclJlZih2bm9kZSwgdHJ1ZSk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyUmVmICh2bm9kZSwgaXNSZW1vdmFsKSB7XG4gICAgdmFyIGtleSA9IHZub2RlLmRhdGEucmVmO1xuICAgIGlmICghaXNEZWYoa2V5KSkgeyByZXR1cm4gfVxuXG4gICAgdmFyIHZtID0gdm5vZGUuY29udGV4dDtcbiAgICB2YXIgcmVmID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgfHwgdm5vZGUuZWxtO1xuICAgIHZhciByZWZzID0gdm0uJHJlZnM7XG4gICAgaWYgKGlzUmVtb3ZhbCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgICByZW1vdmUocmVmc1trZXldLCByZWYpO1xuICAgICAgfSBlbHNlIGlmIChyZWZzW2tleV0gPT09IHJlZikge1xuICAgICAgICByZWZzW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh2bm9kZS5kYXRhLnJlZkluRm9yKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZWZzW2tleV0pKSB7XG4gICAgICAgICAgcmVmc1trZXldID0gW3JlZl07XG4gICAgICAgIH0gZWxzZSBpZiAocmVmc1trZXldLmluZGV4T2YocmVmKSA8IDApIHtcbiAgICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgICAgICByZWZzW2tleV0ucHVzaChyZWYpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWZzW2tleV0gPSByZWY7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFZpcnR1YWwgRE9NIHBhdGNoaW5nIGFsZ29yaXRobSBiYXNlZCBvbiBTbmFiYmRvbSBieVxuICAgKiBTaW1vbiBGcmlpcyBWaW5kdW0gKEBwYWxkZXBpbmQpXG4gICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vcGFsZGVwaW5kL3NuYWJiZG9tL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAgICpcbiAgICogbW9kaWZpZWQgYnkgRXZhbiBZb3UgKEB5eXg5OTA4MDMpXG4gICAqXG4gICAqIE5vdCB0eXBlLWNoZWNraW5nIHRoaXMgYmVjYXVzZSB0aGlzIGZpbGUgaXMgcGVyZi1jcml0aWNhbCBhbmQgdGhlIGNvc3RcbiAgICogb2YgbWFraW5nIGZsb3cgdW5kZXJzdGFuZCBpdCBpcyBub3Qgd29ydGggaXQuXG4gICAqL1xuXG4gIHZhciBlbXB0eU5vZGUgPSBuZXcgVk5vZGUoJycsIHt9LCBbXSk7XG5cbiAgdmFyIGhvb2tzID0gWydjcmVhdGUnLCAnYWN0aXZhdGUnLCAndXBkYXRlJywgJ3JlbW92ZScsICdkZXN0cm95J107XG5cbiAgZnVuY3Rpb24gc2FtZVZub2RlIChhLCBiKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGEua2V5ID09PSBiLmtleSAmJiAoXG4gICAgICAgIChcbiAgICAgICAgICBhLnRhZyA9PT0gYi50YWcgJiZcbiAgICAgICAgICBhLmlzQ29tbWVudCA9PT0gYi5pc0NvbW1lbnQgJiZcbiAgICAgICAgICBpc0RlZihhLmRhdGEpID09PSBpc0RlZihiLmRhdGEpICYmXG4gICAgICAgICAgc2FtZUlucHV0VHlwZShhLCBiKVxuICAgICAgICApIHx8IChcbiAgICAgICAgICBpc1RydWUoYS5pc0FzeW5jUGxhY2Vob2xkZXIpICYmXG4gICAgICAgICAgYS5hc3luY0ZhY3RvcnkgPT09IGIuYXN5bmNGYWN0b3J5ICYmXG4gICAgICAgICAgaXNVbmRlZihiLmFzeW5jRmFjdG9yeS5lcnJvcilcbiAgICAgICAgKVxuICAgICAgKVxuICAgIClcbiAgfVxuXG4gIGZ1bmN0aW9uIHNhbWVJbnB1dFR5cGUgKGEsIGIpIHtcbiAgICBpZiAoYS50YWcgIT09ICdpbnB1dCcpIHsgcmV0dXJuIHRydWUgfVxuICAgIHZhciBpO1xuICAgIHZhciB0eXBlQSA9IGlzRGVmKGkgPSBhLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XG4gICAgdmFyIHR5cGVCID0gaXNEZWYoaSA9IGIuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgICByZXR1cm4gdHlwZUEgPT09IHR5cGVCIHx8IGlzVGV4dElucHV0VHlwZSh0eXBlQSkgJiYgaXNUZXh0SW5wdXRUeXBlKHR5cGVCKVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlS2V5VG9PbGRJZHggKGNoaWxkcmVuLCBiZWdpbklkeCwgZW5kSWR4KSB7XG4gICAgdmFyIGksIGtleTtcbiAgICB2YXIgbWFwID0ge307XG4gICAgZm9yIChpID0gYmVnaW5JZHg7IGkgPD0gZW5kSWR4OyArK2kpIHtcbiAgICAgIGtleSA9IGNoaWxkcmVuW2ldLmtleTtcbiAgICAgIGlmIChpc0RlZihrZXkpKSB7IG1hcFtrZXldID0gaTsgfVxuICAgIH1cbiAgICByZXR1cm4gbWFwXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQYXRjaEZ1bmN0aW9uIChiYWNrZW5kKSB7XG4gICAgdmFyIGksIGo7XG4gICAgdmFyIGNicyA9IHt9O1xuXG4gICAgdmFyIG1vZHVsZXMgPSBiYWNrZW5kLm1vZHVsZXM7XG4gICAgdmFyIG5vZGVPcHMgPSBiYWNrZW5kLm5vZGVPcHM7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNic1tob29rc1tpXV0gPSBbXTtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBtb2R1bGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGlmIChpc0RlZihtb2R1bGVzW2pdW2hvb2tzW2ldXSkpIHtcbiAgICAgICAgICBjYnNbaG9va3NbaV1dLnB1c2gobW9kdWxlc1tqXVtob29rc1tpXV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW1wdHlOb2RlQXQgKGVsbSkge1xuICAgICAgcmV0dXJuIG5ldyBWTm9kZShub2RlT3BzLnRhZ05hbWUoZWxtKS50b0xvd2VyQ2FzZSgpLCB7fSwgW10sIHVuZGVmaW5lZCwgZWxtKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJtQ2IgKGNoaWxkRWxtLCBsaXN0ZW5lcnMpIHtcbiAgICAgIGZ1bmN0aW9uIHJlbW92ZSQkMSAoKSB7XG4gICAgICAgIGlmICgtLXJlbW92ZSQkMS5saXN0ZW5lcnMgPT09IDApIHtcbiAgICAgICAgICByZW1vdmVOb2RlKGNoaWxkRWxtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVtb3ZlJCQxLmxpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICAgIHJldHVybiByZW1vdmUkJDFcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVOb2RlIChlbCkge1xuICAgICAgdmFyIHBhcmVudCA9IG5vZGVPcHMucGFyZW50Tm9kZShlbCk7XG4gICAgICAvLyBlbGVtZW50IG1heSBoYXZlIGFscmVhZHkgYmVlbiByZW1vdmVkIGR1ZSB0byB2LWh0bWwgLyB2LXRleHRcbiAgICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICAgIG5vZGVPcHMucmVtb3ZlQ2hpbGQocGFyZW50LCBlbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNVbmtub3duRWxlbWVudCQkMSAodm5vZGUsIGluVlByZSkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgIWluVlByZSAmJlxuICAgICAgICAhdm5vZGUubnMgJiZcbiAgICAgICAgIShcbiAgICAgICAgICBjb25maWcuaWdub3JlZEVsZW1lbnRzLmxlbmd0aCAmJlxuICAgICAgICAgIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMuc29tZShmdW5jdGlvbiAoaWdub3JlKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNSZWdFeHAoaWdub3JlKVxuICAgICAgICAgICAgICA/IGlnbm9yZS50ZXN0KHZub2RlLnRhZylcbiAgICAgICAgICAgICAgOiBpZ25vcmUgPT09IHZub2RlLnRhZ1xuICAgICAgICAgIH0pXG4gICAgICAgICkgJiZcbiAgICAgICAgY29uZmlnLmlzVW5rbm93bkVsZW1lbnQodm5vZGUudGFnKVxuICAgICAgKVxuICAgIH1cblxuICAgIHZhciBjcmVhdGluZ0VsbUluVlByZSA9IDA7XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVFbG0gKFxuICAgICAgdm5vZGUsXG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUsXG4gICAgICBwYXJlbnRFbG0sXG4gICAgICByZWZFbG0sXG4gICAgICBuZXN0ZWQsXG4gICAgICBvd25lckFycmF5LFxuICAgICAgaW5kZXhcbiAgICApIHtcbiAgICAgIGlmIChpc0RlZih2bm9kZS5lbG0pICYmIGlzRGVmKG93bmVyQXJyYXkpKSB7XG4gICAgICAgIC8vIFRoaXMgdm5vZGUgd2FzIHVzZWQgaW4gYSBwcmV2aW91cyByZW5kZXIhXG4gICAgICAgIC8vIG5vdyBpdCdzIHVzZWQgYXMgYSBuZXcgbm9kZSwgb3ZlcndyaXRpbmcgaXRzIGVsbSB3b3VsZCBjYXVzZVxuICAgICAgICAvLyBwb3RlbnRpYWwgcGF0Y2ggZXJyb3JzIGRvd24gdGhlIHJvYWQgd2hlbiBpdCdzIHVzZWQgYXMgYW4gaW5zZXJ0aW9uXG4gICAgICAgIC8vIHJlZmVyZW5jZSBub2RlLiBJbnN0ZWFkLCB3ZSBjbG9uZSB0aGUgbm9kZSBvbi1kZW1hbmQgYmVmb3JlIGNyZWF0aW5nXG4gICAgICAgIC8vIGFzc29jaWF0ZWQgRE9NIGVsZW1lbnQgZm9yIGl0LlxuICAgICAgICB2bm9kZSA9IG93bmVyQXJyYXlbaW5kZXhdID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gICAgICB9XG5cbiAgICAgIHZub2RlLmlzUm9vdEluc2VydCA9ICFuZXN0ZWQ7IC8vIGZvciB0cmFuc2l0aW9uIGVudGVyIGNoZWNrXG4gICAgICBpZiAoY3JlYXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgICB2YXIgdGFnID0gdm5vZGUudGFnO1xuICAgICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgICAge1xuICAgICAgICAgIGlmIChkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgICAgICBjcmVhdGluZ0VsbUluVlByZSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNVbmtub3duRWxlbWVudCQkMSh2bm9kZSwgY3JlYXRpbmdFbG1JblZQcmUpKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAnVW5rbm93biBjdXN0b20gZWxlbWVudDogPCcgKyB0YWcgKyAnPiAtIGRpZCB5b3UgJyArXG4gICAgICAgICAgICAgICdyZWdpc3RlciB0aGUgY29tcG9uZW50IGNvcnJlY3RseT8gRm9yIHJlY3Vyc2l2ZSBjb21wb25lbnRzLCAnICtcbiAgICAgICAgICAgICAgJ21ha2Ugc3VyZSB0byBwcm92aWRlIHRoZSBcIm5hbWVcIiBvcHRpb24uJyxcbiAgICAgICAgICAgICAgdm5vZGUuY29udGV4dFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2bm9kZS5lbG0gPSB2bm9kZS5uc1xuICAgICAgICAgID8gbm9kZU9wcy5jcmVhdGVFbGVtZW50TlModm5vZGUubnMsIHRhZylcbiAgICAgICAgICA6IG5vZGVPcHMuY3JlYXRlRWxlbWVudCh0YWcsIHZub2RlKTtcbiAgICAgICAgc2V0U2NvcGUodm5vZGUpO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICB7XG4gICAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgICAgY3JlYXRpbmdFbG1JblZQcmUtLTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSkge1xuICAgICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZUNvbW1lbnQodm5vZGUudGV4dCk7XG4gICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dCk7XG4gICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgICB2YXIgaSA9IHZub2RlLmRhdGE7XG4gICAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgICAgdmFyIGlzUmVhY3RpdmF0ZWQgPSBpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaS5rZWVwQWxpdmU7XG4gICAgICAgIGlmIChpc0RlZihpID0gaS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkge1xuICAgICAgICAgIGkodm5vZGUsIGZhbHNlIC8qIGh5ZHJhdGluZyAqLyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWZ0ZXIgY2FsbGluZyB0aGUgaW5pdCBob29rLCBpZiB0aGUgdm5vZGUgaXMgYSBjaGlsZCBjb21wb25lbnRcbiAgICAgICAgLy8gaXQgc2hvdWxkJ3ZlIGNyZWF0ZWQgYSBjaGlsZCBpbnN0YW5jZSBhbmQgbW91bnRlZCBpdC4gdGhlIGNoaWxkXG4gICAgICAgIC8vIGNvbXBvbmVudCBhbHNvIGhhcyBzZXQgdGhlIHBsYWNlaG9sZGVyIHZub2RlJ3MgZWxtLlxuICAgICAgICAvLyBpbiB0aGF0IGNhc2Ugd2UgY2FuIGp1c3QgcmV0dXJuIHRoZSBlbGVtZW50IGFuZCBiZSBkb25lLlxuICAgICAgICBpZiAoaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgICAgICAgaWYgKGlzVHJ1ZShpc1JlYWN0aXZhdGVkKSkge1xuICAgICAgICAgICAgcmVhY3RpdmF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbml0Q29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgICBpZiAoaXNEZWYodm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KSkge1xuICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaC5hcHBseShpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCk7XG4gICAgICAgIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCA9IG51bGw7XG4gICAgICB9XG4gICAgICB2bm9kZS5lbG0gPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kZWw7XG4gICAgICBpZiAoaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBzZXRTY29wZSh2bm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBlbXB0eSBjb21wb25lbnQgcm9vdC5cbiAgICAgICAgLy8gc2tpcCBhbGwgZWxlbWVudC1yZWxhdGVkIG1vZHVsZXMgZXhjZXB0IGZvciByZWYgKCMzNDU1KVxuICAgICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0byBpbnZva2UgdGhlIGluc2VydCBob29rXG4gICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWFjdGl2YXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgICAgdmFyIGk7XG4gICAgICAvLyBoYWNrIGZvciAjNDMzOTogYSByZWFjdGl2YXRlZCBjb21wb25lbnQgd2l0aCBpbm5lciB0cmFuc2l0aW9uXG4gICAgICAvLyBkb2VzIG5vdCB0cmlnZ2VyIGJlY2F1c2UgdGhlIGlubmVyIG5vZGUncyBjcmVhdGVkIGhvb2tzIGFyZSBub3QgY2FsbGVkXG4gICAgICAvLyBhZ2Fpbi4gSXQncyBub3QgaWRlYWwgdG8gaW52b2x2ZSBtb2R1bGUtc3BlY2lmaWMgbG9naWMgaW4gaGVyZSBidXRcbiAgICAgIC8vIHRoZXJlIGRvZXNuJ3Qgc2VlbSB0byBiZSBhIGJldHRlciB3YXkgdG8gZG8gaXQuXG4gICAgICB2YXIgaW5uZXJOb2RlID0gdm5vZGU7XG4gICAgICB3aGlsZSAoaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICAgIGlubmVyTm9kZSA9IGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICAgIGlmIChpc0RlZihpID0gaW5uZXJOb2RlLmRhdGEpICYmIGlzRGVmKGkgPSBpLnRyYW5zaXRpb24pKSB7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5hY3RpdmF0ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY2JzLmFjdGl2YXRlW2ldKGVtcHR5Tm9kZSwgaW5uZXJOb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2goaW5uZXJOb2RlKTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyB1bmxpa2UgYSBuZXdseSBjcmVhdGVkIGNvbXBvbmVudCxcbiAgICAgIC8vIGEgcmVhY3RpdmF0ZWQga2VlcC1hbGl2ZSBjb21wb25lbnQgZG9lc24ndCBpbnNlcnQgaXRzZWxmXG4gICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zZXJ0IChwYXJlbnQsIGVsbSwgcmVmJCQxKSB7XG4gICAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgICBpZiAoaXNEZWYocmVmJCQxKSkge1xuICAgICAgICAgIGlmIChub2RlT3BzLnBhcmVudE5vZGUocmVmJCQxKSA9PT0gcGFyZW50KSB7XG4gICAgICAgICAgICBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnQsIGVsbSwgcmVmJCQxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZChwYXJlbnQsIGVsbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVDaGlsZHJlbiAodm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICB7XG4gICAgICAgICAgY2hlY2tEdXBsaWNhdGVLZXlzKGNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgY3JlYXRlRWxtKGNoaWxkcmVuW2ldLCBpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmVsbSwgbnVsbCwgdHJ1ZSwgY2hpbGRyZW4sIGkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKHZub2RlLnRleHQpKSB7XG4gICAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQodm5vZGUuZWxtLCBub2RlT3BzLmNyZWF0ZVRleHROb2RlKFN0cmluZyh2bm9kZS50ZXh0KSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzUGF0Y2hhYmxlICh2bm9kZSkge1xuICAgICAgd2hpbGUgKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICAgIHZub2RlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzRGVmKHZub2RlLnRhZylcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnZva2VDcmVhdGVIb29rcyAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSQxKSB7XG4gICAgICAgIGNicy5jcmVhdGVbaSQxXShlbXB0eU5vZGUsIHZub2RlKTtcbiAgICAgIH1cbiAgICAgIGkgPSB2bm9kZS5kYXRhLmhvb2s7IC8vIFJldXNlIHZhcmlhYmxlXG4gICAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgICAgaWYgKGlzRGVmKGkuY3JlYXRlKSkgeyBpLmNyZWF0ZShlbXB0eU5vZGUsIHZub2RlKTsgfVxuICAgICAgICBpZiAoaXNEZWYoaS5pbnNlcnQpKSB7IGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTsgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNldCBzY29wZSBpZCBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBDU1MuXG4gICAgLy8gdGhpcyBpcyBpbXBsZW1lbnRlZCBhcyBhIHNwZWNpYWwgY2FzZSB0byBhdm9pZCB0aGUgb3ZlcmhlYWRcbiAgICAvLyBvZiBnb2luZyB0aHJvdWdoIHRoZSBub3JtYWwgYXR0cmlidXRlIHBhdGNoaW5nIHByb2Nlc3MuXG4gICAgZnVuY3Rpb24gc2V0U2NvcGUgKHZub2RlKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuZm5TY29wZUlkKSkge1xuICAgICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBhbmNlc3RvciA9IHZub2RlO1xuICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgICBpZiAoaXNEZWYoaSA9IGFuY2VzdG9yLmNvbnRleHQpICYmIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKSkge1xuICAgICAgICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBmb3Igc2xvdCBjb250ZW50IHRoZXkgc2hvdWxkIGFsc28gZ2V0IHRoZSBzY29wZUlkIGZyb20gdGhlIGhvc3QgaW5zdGFuY2UuXG4gICAgICBpZiAoaXNEZWYoaSA9IGFjdGl2ZUluc3RhbmNlKSAmJlxuICAgICAgICBpICE9PSB2bm9kZS5jb250ZXh0ICYmXG4gICAgICAgIGkgIT09IHZub2RlLmZuQ29udGV4dCAmJlxuICAgICAgICBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZClcbiAgICAgICkge1xuICAgICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRWbm9kZXMgKHBhcmVudEVsbSwgcmVmRWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgICBjcmVhdGVFbG0odm5vZGVzW3N0YXJ0SWR4XSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSwgZmFsc2UsIHZub2Rlcywgc3RhcnRJZHgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludm9rZURlc3Ryb3lIb29rICh2bm9kZSkge1xuICAgICAgdmFyIGksIGo7XG4gICAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmRlc3Ryb3kpKSB7IGkodm5vZGUpOyB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkgeyBjYnMuZGVzdHJveVtpXSh2bm9kZSk7IH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7ICsraikge1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKHZub2RlLmNoaWxkcmVuW2pdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZVZub2RlcyAocGFyZW50RWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgpIHtcbiAgICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgICAgdmFyIGNoID0gdm5vZGVzW3N0YXJ0SWR4XTtcbiAgICAgICAgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICAgIGlmIChpc0RlZihjaC50YWcpKSB7XG4gICAgICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGNoKTtcbiAgICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKGNoKTtcbiAgICAgICAgICB9IGVsc2UgeyAvLyBUZXh0IG5vZGVcbiAgICAgICAgICAgIHJlbW92ZU5vZGUoY2guZWxtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rICh2bm9kZSwgcm0pIHtcbiAgICAgIGlmIChpc0RlZihybSkgfHwgaXNEZWYodm5vZGUuZGF0YSkpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSBjYnMucmVtb3ZlLmxlbmd0aCArIDE7XG4gICAgICAgIGlmIChpc0RlZihybSkpIHtcbiAgICAgICAgICAvLyB3ZSBoYXZlIGEgcmVjdXJzaXZlbHkgcGFzc2VkIGRvd24gcm0gY2FsbGJhY2tcbiAgICAgICAgICAvLyBpbmNyZWFzZSB0aGUgbGlzdGVuZXJzIGNvdW50XG4gICAgICAgICAgcm0ubGlzdGVuZXJzICs9IGxpc3RlbmVycztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBkaXJlY3RseSByZW1vdmluZ1xuICAgICAgICAgIHJtID0gY3JlYXRlUm1DYih2bm9kZS5lbG0sIGxpc3RlbmVycyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVjdXJzaXZlbHkgaW52b2tlIGhvb2tzIG9uIGNoaWxkIGNvbXBvbmVudCByb290IG5vZGVcbiAgICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaXNEZWYoaSA9IGkuX3Zub2RlKSAmJiBpc0RlZihpLmRhdGEpKSB7XG4gICAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhpLCBybSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5yZW1vdmUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBjYnMucmVtb3ZlW2ldKHZub2RlLCBybSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5kYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnJlbW92ZSkpIHtcbiAgICAgICAgICBpKHZub2RlLCBybSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcm0oKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVtb3ZlTm9kZSh2bm9kZS5lbG0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUNoaWxkcmVuIChwYXJlbnRFbG0sIG9sZENoLCBuZXdDaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KSB7XG4gICAgICB2YXIgb2xkU3RhcnRJZHggPSAwO1xuICAgICAgdmFyIG5ld1N0YXJ0SWR4ID0gMDtcbiAgICAgIHZhciBvbGRFbmRJZHggPSBvbGRDaC5sZW5ndGggLSAxO1xuICAgICAgdmFyIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFswXTtcbiAgICAgIHZhciBvbGRFbmRWbm9kZSA9IG9sZENoW29sZEVuZElkeF07XG4gICAgICB2YXIgbmV3RW5kSWR4ID0gbmV3Q2gubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBuZXdTdGFydFZub2RlID0gbmV3Q2hbMF07XG4gICAgICB2YXIgbmV3RW5kVm5vZGUgPSBuZXdDaFtuZXdFbmRJZHhdO1xuICAgICAgdmFyIG9sZEtleVRvSWR4LCBpZHhJbk9sZCwgdm5vZGVUb01vdmUsIHJlZkVsbTtcblxuICAgICAgLy8gcmVtb3ZlT25seSBpcyBhIHNwZWNpYWwgZmxhZyB1c2VkIG9ubHkgYnkgPHRyYW5zaXRpb24tZ3JvdXA+XG4gICAgICAvLyB0byBlbnN1cmUgcmVtb3ZlZCBlbGVtZW50cyBzdGF5IGluIGNvcnJlY3QgcmVsYXRpdmUgcG9zaXRpb25zXG4gICAgICAvLyBkdXJpbmcgbGVhdmluZyB0cmFuc2l0aW9uc1xuICAgICAgdmFyIGNhbk1vdmUgPSAhcmVtb3ZlT25seTtcblxuICAgICAge1xuICAgICAgICBjaGVja0R1cGxpY2F0ZUtleXMobmV3Q2gpO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAob2xkU3RhcnRJZHggPD0gb2xkRW5kSWR4ICYmIG5ld1N0YXJ0SWR4IDw9IG5ld0VuZElkeCkge1xuICAgICAgICBpZiAoaXNVbmRlZihvbGRTdGFydFZub2RlKSkge1xuICAgICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTsgLy8gVm5vZGUgaGFzIGJlZW4gbW92ZWQgbGVmdFxuICAgICAgICB9IGVsc2UgaWYgKGlzVW5kZWYob2xkRW5kVm5vZGUpKSB7XG4gICAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlKSkge1xuICAgICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdFbmRJZHgpO1xuICAgICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgcmlnaHRcbiAgICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdFbmRJZHgpO1xuICAgICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbmRWbm9kZS5lbG0pKTtcbiAgICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCBsZWZ0XG4gICAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRFbmRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGlzVW5kZWYob2xkS2V5VG9JZHgpKSB7IG9sZEtleVRvSWR4ID0gY3JlYXRlS2V5VG9PbGRJZHgob2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpOyB9XG4gICAgICAgICAgaWR4SW5PbGQgPSBpc0RlZihuZXdTdGFydFZub2RlLmtleSlcbiAgICAgICAgICAgID8gb2xkS2V5VG9JZHhbbmV3U3RhcnRWbm9kZS5rZXldXG4gICAgICAgICAgICA6IGZpbmRJZHhJbk9sZChuZXdTdGFydFZub2RlLCBvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgICAgICAgaWYgKGlzVW5kZWYoaWR4SW5PbGQpKSB7IC8vIE5ldyBlbGVtZW50XG4gICAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBmYWxzZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdm5vZGVUb01vdmUgPSBvbGRDaFtpZHhJbk9sZF07XG4gICAgICAgICAgICBpZiAoc2FtZVZub2RlKHZub2RlVG9Nb3ZlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICAgICAgICBwYXRjaFZub2RlKHZub2RlVG9Nb3ZlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgICAgICAgIG9sZENoW2lkeEluT2xkXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIHZub2RlVG9Nb3ZlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gc2FtZSBrZXkgYnV0IGRpZmZlcmVudCBlbGVtZW50LiB0cmVhdCBhcyBuZXcgZWxlbWVudFxuICAgICAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBmYWxzZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob2xkU3RhcnRJZHggPiBvbGRFbmRJZHgpIHtcbiAgICAgICAgcmVmRWxtID0gaXNVbmRlZihuZXdDaFtuZXdFbmRJZHggKyAxXSkgPyBudWxsIDogbmV3Q2hbbmV3RW5kSWR4ICsgMV0uZWxtO1xuICAgICAgICBhZGRWbm9kZXMocGFyZW50RWxtLCByZWZFbG0sIG5ld0NoLCBuZXdTdGFydElkeCwgbmV3RW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIGlmIChuZXdTdGFydElkeCA+IG5ld0VuZElkeCkge1xuICAgICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtLCBvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tEdXBsaWNhdGVLZXlzIChjaGlsZHJlbikge1xuICAgICAgdmFyIHNlZW5LZXlzID0ge307XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB2bm9kZSA9IGNoaWxkcmVuW2ldO1xuICAgICAgICB2YXIga2V5ID0gdm5vZGUua2V5O1xuICAgICAgICBpZiAoaXNEZWYoa2V5KSkge1xuICAgICAgICAgIGlmIChzZWVuS2V5c1trZXldKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAoXCJEdXBsaWNhdGUga2V5cyBkZXRlY3RlZDogJ1wiICsga2V5ICsgXCInLiBUaGlzIG1heSBjYXVzZSBhbiB1cGRhdGUgZXJyb3IuXCIpLFxuICAgICAgICAgICAgICB2bm9kZS5jb250ZXh0XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWVuS2V5c1trZXldID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaW5kSWR4SW5PbGQgKG5vZGUsIG9sZENoLCBzdGFydCwgZW5kKSB7XG4gICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICB2YXIgYyA9IG9sZENoW2ldO1xuICAgICAgICBpZiAoaXNEZWYoYykgJiYgc2FtZVZub2RlKG5vZGUsIGMpKSB7IHJldHVybiBpIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXRjaFZub2RlIChcbiAgICAgIG9sZFZub2RlLFxuICAgICAgdm5vZGUsXG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUsXG4gICAgICBvd25lckFycmF5LFxuICAgICAgaW5kZXgsXG4gICAgICByZW1vdmVPbmx5XG4gICAgKSB7XG4gICAgICBpZiAob2xkVm5vZGUgPT09IHZub2RlKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAoaXNEZWYodm5vZGUuZWxtKSAmJiBpc0RlZihvd25lckFycmF5KSkge1xuICAgICAgICAvLyBjbG9uZSByZXVzZWQgdm5vZGVcbiAgICAgICAgdm5vZGUgPSBvd25lckFycmF5W2luZGV4XSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxtID0gdm5vZGUuZWxtID0gb2xkVm5vZGUuZWxtO1xuXG4gICAgICBpZiAoaXNUcnVlKG9sZFZub2RlLmlzQXN5bmNQbGFjZWhvbGRlcikpIHtcbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLmFzeW5jRmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICBoeWRyYXRlKG9sZFZub2RlLmVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gcmV1c2UgZWxlbWVudCBmb3Igc3RhdGljIHRyZWVzLlxuICAgICAgLy8gbm90ZSB3ZSBvbmx5IGRvIHRoaXMgaWYgdGhlIHZub2RlIGlzIGNsb25lZCAtXG4gICAgICAvLyBpZiB0aGUgbmV3IG5vZGUgaXMgbm90IGNsb25lZCBpdCBtZWFucyB0aGUgcmVuZGVyIGZ1bmN0aW9ucyBoYXZlIGJlZW5cbiAgICAgIC8vIHJlc2V0IGJ5IHRoZSBob3QtcmVsb2FkLWFwaSBhbmQgd2UgbmVlZCB0byBkbyBhIHByb3BlciByZS1yZW5kZXIuXG4gICAgICBpZiAoaXNUcnVlKHZub2RlLmlzU3RhdGljKSAmJlxuICAgICAgICBpc1RydWUob2xkVm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICAgIHZub2RlLmtleSA9PT0gb2xkVm5vZGUua2V5ICYmXG4gICAgICAgIChpc1RydWUodm5vZGUuaXNDbG9uZWQpIHx8IGlzVHJ1ZSh2bm9kZS5pc09uY2UpKVxuICAgICAgKSB7XG4gICAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wcmVwYXRjaCkpIHtcbiAgICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb2xkQ2ggPSBvbGRWbm9kZS5jaGlsZHJlbjtcbiAgICAgIHZhciBjaCA9IHZub2RlLmNoaWxkcmVuO1xuICAgICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnVwZGF0ZS5sZW5ndGg7ICsraSkgeyBjYnMudXBkYXRlW2ldKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnVwZGF0ZSkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgICB9XG4gICAgICBpZiAoaXNVbmRlZih2bm9kZS50ZXh0KSkge1xuICAgICAgICBpZiAoaXNEZWYob2xkQ2gpICYmIGlzRGVmKGNoKSkge1xuICAgICAgICAgIGlmIChvbGRDaCAhPT0gY2gpIHsgdXBkYXRlQ2hpbGRyZW4oZWxtLCBvbGRDaCwgY2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7IH1cbiAgICAgICAgfSBlbHNlIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjaGVja0R1cGxpY2F0ZUtleXMoY2gpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHsgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTsgfVxuICAgICAgICAgIGFkZFZub2RlcyhlbG0sIG51bGwsIGNoLCAwLCBjaC5sZW5ndGggLSAxLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZENoKSkge1xuICAgICAgICAgIHJlbW92ZVZub2RlcyhlbG0sIG9sZENoLCAwLCBvbGRDaC5sZW5ndGggLSAxKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkge1xuICAgICAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAob2xkVm5vZGUudGV4dCAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgdm5vZGUudGV4dCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnBvc3RwYXRjaCkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW52b2tlSW5zZXJ0SG9vayAodm5vZGUsIHF1ZXVlLCBpbml0aWFsKSB7XG4gICAgICAvLyBkZWxheSBpbnNlcnQgaG9va3MgZm9yIGNvbXBvbmVudCByb290IG5vZGVzLCBpbnZva2UgdGhlbSBhZnRlciB0aGVcbiAgICAgIC8vIGVsZW1lbnQgaXMgcmVhbGx5IGluc2VydGVkXG4gICAgICBpZiAoaXNUcnVlKGluaXRpYWwpICYmIGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgICAgdm5vZGUucGFyZW50LmRhdGEucGVuZGluZ0luc2VydCA9IHF1ZXVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHF1ZXVlW2ldLmRhdGEuaG9vay5pbnNlcnQocXVldWVbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGh5ZHJhdGlvbkJhaWxlZCA9IGZhbHNlO1xuICAgIC8vIGxpc3Qgb2YgbW9kdWxlcyB0aGF0IGNhbiBza2lwIGNyZWF0ZSBob29rIGR1cmluZyBoeWRyYXRpb24gYmVjYXVzZSB0aGV5XG4gICAgLy8gYXJlIGFscmVhZHkgcmVuZGVyZWQgb24gdGhlIGNsaWVudCBvciBoYXMgbm8gbmVlZCBmb3IgaW5pdGlhbGl6YXRpb25cbiAgICAvLyBOb3RlOiBzdHlsZSBpcyBleGNsdWRlZCBiZWNhdXNlIGl0IHJlbGllcyBvbiBpbml0aWFsIGNsb25lIGZvciBmdXR1cmVcbiAgICAvLyBkZWVwIHVwZGF0ZXMgKCM3MDYzKS5cbiAgICB2YXIgaXNSZW5kZXJlZE1vZHVsZSA9IG1ha2VNYXAoJ2F0dHJzLGNsYXNzLHN0YXRpY0NsYXNzLHN0YXRpY1N0eWxlLGtleScpO1xuXG4gICAgLy8gTm90ZTogdGhpcyBpcyBhIGJyb3dzZXItb25seSBmdW5jdGlvbiBzbyB3ZSBjYW4gYXNzdW1lIGVsbXMgYXJlIERPTSBub2Rlcy5cbiAgICBmdW5jdGlvbiBoeWRyYXRlIChlbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIGluVlByZSkge1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgdGFnID0gdm5vZGUudGFnO1xuICAgICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgICBpblZQcmUgPSBpblZQcmUgfHwgKGRhdGEgJiYgZGF0YS5wcmUpO1xuICAgICAgdm5vZGUuZWxtID0gZWxtO1xuXG4gICAgICBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkgJiYgaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5KSkge1xuICAgICAgICB2bm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgLy8gYXNzZXJ0IG5vZGUgbWF0Y2hcbiAgICAgIHtcbiAgICAgICAgaWYgKCFhc3NlcnROb2RlTWF0Y2goZWxtLCB2bm9kZSwgaW5WUHJlKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7IGkodm5vZGUsIHRydWUgLyogaHlkcmF0aW5nICovKTsgfVxuICAgICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICAgIC8vIGNoaWxkIGNvbXBvbmVudC4gaXQgc2hvdWxkIGhhdmUgaHlkcmF0ZWQgaXRzIG93biB0cmVlLlxuICAgICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgICAgaWYgKGlzRGVmKGNoaWxkcmVuKSkge1xuICAgICAgICAgIC8vIGVtcHR5IGVsZW1lbnQsIGFsbG93IGNsaWVudCB0byBwaWNrIHVwIGFuZCBwb3B1bGF0ZSBjaGlsZHJlblxuICAgICAgICAgIGlmICghZWxtLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB2LWh0bWwgYW5kIGRvbVByb3BzOiBpbm5lckhUTUxcbiAgICAgICAgICAgIGlmIChpc0RlZihpID0gZGF0YSkgJiYgaXNEZWYoaSA9IGkuZG9tUHJvcHMpICYmIGlzRGVmKGkgPSBpLmlubmVySFRNTCkpIHtcbiAgICAgICAgICAgICAgaWYgKGkgIT09IGVsbS5pbm5lckhUTUwpIHtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgICAhaHlkcmF0aW9uQmFpbGVkXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICBoeWRyYXRpb25CYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQYXJlbnQ6ICcsIGVsbSk7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ3NlcnZlciBpbm5lckhUTUw6ICcsIGkpO1xuICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdjbGllbnQgaW5uZXJIVE1MOiAnLCBlbG0uaW5uZXJIVE1MKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGl0ZXJhdGUgYW5kIGNvbXBhcmUgY2hpbGRyZW4gbGlzdHNcbiAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICB2YXIgY2hpbGROb2RlID0gZWxtLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNoaWxkTm9kZSB8fCAhaHlkcmF0ZShjaGlsZE5vZGUsIGNoaWxkcmVuW2kkMV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSkge1xuICAgICAgICAgICAgICAgICAgY2hpbGRyZW5NYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIGlmIGNoaWxkTm9kZSBpcyBub3QgbnVsbCwgaXQgbWVhbnMgdGhlIGFjdHVhbCBjaGlsZE5vZGVzIGxpc3QgaXNcbiAgICAgICAgICAgICAgLy8gbG9uZ2VyIHRoYW4gdGhlIHZpcnR1YWwgY2hpbGRyZW4gbGlzdC5cbiAgICAgICAgICAgICAgaWYgKCFjaGlsZHJlbk1hdGNoIHx8IGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAgICFoeWRyYXRpb25CYWlsZWRcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIGh5ZHJhdGlvbkJhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignTWlzbWF0Y2hpbmcgY2hpbGROb2RlcyB2cy4gVk5vZGVzOiAnLCBlbG0uY2hpbGROb2RlcywgY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgICB2YXIgZnVsbEludm9rZSA9IGZhbHNlO1xuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIWlzUmVuZGVyZWRNb2R1bGUoa2V5KSkge1xuICAgICAgICAgICAgICBmdWxsSW52b2tlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZnVsbEludm9rZSAmJiBkYXRhWydjbGFzcyddKSB7XG4gICAgICAgICAgICAvLyBlbnN1cmUgY29sbGVjdGluZyBkZXBzIGZvciBkZWVwIGNsYXNzIGJpbmRpbmdzIGZvciBmdXR1cmUgdXBkYXRlc1xuICAgICAgICAgICAgdHJhdmVyc2UoZGF0YVsnY2xhc3MnXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGVsbS5kYXRhICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICAgIGVsbS5kYXRhID0gdm5vZGUudGV4dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXNzZXJ0Tm9kZU1hdGNoIChub2RlLCB2bm9kZSwgaW5WUHJlKSB7XG4gICAgICBpZiAoaXNEZWYodm5vZGUudGFnKSkge1xuICAgICAgICByZXR1cm4gdm5vZGUudGFnLmluZGV4T2YoJ3Z1ZS1jb21wb25lbnQnKSA9PT0gMCB8fCAoXG4gICAgICAgICAgIWlzVW5rbm93bkVsZW1lbnQkJDEodm5vZGUsIGluVlByZSkgJiZcbiAgICAgICAgICB2bm9kZS50YWcudG9Mb3dlckNhc2UoKSA9PT0gKG5vZGUudGFnTmFtZSAmJiBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSlcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09ICh2bm9kZS5pc0NvbW1lbnQgPyA4IDogMylcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gcGF0Y2ggKG9sZFZub2RlLCB2bm9kZSwgaHlkcmF0aW5nLCByZW1vdmVPbmx5KSB7XG4gICAgICBpZiAoaXNVbmRlZih2bm9kZSkpIHtcbiAgICAgICAgaWYgKGlzRGVmKG9sZFZub2RlKSkgeyBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7IH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHZhciBpc0luaXRpYWxQYXRjaCA9IGZhbHNlO1xuICAgICAgdmFyIGluc2VydGVkVm5vZGVRdWV1ZSA9IFtdO1xuXG4gICAgICBpZiAoaXNVbmRlZihvbGRWbm9kZSkpIHtcbiAgICAgICAgLy8gZW1wdHkgbW91bnQgKGxpa2VseSBhcyBjb21wb25lbnQpLCBjcmVhdGUgbmV3IHJvb3QgZWxlbWVudFxuICAgICAgICBpc0luaXRpYWxQYXRjaCA9IHRydWU7XG4gICAgICAgIGNyZWF0ZUVsbSh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpc1JlYWxFbGVtZW50ID0gaXNEZWYob2xkVm5vZGUubm9kZVR5cGUpO1xuICAgICAgICBpZiAoIWlzUmVhbEVsZW1lbnQgJiYgc2FtZVZub2RlKG9sZFZub2RlLCB2bm9kZSkpIHtcbiAgICAgICAgICAvLyBwYXRjaCBleGlzdGluZyByb290IG5vZGVcbiAgICAgICAgICBwYXRjaFZub2RlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBudWxsLCBudWxsLCByZW1vdmVPbmx5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaXNSZWFsRWxlbWVudCkge1xuICAgICAgICAgICAgLy8gbW91bnRpbmcgdG8gYSByZWFsIGVsZW1lbnRcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoaXMgaXMgc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQgYW5kIGlmIHdlIGNhbiBwZXJmb3JtXG4gICAgICAgICAgICAvLyBhIHN1Y2Nlc3NmdWwgaHlkcmF0aW9uLlxuICAgICAgICAgICAgaWYgKG9sZFZub2RlLm5vZGVUeXBlID09PSAxICYmIG9sZFZub2RlLmhhc0F0dHJpYnV0ZShTU1JfQVRUUikpIHtcbiAgICAgICAgICAgICAgb2xkVm5vZGUucmVtb3ZlQXR0cmlidXRlKFNTUl9BVFRSKTtcbiAgICAgICAgICAgICAgaHlkcmF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1RydWUoaHlkcmF0aW5nKSkge1xuICAgICAgICAgICAgICBpZiAoaHlkcmF0ZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkpIHtcbiAgICAgICAgICAgICAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvbGRWbm9kZVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgICAnVGhlIGNsaWVudC1zaWRlIHJlbmRlcmVkIHZpcnR1YWwgRE9NIHRyZWUgaXMgbm90IG1hdGNoaW5nICcgK1xuICAgICAgICAgICAgICAgICAgJ3NlcnZlci1yZW5kZXJlZCBjb250ZW50LiBUaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgaW5jb3JyZWN0ICcgK1xuICAgICAgICAgICAgICAgICAgJ0hUTUwgbWFya3VwLCBmb3IgZXhhbXBsZSBuZXN0aW5nIGJsb2NrLWxldmVsIGVsZW1lbnRzIGluc2lkZSAnICtcbiAgICAgICAgICAgICAgICAgICc8cD4sIG9yIG1pc3NpbmcgPHRib2R5Pi4gQmFpbGluZyBoeWRyYXRpb24gYW5kIHBlcmZvcm1pbmcgJyArXG4gICAgICAgICAgICAgICAgICAnZnVsbCBjbGllbnQtc2lkZSByZW5kZXIuJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVpdGhlciBub3Qgc2VydmVyLXJlbmRlcmVkLCBvciBoeWRyYXRpb24gZmFpbGVkLlxuICAgICAgICAgICAgLy8gY3JlYXRlIGFuIGVtcHR5IG5vZGUgYW5kIHJlcGxhY2UgaXRcbiAgICAgICAgICAgIG9sZFZub2RlID0gZW1wdHlOb2RlQXQob2xkVm5vZGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHJlcGxhY2luZyBleGlzdGluZyBlbGVtZW50XG4gICAgICAgICAgdmFyIG9sZEVsbSA9IG9sZFZub2RlLmVsbTtcbiAgICAgICAgICB2YXIgcGFyZW50RWxtID0gbm9kZU9wcy5wYXJlbnROb2RlKG9sZEVsbSk7XG5cbiAgICAgICAgICAvLyBjcmVhdGUgbmV3IG5vZGVcbiAgICAgICAgICBjcmVhdGVFbG0oXG4gICAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICAgICAgICAgIC8vIGV4dHJlbWVseSByYXJlIGVkZ2UgY2FzZTogZG8gbm90IGluc2VydCBpZiBvbGQgZWxlbWVudCBpcyBpbiBhXG4gICAgICAgICAgICAvLyBsZWF2aW5nIHRyYW5zaXRpb24uIE9ubHkgaGFwcGVucyB3aGVuIGNvbWJpbmluZyB0cmFuc2l0aW9uICtcbiAgICAgICAgICAgIC8vIGtlZXAtYWxpdmUgKyBIT0NzLiAoIzQ1OTApXG4gICAgICAgICAgICBvbGRFbG0uX2xlYXZlQ2IgPyBudWxsIDogcGFyZW50RWxtLFxuICAgICAgICAgICAgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbG0pXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIHVwZGF0ZSBwYXJlbnQgcGxhY2Vob2xkZXIgbm9kZSBlbGVtZW50LCByZWN1cnNpdmVseVxuICAgICAgICAgIGlmIChpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICAgICAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZS5wYXJlbnQ7XG4gICAgICAgICAgICB2YXIgcGF0Y2hhYmxlID0gaXNQYXRjaGFibGUodm5vZGUpO1xuICAgICAgICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjYnMuZGVzdHJveVtpXShhbmNlc3Rvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYW5jZXN0b3IuZWxtID0gdm5vZGUuZWxtO1xuICAgICAgICAgICAgICBpZiAocGF0Y2hhYmxlKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSQxKSB7XG4gICAgICAgICAgICAgICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCBhbmNlc3Rvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vICM2NTEzXG4gICAgICAgICAgICAgICAgLy8gaW52b2tlIGluc2VydCBob29rcyB0aGF0IG1heSBoYXZlIGJlZW4gbWVyZ2VkIGJ5IGNyZWF0ZSBob29rcy5cbiAgICAgICAgICAgICAgICAvLyBlLmcuIGZvciBkaXJlY3RpdmVzIHRoYXQgdXNlcyB0aGUgXCJpbnNlcnRlZFwiIGhvb2suXG4gICAgICAgICAgICAgICAgdmFyIGluc2VydCA9IGFuY2VzdG9yLmRhdGEuaG9vay5pbnNlcnQ7XG4gICAgICAgICAgICAgICAgaWYgKGluc2VydC5tZXJnZWQpIHtcbiAgICAgICAgICAgICAgICAgIC8vIHN0YXJ0IGF0IGluZGV4IDEgdG8gYXZvaWQgcmUtaW52b2tpbmcgY29tcG9uZW50IG1vdW50ZWQgaG9va1xuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSQyID0gMTsgaSQyIDwgaW5zZXJ0LmZucy5sZW5ndGg7IGkkMisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydC5mbnNbaSQyXSgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWdpc3RlclJlZihhbmNlc3Rvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gZGVzdHJveSBvbGQgbm9kZVxuICAgICAgICAgIGlmIChpc0RlZihwYXJlbnRFbG0pKSB7XG4gICAgICAgICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtLCBbb2xkVm5vZGVdLCAwLCAwKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRhZykpIHtcbiAgICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpc0luaXRpYWxQYXRjaCk7XG4gICAgICByZXR1cm4gdm5vZGUuZWxtXG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cbiAgdmFyIGRpcmVjdGl2ZXMgPSB7XG4gICAgY3JlYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICAgIHVwZGF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcbiAgICBkZXN0cm95OiBmdW5jdGlvbiB1bmJpbmREaXJlY3RpdmVzICh2bm9kZSkge1xuICAgICAgdXBkYXRlRGlyZWN0aXZlcyh2bm9kZSwgZW1wdHlOb2RlKTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gdXBkYXRlRGlyZWN0aXZlcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgaWYgKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcyB8fCB2bm9kZS5kYXRhLmRpcmVjdGl2ZXMpIHtcbiAgICAgIF91cGRhdGUob2xkVm5vZGUsIHZub2RlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICB2YXIgaXNDcmVhdGUgPSBvbGRWbm9kZSA9PT0gZW1wdHlOb2RlO1xuICAgIHZhciBpc0Rlc3Ryb3kgPSB2bm9kZSA9PT0gZW1wdHlOb2RlO1xuICAgIHZhciBvbGREaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcywgb2xkVm5vZGUuY29udGV4dCk7XG4gICAgdmFyIG5ld0RpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEodm5vZGUuZGF0YS5kaXJlY3RpdmVzLCB2bm9kZS5jb250ZXh0KTtcblxuICAgIHZhciBkaXJzV2l0aEluc2VydCA9IFtdO1xuICAgIHZhciBkaXJzV2l0aFBvc3RwYXRjaCA9IFtdO1xuXG4gICAgdmFyIGtleSwgb2xkRGlyLCBkaXI7XG4gICAgZm9yIChrZXkgaW4gbmV3RGlycykge1xuICAgICAgb2xkRGlyID0gb2xkRGlyc1trZXldO1xuICAgICAgZGlyID0gbmV3RGlyc1trZXldO1xuICAgICAgaWYgKCFvbGREaXIpIHtcbiAgICAgICAgLy8gbmV3IGRpcmVjdGl2ZSwgYmluZFxuICAgICAgICBjYWxsSG9vayQxKGRpciwgJ2JpbmQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmluc2VydGVkKSB7XG4gICAgICAgICAgZGlyc1dpdGhJbnNlcnQucHVzaChkaXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBleGlzdGluZyBkaXJlY3RpdmUsIHVwZGF0ZVxuICAgICAgICBkaXIub2xkVmFsdWUgPSBvbGREaXIudmFsdWU7XG4gICAgICAgIGRpci5vbGRBcmcgPSBvbGREaXIuYXJnO1xuICAgICAgICBjYWxsSG9vayQxKGRpciwgJ3VwZGF0ZScsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuY29tcG9uZW50VXBkYXRlZCkge1xuICAgICAgICAgIGRpcnNXaXRoUG9zdHBhdGNoLnB1c2goZGlyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkaXJzV2l0aEluc2VydC5sZW5ndGgpIHtcbiAgICAgIHZhciBjYWxsSW5zZXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY2FsbEhvb2skMShkaXJzV2l0aEluc2VydFtpXSwgJ2luc2VydGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChpc0NyZWF0ZSkge1xuICAgICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ2luc2VydCcsIGNhbGxJbnNlcnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbEluc2VydCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGgpIHtcbiAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY2FsbEhvb2skMShkaXJzV2l0aFBvc3RwYXRjaFtpXSwgJ2NvbXBvbmVudFVwZGF0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIWlzQ3JlYXRlKSB7XG4gICAgICBmb3IgKGtleSBpbiBvbGREaXJzKSB7XG4gICAgICAgIGlmICghbmV3RGlyc1trZXldKSB7XG4gICAgICAgICAgLy8gbm8gbG9uZ2VyIHByZXNlbnQsIHVuYmluZFxuICAgICAgICAgIGNhbGxIb29rJDEob2xkRGlyc1trZXldLCAndW5iaW5kJywgb2xkVm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGVtcHR5TW9kaWZpZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBmdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzJDEgKFxuICAgIGRpcnMsXG4gICAgdm1cbiAgKSB7XG4gICAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgaWYgKCFkaXJzKSB7XG4gICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgIHJldHVybiByZXNcbiAgICB9XG4gICAgdmFyIGksIGRpcjtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZGlycy5sZW5ndGg7IGkrKykge1xuICAgICAgZGlyID0gZGlyc1tpXTtcbiAgICAgIGlmICghZGlyLm1vZGlmaWVycykge1xuICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgICAgZGlyLm1vZGlmaWVycyA9IGVtcHR5TW9kaWZpZXJzO1xuICAgICAgfVxuICAgICAgcmVzW2dldFJhd0Rpck5hbWUoZGlyKV0gPSBkaXI7XG4gICAgICBkaXIuZGVmID0gcmVzb2x2ZUFzc2V0KHZtLiRvcHRpb25zLCAnZGlyZWN0aXZlcycsIGRpci5uYW1lLCB0cnVlKTtcbiAgICB9XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UmF3RGlyTmFtZSAoZGlyKSB7XG4gICAgcmV0dXJuIGRpci5yYXdOYW1lIHx8ICgoZGlyLm5hbWUpICsgXCIuXCIgKyAoT2JqZWN0LmtleXMoZGlyLm1vZGlmaWVycyB8fCB7fSkuam9pbignLicpKSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGxIb29rJDEgKGRpciwgaG9vaywgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpIHtcbiAgICB2YXIgZm4gPSBkaXIuZGVmICYmIGRpci5kZWZbaG9va107XG4gICAgaWYgKGZuKSB7XG4gICAgICB0cnkge1xuICAgICAgICBmbih2bm9kZS5lbG0sIGRpciwgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCB2bm9kZS5jb250ZXh0LCAoXCJkaXJlY3RpdmUgXCIgKyAoZGlyLm5hbWUpICsgXCIgXCIgKyBob29rICsgXCIgaG9va1wiKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2VNb2R1bGVzID0gW1xuICAgIHJlZixcbiAgICBkaXJlY3RpdmVzXG4gIF07XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gdXBkYXRlQXR0cnMgKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIHZhciBvcHRzID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICBpZiAoaXNEZWYob3B0cykgJiYgb3B0cy5DdG9yLm9wdGlvbnMuaW5oZXJpdEF0dHJzID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEuYXR0cnMpICYmIGlzVW5kZWYodm5vZGUuZGF0YS5hdHRycykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIga2V5LCBjdXIsIG9sZDtcbiAgICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICAgIHZhciBvbGRBdHRycyA9IG9sZFZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gICAgdmFyIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgICBpZiAoaXNEZWYoYXR0cnMuX19vYl9fKSkge1xuICAgICAgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzID0gZXh0ZW5kKHt9LCBhdHRycyk7XG4gICAgfVxuXG4gICAgZm9yIChrZXkgaW4gYXR0cnMpIHtcbiAgICAgIGN1ciA9IGF0dHJzW2tleV07XG4gICAgICBvbGQgPSBvbGRBdHRyc1trZXldO1xuICAgICAgaWYgKG9sZCAhPT0gY3VyKSB7XG4gICAgICAgIHNldEF0dHIoZWxtLCBrZXksIGN1cik7XG4gICAgICB9XG4gICAgfVxuICAgIC8vICM0MzkxOiBpbiBJRTksIHNldHRpbmcgdHlwZSBjYW4gcmVzZXQgdmFsdWUgZm9yIGlucHV0W3R5cGU9cmFkaW9dXG4gICAgLy8gIzY2NjY6IElFL0VkZ2UgZm9yY2VzIHByb2dyZXNzIHZhbHVlIGRvd24gdG8gMSBiZWZvcmUgc2V0dGluZyBhIG1heFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICgoaXNJRSB8fCBpc0VkZ2UpICYmIGF0dHJzLnZhbHVlICE9PSBvbGRBdHRycy52YWx1ZSkge1xuICAgICAgc2V0QXR0cihlbG0sICd2YWx1ZScsIGF0dHJzLnZhbHVlKTtcbiAgICB9XG4gICAgZm9yIChrZXkgaW4gb2xkQXR0cnMpIHtcbiAgICAgIGlmIChpc1VuZGVmKGF0dHJzW2tleV0pKSB7XG4gICAgICAgIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xuICAgICAgICB9IGVsc2UgaWYgKCFpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcbiAgICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRBdHRyIChlbCwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChlbC50YWdOYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICBiYXNlU2V0QXR0cihlbCwga2V5LCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChpc0Jvb2xlYW5BdHRyKGtleSkpIHtcbiAgICAgIC8vIHNldCBhdHRyaWJ1dGUgZm9yIGJsYW5rIHZhbHVlXG4gICAgICAvLyBlLmcuIDxvcHRpb24gZGlzYWJsZWQ+U2VsZWN0IG9uZTwvb3B0aW9uPlxuICAgICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdGVjaG5pY2FsbHkgYWxsb3dmdWxsc2NyZWVuIGlzIGEgYm9vbGVhbiBhdHRyaWJ1dGUgZm9yIDxpZnJhbWU+LFxuICAgICAgICAvLyBidXQgRmxhc2ggZXhwZWN0cyBhIHZhbHVlIG9mIFwidHJ1ZVwiIHdoZW4gdXNlZCBvbiA8ZW1iZWQ+IHRhZ1xuICAgICAgICB2YWx1ZSA9IGtleSA9PT0gJ2FsbG93ZnVsbHNjcmVlbicgJiYgZWwudGFnTmFtZSA9PT0gJ0VNQkVEJ1xuICAgICAgICAgID8gJ3RydWUnXG4gICAgICAgICAgOiBrZXk7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgY29udmVydEVudW1lcmF0ZWRWYWx1ZShrZXksIHZhbHVlKSk7XG4gICAgfSBlbHNlIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGVOUyh4bGlua05TLCBrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYmFzZVNldEF0dHIoZWwsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGJhc2VTZXRBdHRyIChlbCwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vICM3MTM4OiBJRTEwICYgMTEgZmlyZXMgaW5wdXQgZXZlbnQgd2hlbiBzZXR0aW5nIHBsYWNlaG9sZGVyIG9uXG4gICAgICAvLyA8dGV4dGFyZWE+Li4uIGJsb2NrIHRoZSBmaXJzdCBpbnB1dCBldmVudCBhbmQgcmVtb3ZlIHRoZSBibG9ja2VyXG4gICAgICAvLyBpbW1lZGlhdGVseS5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKFxuICAgICAgICBpc0lFICYmICFpc0lFOSAmJlxuICAgICAgICBlbC50YWdOYW1lID09PSAnVEVYVEFSRUEnICYmXG4gICAgICAgIGtleSA9PT0gJ3BsYWNlaG9sZGVyJyAmJiB2YWx1ZSAhPT0gJycgJiYgIWVsLl9faWVwaFxuICAgICAgKSB7XG4gICAgICAgIHZhciBibG9ja2VyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgYmxvY2tlcik7XG4gICAgICAgIH07XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgYmxvY2tlcik7XG4gICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgICBlbC5fX2llcGggPSB0cnVlOyAvKiBJRSBwbGFjZWhvbGRlciBwYXRjaGVkICovXG4gICAgICB9XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGF0dHJzID0ge1xuICAgIGNyZWF0ZTogdXBkYXRlQXR0cnMsXG4gICAgdXBkYXRlOiB1cGRhdGVBdHRyc1xuICB9O1xuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNsYXNzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcbiAgICBpZiAoXG4gICAgICBpc1VuZGVmKGRhdGEuc3RhdGljQ2xhc3MpICYmXG4gICAgICBpc1VuZGVmKGRhdGEuY2xhc3MpICYmIChcbiAgICAgICAgaXNVbmRlZihvbGREYXRhKSB8fCAoXG4gICAgICAgICAgaXNVbmRlZihvbGREYXRhLnN0YXRpY0NsYXNzKSAmJlxuICAgICAgICAgIGlzVW5kZWYob2xkRGF0YS5jbGFzcylcbiAgICAgICAgKVxuICAgICAgKVxuICAgICkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGNscyA9IGdlbkNsYXNzRm9yVm5vZGUodm5vZGUpO1xuXG4gICAgLy8gaGFuZGxlIHRyYW5zaXRpb24gY2xhc3Nlc1xuICAgIHZhciB0cmFuc2l0aW9uQ2xhc3MgPSBlbC5fdHJhbnNpdGlvbkNsYXNzZXM7XG4gICAgaWYgKGlzRGVmKHRyYW5zaXRpb25DbGFzcykpIHtcbiAgICAgIGNscyA9IGNvbmNhdChjbHMsIHN0cmluZ2lmeUNsYXNzKHRyYW5zaXRpb25DbGFzcykpO1xuICAgIH1cblxuICAgIC8vIHNldCB0aGUgY2xhc3NcbiAgICBpZiAoY2xzICE9PSBlbC5fcHJldkNsYXNzKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2xzKTtcbiAgICAgIGVsLl9wcmV2Q2xhc3MgPSBjbHM7XG4gICAgfVxuICB9XG5cbiAgdmFyIGtsYXNzID0ge1xuICAgIGNyZWF0ZTogdXBkYXRlQ2xhc3MsXG4gICAgdXBkYXRlOiB1cGRhdGVDbGFzc1xuICB9O1xuXG4gIC8qICAqL1xuXG4gIHZhciB2YWxpZERpdmlzaW9uQ2hhclJFID0gL1tcXHcpLitcXC1fJFxcXV0vO1xuXG4gIGZ1bmN0aW9uIHBhcnNlRmlsdGVycyAoZXhwKSB7XG4gICAgdmFyIGluU2luZ2xlID0gZmFsc2U7XG4gICAgdmFyIGluRG91YmxlID0gZmFsc2U7XG4gICAgdmFyIGluVGVtcGxhdGVTdHJpbmcgPSBmYWxzZTtcbiAgICB2YXIgaW5SZWdleCA9IGZhbHNlO1xuICAgIHZhciBjdXJseSA9IDA7XG4gICAgdmFyIHNxdWFyZSA9IDA7XG4gICAgdmFyIHBhcmVuID0gMDtcbiAgICB2YXIgbGFzdEZpbHRlckluZGV4ID0gMDtcbiAgICB2YXIgYywgcHJldiwgaSwgZXhwcmVzc2lvbiwgZmlsdGVycztcblxuICAgIGZvciAoaSA9IDA7IGkgPCBleHAubGVuZ3RoOyBpKyspIHtcbiAgICAgIHByZXYgPSBjO1xuICAgICAgYyA9IGV4cC5jaGFyQ29kZUF0KGkpO1xuICAgICAgaWYgKGluU2luZ2xlKSB7XG4gICAgICAgIGlmIChjID09PSAweDI3ICYmIHByZXYgIT09IDB4NUMpIHsgaW5TaW5nbGUgPSBmYWxzZTsgfVxuICAgICAgfSBlbHNlIGlmIChpbkRvdWJsZSkge1xuICAgICAgICBpZiAoYyA9PT0gMHgyMiAmJiBwcmV2ICE9PSAweDVDKSB7IGluRG91YmxlID0gZmFsc2U7IH1cbiAgICAgIH0gZWxzZSBpZiAoaW5UZW1wbGF0ZVN0cmluZykge1xuICAgICAgICBpZiAoYyA9PT0gMHg2MCAmJiBwcmV2ICE9PSAweDVDKSB7IGluVGVtcGxhdGVTdHJpbmcgPSBmYWxzZTsgfVxuICAgICAgfSBlbHNlIGlmIChpblJlZ2V4KSB7XG4gICAgICAgIGlmIChjID09PSAweDJmICYmIHByZXYgIT09IDB4NUMpIHsgaW5SZWdleCA9IGZhbHNlOyB9XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBjID09PSAweDdDICYmIC8vIHBpcGVcbiAgICAgICAgZXhwLmNoYXJDb2RlQXQoaSArIDEpICE9PSAweDdDICYmXG4gICAgICAgIGV4cC5jaGFyQ29kZUF0KGkgLSAxKSAhPT0gMHg3QyAmJlxuICAgICAgICAhY3VybHkgJiYgIXNxdWFyZSAmJiAhcGFyZW5cbiAgICAgICkge1xuICAgICAgICBpZiAoZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gZmlyc3QgZmlsdGVyLCBlbmQgb2YgZXhwcmVzc2lvblxuICAgICAgICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICAgICAgICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHB1c2hGaWx0ZXIoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgICAgY2FzZSAweDIyOiBpbkRvdWJsZSA9IHRydWU7IGJyZWFrICAgICAgICAgLy8gXCJcbiAgICAgICAgICBjYXNlIDB4Mjc6IGluU2luZ2xlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyAnXG4gICAgICAgICAgY2FzZSAweDYwOiBpblRlbXBsYXRlU3RyaW5nID0gdHJ1ZTsgYnJlYWsgLy8gYFxuICAgICAgICAgIGNhc2UgMHgyODogcGFyZW4rKzsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIChcbiAgICAgICAgICBjYXNlIDB4Mjk6IHBhcmVuLS07IGJyZWFrICAgICAgICAgICAgICAgICAvLyApXG4gICAgICAgICAgY2FzZSAweDVCOiBzcXVhcmUrKzsgYnJlYWsgICAgICAgICAgICAgICAgLy8gW1xuICAgICAgICAgIGNhc2UgMHg1RDogc3F1YXJlLS07IGJyZWFrICAgICAgICAgICAgICAgIC8vIF1cbiAgICAgICAgICBjYXNlIDB4N0I6IGN1cmx5Kys7IGJyZWFrICAgICAgICAgICAgICAgICAvLyB7XG4gICAgICAgICAgY2FzZSAweDdEOiBjdXJseS0tOyBicmVhayAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjID09PSAweDJmKSB7IC8vIC9cbiAgICAgICAgICB2YXIgaiA9IGkgLSAxO1xuICAgICAgICAgIHZhciBwID0gKHZvaWQgMCk7XG4gICAgICAgICAgLy8gZmluZCBmaXJzdCBub24td2hpdGVzcGFjZSBwcmV2IGNoYXJcbiAgICAgICAgICBmb3IgKDsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgIHAgPSBleHAuY2hhckF0KGopO1xuICAgICAgICAgICAgaWYgKHAgIT09ICcgJykgeyBicmVhayB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcCB8fCAhdmFsaWREaXZpc2lvbkNoYXJSRS50ZXN0KHApKSB7XG4gICAgICAgICAgICBpblJlZ2V4ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgICB9IGVsc2UgaWYgKGxhc3RGaWx0ZXJJbmRleCAhPT0gMCkge1xuICAgICAgcHVzaEZpbHRlcigpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHB1c2hGaWx0ZXIgKCkge1xuICAgICAgKGZpbHRlcnMgfHwgKGZpbHRlcnMgPSBbXSkpLnB1c2goZXhwLnNsaWNlKGxhc3RGaWx0ZXJJbmRleCwgaSkudHJpbSgpKTtcbiAgICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICAgIH1cblxuICAgIGlmIChmaWx0ZXJzKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBleHByZXNzaW9uID0gd3JhcEZpbHRlcihleHByZXNzaW9uLCBmaWx0ZXJzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZXhwcmVzc2lvblxuICB9XG5cbiAgZnVuY3Rpb24gd3JhcEZpbHRlciAoZXhwLCBmaWx0ZXIpIHtcbiAgICB2YXIgaSA9IGZpbHRlci5pbmRleE9mKCcoJyk7XG4gICAgaWYgKGkgPCAwKSB7XG4gICAgICAvLyBfZjogcmVzb2x2ZUZpbHRlclxuICAgICAgcmV0dXJuIChcIl9mKFxcXCJcIiArIGZpbHRlciArIFwiXFxcIikoXCIgKyBleHAgKyBcIilcIilcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG5hbWUgPSBmaWx0ZXIuc2xpY2UoMCwgaSk7XG4gICAgICB2YXIgYXJncyA9IGZpbHRlci5zbGljZShpICsgMSk7XG4gICAgICByZXR1cm4gKFwiX2YoXFxcIlwiICsgbmFtZSArIFwiXFxcIikoXCIgKyBleHAgKyAoYXJncyAhPT0gJyknID8gJywnICsgYXJncyA6IGFyZ3MpKVxuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG5cblxuICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuICBmdW5jdGlvbiBiYXNlV2FybiAobXNnLCByYW5nZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoKFwiW1Z1ZSBjb21waWxlcl06IFwiICsgbXNnKSk7XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG4gIGZ1bmN0aW9uIHBsdWNrTW9kdWxlRnVuY3Rpb24gKFxuICAgIG1vZHVsZXMsXG4gICAga2V5XG4gICkge1xuICAgIHJldHVybiBtb2R1bGVzXG4gICAgICA/IG1vZHVsZXMubWFwKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtW2tleV07IH0pLmZpbHRlcihmdW5jdGlvbiAoXykgeyByZXR1cm4gXzsgfSlcbiAgICAgIDogW11cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFByb3AgKGVsLCBuYW1lLCB2YWx1ZSwgcmFuZ2UsIGR5bmFtaWMpIHtcbiAgICAoZWwucHJvcHMgfHwgKGVsLnByb3BzID0gW10pKS5wdXNoKHJhbmdlU2V0SXRlbSh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSwgZHluYW1pYzogZHluYW1pYyB9LCByYW5nZSkpO1xuICAgIGVsLnBsYWluID0gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRBdHRyIChlbCwgbmFtZSwgdmFsdWUsIHJhbmdlLCBkeW5hbWljKSB7XG4gICAgdmFyIGF0dHJzID0gZHluYW1pY1xuICAgICAgPyAoZWwuZHluYW1pY0F0dHJzIHx8IChlbC5keW5hbWljQXR0cnMgPSBbXSkpXG4gICAgICA6IChlbC5hdHRycyB8fCAoZWwuYXR0cnMgPSBbXSkpO1xuICAgIGF0dHJzLnB1c2gocmFuZ2VTZXRJdGVtKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlLCBkeW5hbWljOiBkeW5hbWljIH0sIHJhbmdlKSk7XG4gICAgZWwucGxhaW4gPSBmYWxzZTtcbiAgfVxuXG4gIC8vIGFkZCBhIHJhdyBhdHRyICh1c2UgdGhpcyBpbiBwcmVUcmFuc2Zvcm1zKVxuICBmdW5jdGlvbiBhZGRSYXdBdHRyIChlbCwgbmFtZSwgdmFsdWUsIHJhbmdlKSB7XG4gICAgZWwuYXR0cnNNYXBbbmFtZV0gPSB2YWx1ZTtcbiAgICBlbC5hdHRyc0xpc3QucHVzaChyYW5nZVNldEl0ZW0oeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSwgcmFuZ2UpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZERpcmVjdGl2ZSAoXG4gICAgZWwsXG4gICAgbmFtZSxcbiAgICByYXdOYW1lLFxuICAgIHZhbHVlLFxuICAgIGFyZyxcbiAgICBpc0R5bmFtaWNBcmcsXG4gICAgbW9kaWZpZXJzLFxuICAgIHJhbmdlXG4gICkge1xuICAgIChlbC5kaXJlY3RpdmVzIHx8IChlbC5kaXJlY3RpdmVzID0gW10pKS5wdXNoKHJhbmdlU2V0SXRlbSh7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgcmF3TmFtZTogcmF3TmFtZSxcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGFyZzogYXJnLFxuICAgICAgaXNEeW5hbWljQXJnOiBpc0R5bmFtaWNBcmcsXG4gICAgICBtb2RpZmllcnM6IG1vZGlmaWVyc1xuICAgIH0sIHJhbmdlKSk7XG4gICAgZWwucGxhaW4gPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByZXBlbmRNb2RpZmllck1hcmtlciAoc3ltYm9sLCBuYW1lLCBkeW5hbWljKSB7XG4gICAgcmV0dXJuIGR5bmFtaWNcbiAgICAgID8gKFwiX3AoXCIgKyBuYW1lICsgXCIsXFxcIlwiICsgc3ltYm9sICsgXCJcXFwiKVwiKVxuICAgICAgOiBzeW1ib2wgKyBuYW1lIC8vIG1hcmsgdGhlIGV2ZW50IGFzIGNhcHR1cmVkXG4gIH1cblxuICBmdW5jdGlvbiBhZGRIYW5kbGVyIChcbiAgICBlbCxcbiAgICBuYW1lLFxuICAgIHZhbHVlLFxuICAgIG1vZGlmaWVycyxcbiAgICBpbXBvcnRhbnQsXG4gICAgd2FybixcbiAgICByYW5nZSxcbiAgICBkeW5hbWljXG4gICkge1xuICAgIG1vZGlmaWVycyA9IG1vZGlmaWVycyB8fCBlbXB0eU9iamVjdDtcbiAgICAvLyB3YXJuIHByZXZlbnQgYW5kIHBhc3NpdmUgbW9kaWZpZXJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoXG4gICAgICB3YXJuICYmXG4gICAgICBtb2RpZmllcnMucHJldmVudCAmJiBtb2RpZmllcnMucGFzc2l2ZVxuICAgICkge1xuICAgICAgd2FybihcbiAgICAgICAgJ3Bhc3NpdmUgYW5kIHByZXZlbnQgY2FuXFwndCBiZSB1c2VkIHRvZ2V0aGVyLiAnICtcbiAgICAgICAgJ1Bhc3NpdmUgaGFuZGxlciBjYW5cXCd0IHByZXZlbnQgZGVmYXVsdCBldmVudC4nLFxuICAgICAgICByYW5nZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBub3JtYWxpemUgY2xpY2sucmlnaHQgYW5kIGNsaWNrLm1pZGRsZSBzaW5jZSB0aGV5IGRvbid0IGFjdHVhbGx5IGZpcmVcbiAgICAvLyB0aGlzIGlzIHRlY2huaWNhbGx5IGJyb3dzZXItc3BlY2lmaWMsIGJ1dCBhdCBsZWFzdCBmb3Igbm93IGJyb3dzZXJzIGFyZVxuICAgIC8vIHRoZSBvbmx5IHRhcmdldCBlbnZzIHRoYXQgaGF2ZSByaWdodC9taWRkbGUgY2xpY2tzLlxuICAgIGlmIChtb2RpZmllcnMucmlnaHQpIHtcbiAgICAgIGlmIChkeW5hbWljKSB7XG4gICAgICAgIG5hbWUgPSBcIihcIiArIG5hbWUgKyBcIik9PT0nY2xpY2snPydjb250ZXh0bWVudSc6KFwiICsgbmFtZSArIFwiKVwiO1xuICAgICAgfSBlbHNlIGlmIChuYW1lID09PSAnY2xpY2snKSB7XG4gICAgICAgIG5hbWUgPSAnY29udGV4dG1lbnUnO1xuICAgICAgICBkZWxldGUgbW9kaWZpZXJzLnJpZ2h0O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobW9kaWZpZXJzLm1pZGRsZSkge1xuICAgICAgaWYgKGR5bmFtaWMpIHtcbiAgICAgICAgbmFtZSA9IFwiKFwiICsgbmFtZSArIFwiKT09PSdjbGljayc/J21vdXNldXAnOihcIiArIG5hbWUgKyBcIilcIjtcbiAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2NsaWNrJykge1xuICAgICAgICBuYW1lID0gJ21vdXNldXAnO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNoZWNrIGNhcHR1cmUgbW9kaWZpZXJcbiAgICBpZiAobW9kaWZpZXJzLmNhcHR1cmUpIHtcbiAgICAgIGRlbGV0ZSBtb2RpZmllcnMuY2FwdHVyZTtcbiAgICAgIG5hbWUgPSBwcmVwZW5kTW9kaWZpZXJNYXJrZXIoJyEnLCBuYW1lLCBkeW5hbWljKTtcbiAgICB9XG4gICAgaWYgKG1vZGlmaWVycy5vbmNlKSB7XG4gICAgICBkZWxldGUgbW9kaWZpZXJzLm9uY2U7XG4gICAgICBuYW1lID0gcHJlcGVuZE1vZGlmaWVyTWFya2VyKCd+JywgbmFtZSwgZHluYW1pYyk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChtb2RpZmllcnMucGFzc2l2ZSkge1xuICAgICAgZGVsZXRlIG1vZGlmaWVycy5wYXNzaXZlO1xuICAgICAgbmFtZSA9IHByZXBlbmRNb2RpZmllck1hcmtlcignJicsIG5hbWUsIGR5bmFtaWMpO1xuICAgIH1cblxuICAgIHZhciBldmVudHM7XG4gICAgaWYgKG1vZGlmaWVycy5uYXRpdmUpIHtcbiAgICAgIGRlbGV0ZSBtb2RpZmllcnMubmF0aXZlO1xuICAgICAgZXZlbnRzID0gZWwubmF0aXZlRXZlbnRzIHx8IChlbC5uYXRpdmVFdmVudHMgPSB7fSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2ZW50cyA9IGVsLmV2ZW50cyB8fCAoZWwuZXZlbnRzID0ge30pO1xuICAgIH1cblxuICAgIHZhciBuZXdIYW5kbGVyID0gcmFuZ2VTZXRJdGVtKHsgdmFsdWU6IHZhbHVlLnRyaW0oKSwgZHluYW1pYzogZHluYW1pYyB9LCByYW5nZSk7XG4gICAgaWYgKG1vZGlmaWVycyAhPT0gZW1wdHlPYmplY3QpIHtcbiAgICAgIG5ld0hhbmRsZXIubW9kaWZpZXJzID0gbW9kaWZpZXJzO1xuICAgIH1cblxuICAgIHZhciBoYW5kbGVycyA9IGV2ZW50c1tuYW1lXTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVycykpIHtcbiAgICAgIGltcG9ydGFudCA/IGhhbmRsZXJzLnVuc2hpZnQobmV3SGFuZGxlcikgOiBoYW5kbGVycy5wdXNoKG5ld0hhbmRsZXIpO1xuICAgIH0gZWxzZSBpZiAoaGFuZGxlcnMpIHtcbiAgICAgIGV2ZW50c1tuYW1lXSA9IGltcG9ydGFudCA/IFtuZXdIYW5kbGVyLCBoYW5kbGVyc10gOiBbaGFuZGxlcnMsIG5ld0hhbmRsZXJdO1xuICAgIH0gZWxzZSB7XG4gICAgICBldmVudHNbbmFtZV0gPSBuZXdIYW5kbGVyO1xuICAgIH1cblxuICAgIGVsLnBsYWluID0gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRSYXdCaW5kaW5nQXR0ciAoXG4gICAgZWwsXG4gICAgbmFtZVxuICApIHtcbiAgICByZXR1cm4gZWwucmF3QXR0cnNNYXBbJzonICsgbmFtZV0gfHxcbiAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LWJpbmQ6JyArIG5hbWVdIHx8XG4gICAgICBlbC5yYXdBdHRyc01hcFtuYW1lXVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0QmluZGluZ0F0dHIgKFxuICAgIGVsLFxuICAgIG5hbWUsXG4gICAgZ2V0U3RhdGljXG4gICkge1xuICAgIHZhciBkeW5hbWljVmFsdWUgPVxuICAgICAgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJzonICsgbmFtZSkgfHxcbiAgICAgIGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWJpbmQ6JyArIG5hbWUpO1xuICAgIGlmIChkeW5hbWljVmFsdWUgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHBhcnNlRmlsdGVycyhkeW5hbWljVmFsdWUpXG4gICAgfSBlbHNlIGlmIChnZXRTdGF0aWMgIT09IGZhbHNlKSB7XG4gICAgICB2YXIgc3RhdGljVmFsdWUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCBuYW1lKTtcbiAgICAgIGlmIChzdGF0aWNWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzdGF0aWNWYWx1ZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBub3RlOiB0aGlzIG9ubHkgcmVtb3ZlcyB0aGUgYXR0ciBmcm9tIHRoZSBBcnJheSAoYXR0cnNMaXN0KSBzbyB0aGF0IGl0XG4gIC8vIGRvZXNuJ3QgZ2V0IHByb2Nlc3NlZCBieSBwcm9jZXNzQXR0cnMuXG4gIC8vIEJ5IGRlZmF1bHQgaXQgZG9lcyBOT1QgcmVtb3ZlIGl0IGZyb20gdGhlIG1hcCAoYXR0cnNNYXApIGJlY2F1c2UgdGhlIG1hcCBpc1xuICAvLyBuZWVkZWQgZHVyaW5nIGNvZGVnZW4uXG4gIGZ1bmN0aW9uIGdldEFuZFJlbW92ZUF0dHIgKFxuICAgIGVsLFxuICAgIG5hbWUsXG4gICAgcmVtb3ZlRnJvbU1hcFxuICApIHtcbiAgICB2YXIgdmFsO1xuICAgIGlmICgodmFsID0gZWwuYXR0cnNNYXBbbmFtZV0pICE9IG51bGwpIHtcbiAgICAgIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAobGlzdFtpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVtb3ZlRnJvbU1hcCkge1xuICAgICAgZGVsZXRlIGVsLmF0dHJzTWFwW25hbWVdO1xuICAgIH1cbiAgICByZXR1cm4gdmFsXG4gIH1cblxuICBmdW5jdGlvbiBnZXRBbmRSZW1vdmVBdHRyQnlSZWdleCAoXG4gICAgZWwsXG4gICAgbmFtZVxuICApIHtcbiAgICB2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYXR0ciA9IGxpc3RbaV07XG4gICAgICBpZiAobmFtZS50ZXN0KGF0dHIubmFtZSkpIHtcbiAgICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgIHJldHVybiBhdHRyXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmFuZ2VTZXRJdGVtIChcbiAgICBpdGVtLFxuICAgIHJhbmdlXG4gICkge1xuICAgIGlmIChyYW5nZSkge1xuICAgICAgaWYgKHJhbmdlLnN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgaXRlbS5zdGFydCA9IHJhbmdlLnN0YXJ0O1xuICAgICAgfVxuICAgICAgaWYgKHJhbmdlLmVuZCAhPSBudWxsKSB7XG4gICAgICAgIGl0ZW0uZW5kID0gcmFuZ2UuZW5kO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaXRlbVxuICB9XG5cbiAgLyogICovXG5cbiAgLyoqXG4gICAqIENyb3NzLXBsYXRmb3JtIGNvZGUgZ2VuZXJhdGlvbiBmb3IgY29tcG9uZW50IHYtbW9kZWxcbiAgICovXG4gIGZ1bmN0aW9uIGdlbkNvbXBvbmVudE1vZGVsIChcbiAgICBlbCxcbiAgICB2YWx1ZSxcbiAgICBtb2RpZmllcnNcbiAgKSB7XG4gICAgdmFyIHJlZiA9IG1vZGlmaWVycyB8fCB7fTtcbiAgICB2YXIgbnVtYmVyID0gcmVmLm51bWJlcjtcbiAgICB2YXIgdHJpbSA9IHJlZi50cmltO1xuXG4gICAgdmFyIGJhc2VWYWx1ZUV4cHJlc3Npb24gPSAnJCR2JztcbiAgICB2YXIgdmFsdWVFeHByZXNzaW9uID0gYmFzZVZhbHVlRXhwcmVzc2lvbjtcbiAgICBpZiAodHJpbSkge1xuICAgICAgdmFsdWVFeHByZXNzaW9uID1cbiAgICAgICAgXCIodHlwZW9mIFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiID09PSAnc3RyaW5nJ1wiICtcbiAgICAgICAgXCI/IFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiLnRyaW0oKVwiICtcbiAgICAgICAgXCI6IFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICAgIH1cbiAgICBpZiAobnVtYmVyKSB7XG4gICAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIl9uKFwiICsgdmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gICAgfVxuICAgIHZhciBhc3NpZ25tZW50ID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG5cbiAgICBlbC5tb2RlbCA9IHtcbiAgICAgIHZhbHVlOiAoXCIoXCIgKyB2YWx1ZSArIFwiKVwiKSxcbiAgICAgIGV4cHJlc3Npb246IEpTT04uc3RyaW5naWZ5KHZhbHVlKSxcbiAgICAgIGNhbGxiYWNrOiAoXCJmdW5jdGlvbiAoXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIpIHtcIiArIGFzc2lnbm1lbnQgKyBcIn1cIilcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENyb3NzLXBsYXRmb3JtIGNvZGVnZW4gaGVscGVyIGZvciBnZW5lcmF0aW5nIHYtbW9kZWwgdmFsdWUgYXNzaWdubWVudCBjb2RlLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2VuQXNzaWdubWVudENvZGUgKFxuICAgIHZhbHVlLFxuICAgIGFzc2lnbm1lbnRcbiAgKSB7XG4gICAgdmFyIHJlcyA9IHBhcnNlTW9kZWwodmFsdWUpO1xuICAgIGlmIChyZXMua2V5ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gKHZhbHVlICsgXCI9XCIgKyBhc3NpZ25tZW50KVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKFwiJHNldChcIiArIChyZXMuZXhwKSArIFwiLCBcIiArIChyZXMua2V5KSArIFwiLCBcIiArIGFzc2lnbm1lbnQgKyBcIilcIilcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgYSB2LW1vZGVsIGV4cHJlc3Npb24gaW50byBhIGJhc2UgcGF0aCBhbmQgYSBmaW5hbCBrZXkgc2VnbWVudC5cbiAgICogSGFuZGxlcyBib3RoIGRvdC1wYXRoIGFuZCBwb3NzaWJsZSBzcXVhcmUgYnJhY2tldHMuXG4gICAqXG4gICAqIFBvc3NpYmxlIGNhc2VzOlxuICAgKlxuICAgKiAtIHRlc3RcbiAgICogLSB0ZXN0W2tleV1cbiAgICogLSB0ZXN0W3Rlc3QxW2tleV1dXG4gICAqIC0gdGVzdFtcImFcIl1ba2V5XVxuICAgKiAtIHh4eC50ZXN0W2FbYV0udGVzdDFba2V5XV1cbiAgICogLSB0ZXN0Lnh4eC5hW1wiYXNhXCJdW3Rlc3QxW2tleV1dXG4gICAqXG4gICAqL1xuXG4gIHZhciBsZW4sIHN0ciwgY2hyLCBpbmRleCQxLCBleHByZXNzaW9uUG9zLCBleHByZXNzaW9uRW5kUG9zO1xuXG5cblxuICBmdW5jdGlvbiBwYXJzZU1vZGVsICh2YWwpIHtcbiAgICAvLyBGaXggaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS9wdWxsLzc3MzBcbiAgICAvLyBhbGxvdyB2LW1vZGVsPVwib2JqLnZhbCBcIiAodHJhaWxpbmcgd2hpdGVzcGFjZSlcbiAgICB2YWwgPSB2YWwudHJpbSgpO1xuICAgIGxlbiA9IHZhbC5sZW5ndGg7XG5cbiAgICBpZiAodmFsLmluZGV4T2YoJ1snKSA8IDAgfHwgdmFsLmxhc3RJbmRleE9mKCddJykgPCBsZW4gLSAxKSB7XG4gICAgICBpbmRleCQxID0gdmFsLmxhc3RJbmRleE9mKCcuJyk7XG4gICAgICBpZiAoaW5kZXgkMSA+IC0xKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZXhwOiB2YWwuc2xpY2UoMCwgaW5kZXgkMSksXG4gICAgICAgICAga2V5OiAnXCInICsgdmFsLnNsaWNlKGluZGV4JDEgKyAxKSArICdcIidcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBleHA6IHZhbCxcbiAgICAgICAgICBrZXk6IG51bGxcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHN0ciA9IHZhbDtcbiAgICBpbmRleCQxID0gZXhwcmVzc2lvblBvcyA9IGV4cHJlc3Npb25FbmRQb3MgPSAwO1xuXG4gICAgd2hpbGUgKCFlb2YoKSkge1xuICAgICAgY2hyID0gbmV4dCgpO1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXNTdHJpbmdTdGFydChjaHIpKSB7XG4gICAgICAgIHBhcnNlU3RyaW5nKGNocik7XG4gICAgICB9IGVsc2UgaWYgKGNociA9PT0gMHg1Qikge1xuICAgICAgICBwYXJzZUJyYWNrZXQoY2hyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZXhwOiB2YWwuc2xpY2UoMCwgZXhwcmVzc2lvblBvcyksXG4gICAgICBrZXk6IHZhbC5zbGljZShleHByZXNzaW9uUG9zICsgMSwgZXhwcmVzc2lvbkVuZFBvcylcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBuZXh0ICgpIHtcbiAgICByZXR1cm4gc3RyLmNoYXJDb2RlQXQoKytpbmRleCQxKVxuICB9XG5cbiAgZnVuY3Rpb24gZW9mICgpIHtcbiAgICByZXR1cm4gaW5kZXgkMSA+PSBsZW5cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3RyaW5nU3RhcnQgKGNocikge1xuICAgIHJldHVybiBjaHIgPT09IDB4MjIgfHwgY2hyID09PSAweDI3XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUJyYWNrZXQgKGNocikge1xuICAgIHZhciBpbkJyYWNrZXQgPSAxO1xuICAgIGV4cHJlc3Npb25Qb3MgPSBpbmRleCQxO1xuICAgIHdoaWxlICghZW9mKCkpIHtcbiAgICAgIGNociA9IG5leHQoKTtcbiAgICAgIGlmIChpc1N0cmluZ1N0YXJ0KGNocikpIHtcbiAgICAgICAgcGFyc2VTdHJpbmcoY2hyKTtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGlmIChjaHIgPT09IDB4NUIpIHsgaW5CcmFja2V0Kys7IH1cbiAgICAgIGlmIChjaHIgPT09IDB4NUQpIHsgaW5CcmFja2V0LS07IH1cbiAgICAgIGlmIChpbkJyYWNrZXQgPT09IDApIHtcbiAgICAgICAgZXhwcmVzc2lvbkVuZFBvcyA9IGluZGV4JDE7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VTdHJpbmcgKGNocikge1xuICAgIHZhciBzdHJpbmdRdW90ZSA9IGNocjtcbiAgICB3aGlsZSAoIWVvZigpKSB7XG4gICAgICBjaHIgPSBuZXh0KCk7XG4gICAgICBpZiAoY2hyID09PSBzdHJpbmdRdW90ZSkge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIHZhciB3YXJuJDE7XG5cbiAgLy8gaW4gc29tZSBjYXNlcywgdGhlIGV2ZW50IHVzZWQgaGFzIHRvIGJlIGRldGVybWluZWQgYXQgcnVudGltZVxuICAvLyBzbyB3ZSB1c2VkIHNvbWUgcmVzZXJ2ZWQgdG9rZW5zIGR1cmluZyBjb21waWxlLlxuICB2YXIgUkFOR0VfVE9LRU4gPSAnX19yJztcbiAgdmFyIENIRUNLQk9YX1JBRElPX1RPS0VOID0gJ19fYyc7XG5cbiAgZnVuY3Rpb24gbW9kZWwgKFxuICAgIGVsLFxuICAgIGRpcixcbiAgICBfd2FyblxuICApIHtcbiAgICB3YXJuJDEgPSBfd2FybjtcbiAgICB2YXIgdmFsdWUgPSBkaXIudmFsdWU7XG4gICAgdmFyIG1vZGlmaWVycyA9IGRpci5tb2RpZmllcnM7XG4gICAgdmFyIHRhZyA9IGVsLnRhZztcbiAgICB2YXIgdHlwZSA9IGVsLmF0dHJzTWFwLnR5cGU7XG5cbiAgICB7XG4gICAgICAvLyBpbnB1dHMgd2l0aCB0eXBlPVwiZmlsZVwiIGFyZSByZWFkIG9ubHkgYW5kIHNldHRpbmcgdGhlIGlucHV0J3NcbiAgICAgIC8vIHZhbHVlIHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gICAgICBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdmaWxlJykge1xuICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCIgdHlwZT1cXFwiZmlsZVxcXCI+OlxcblwiICtcbiAgICAgICAgICBcIkZpbGUgaW5wdXRzIGFyZSByZWFkIG9ubHkuIFVzZSBhIHYtb246Y2hhbmdlIGxpc3RlbmVyIGluc3RlYWQuXCIsXG4gICAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtbW9kZWwnXVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICAgIGdlbkNvbXBvbmVudE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICAgIC8vIGNvbXBvbmVudCB2LW1vZGVsIGRvZXNuJ3QgbmVlZCBleHRyYSBydW50aW1lXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9IGVsc2UgaWYgKHRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIGdlblNlbGVjdChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gICAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ2NoZWNrYm94Jykge1xuICAgICAgZ2VuQ2hlY2tib3hNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gICAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ3JhZGlvJykge1xuICAgICAgZ2VuUmFkaW9Nb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gICAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgfHwgdGFnID09PSAndGV4dGFyZWEnKSB7XG4gICAgICBnZW5EZWZhdWx0TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgIH0gZWxzZSBpZiAoIWNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICAgIGdlbkNvbXBvbmVudE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICAgIC8vIGNvbXBvbmVudCB2LW1vZGVsIGRvZXNuJ3QgbmVlZCBleHRyYSBydW50aW1lXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybiQxKFxuICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46IFwiICtcbiAgICAgICAgXCJ2LW1vZGVsIGlzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBlbGVtZW50IHR5cGUuIFwiICtcbiAgICAgICAgJ0lmIHlvdSBhcmUgd29ya2luZyB3aXRoIGNvbnRlbnRlZGl0YWJsZSwgaXRcXCdzIHJlY29tbWVuZGVkIHRvICcgK1xuICAgICAgICAnd3JhcCBhIGxpYnJhcnkgZGVkaWNhdGVkIGZvciB0aGF0IHB1cnBvc2UgaW5zaWRlIGEgY3VzdG9tIGNvbXBvbmVudC4nLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsndi1tb2RlbCddXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIGVuc3VyZSBydW50aW1lIGRpcmVjdGl2ZSBtZXRhZGF0YVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBmdW5jdGlvbiBnZW5DaGVja2JveE1vZGVsIChcbiAgICBlbCxcbiAgICB2YWx1ZSxcbiAgICBtb2RpZmllcnNcbiAgKSB7XG4gICAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICAgIHZhciB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xuICAgIHZhciB0cnVlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd0cnVlLXZhbHVlJykgfHwgJ3RydWUnO1xuICAgIHZhciBmYWxzZVZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnZmFsc2UtdmFsdWUnKSB8fCAnZmFsc2UnO1xuICAgIGFkZFByb3AoZWwsICdjaGVja2VkJyxcbiAgICAgIFwiQXJyYXkuaXNBcnJheShcIiArIHZhbHVlICsgXCIpXCIgK1xuICAgICAgXCI/X2koXCIgKyB2YWx1ZSArIFwiLFwiICsgdmFsdWVCaW5kaW5nICsgXCIpPi0xXCIgKyAoXG4gICAgICAgIHRydWVWYWx1ZUJpbmRpbmcgPT09ICd0cnVlJ1xuICAgICAgICAgID8gKFwiOihcIiArIHZhbHVlICsgXCIpXCIpXG4gICAgICAgICAgOiAoXCI6X3EoXCIgKyB2YWx1ZSArIFwiLFwiICsgdHJ1ZVZhbHVlQmluZGluZyArIFwiKVwiKVxuICAgICAgKVxuICAgICk7XG4gICAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsXG4gICAgICBcInZhciAkJGE9XCIgKyB2YWx1ZSArIFwiLFwiICtcbiAgICAgICAgICAnJCRlbD0kZXZlbnQudGFyZ2V0LCcgK1xuICAgICAgICAgIFwiJCRjPSQkZWwuY2hlY2tlZD8oXCIgKyB0cnVlVmFsdWVCaW5kaW5nICsgXCIpOihcIiArIGZhbHNlVmFsdWVCaW5kaW5nICsgXCIpO1wiICtcbiAgICAgICdpZihBcnJheS5pc0FycmF5KCQkYSkpeycgK1xuICAgICAgICBcInZhciAkJHY9XCIgKyAobnVtYmVyID8gJ19uKCcgKyB2YWx1ZUJpbmRpbmcgKyAnKScgOiB2YWx1ZUJpbmRpbmcpICsgXCIsXCIgK1xuICAgICAgICAgICAgJyQkaT1faSgkJGEsJCR2KTsnICtcbiAgICAgICAgXCJpZigkJGVsLmNoZWNrZWQpeyQkaTwwJiYoXCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsICckJGEuY29uY2F0KFskJHZdKScpKSArIFwiKX1cIiArXG4gICAgICAgIFwiZWxzZXskJGk+LTEmJihcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYS5zbGljZSgwLCQkaSkuY29uY2F0KCQkYS5zbGljZSgkJGkrMSkpJykpICsgXCIpfVwiICtcbiAgICAgIFwifWVsc2V7XCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsICckJGMnKSkgKyBcIn1cIixcbiAgICAgIG51bGwsIHRydWVcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VuUmFkaW9Nb2RlbCAoXG4gICAgZWwsXG4gICAgdmFsdWUsXG4gICAgbW9kaWZpZXJzXG4gICkge1xuICAgIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgICB2YXIgdmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd2YWx1ZScpIHx8ICdudWxsJztcbiAgICB2YWx1ZUJpbmRpbmcgPSBudW1iZXIgPyAoXCJfbihcIiArIHZhbHVlQmluZGluZyArIFwiKVwiKSA6IHZhbHVlQmluZGluZztcbiAgICBhZGRQcm9wKGVsLCAnY2hlY2tlZCcsIChcIl9xKFwiICsgdmFsdWUgKyBcIixcIiArIHZhbHVlQmluZGluZyArIFwiKVwiKSk7XG4gICAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsIGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUJpbmRpbmcpLCBudWxsLCB0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlblNlbGVjdCAoXG4gICAgZWwsXG4gICAgdmFsdWUsXG4gICAgbW9kaWZpZXJzXG4gICkge1xuICAgIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgICB2YXIgc2VsZWN0ZWRWYWwgPSBcIkFycmF5LnByb3RvdHlwZS5maWx0ZXJcIiArXG4gICAgICBcIi5jYWxsKCRldmVudC50YXJnZXQub3B0aW9ucyxmdW5jdGlvbihvKXtyZXR1cm4gby5zZWxlY3RlZH0pXCIgK1xuICAgICAgXCIubWFwKGZ1bmN0aW9uKG8pe3ZhciB2YWwgPSBcXFwiX3ZhbHVlXFxcIiBpbiBvID8gby5fdmFsdWUgOiBvLnZhbHVlO1wiICtcbiAgICAgIFwicmV0dXJuIFwiICsgKG51bWJlciA/ICdfbih2YWwpJyA6ICd2YWwnKSArIFwifSlcIjtcblxuICAgIHZhciBhc3NpZ25tZW50ID0gJyRldmVudC50YXJnZXQubXVsdGlwbGUgPyAkJHNlbGVjdGVkVmFsIDogJCRzZWxlY3RlZFZhbFswXSc7XG4gICAgdmFyIGNvZGUgPSBcInZhciAkJHNlbGVjdGVkVmFsID0gXCIgKyBzZWxlY3RlZFZhbCArIFwiO1wiO1xuICAgIGNvZGUgPSBjb2RlICsgXCIgXCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIGFzc2lnbm1lbnQpKTtcbiAgICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJywgY29kZSwgbnVsbCwgdHJ1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZW5EZWZhdWx0TW9kZWwgKFxuICAgIGVsLFxuICAgIHZhbHVlLFxuICAgIG1vZGlmaWVyc1xuICApIHtcbiAgICB2YXIgdHlwZSA9IGVsLmF0dHJzTWFwLnR5cGU7XG5cbiAgICAvLyB3YXJuIGlmIHYtYmluZDp2YWx1ZSBjb25mbGljdHMgd2l0aCB2LW1vZGVsXG4gICAgLy8gZXhjZXB0IGZvciBpbnB1dHMgd2l0aCB2LWJpbmQ6dHlwZVxuICAgIHtcbiAgICAgIHZhciB2YWx1ZSQxID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp2YWx1ZSddIHx8IGVsLmF0dHJzTWFwWyc6dmFsdWUnXTtcbiAgICAgIHZhciB0eXBlQmluZGluZyA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dHlwZSddIHx8IGVsLmF0dHJzTWFwWyc6dHlwZSddO1xuICAgICAgaWYgKHZhbHVlJDEgJiYgIXR5cGVCaW5kaW5nKSB7XG4gICAgICAgIHZhciBiaW5kaW5nID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp2YWx1ZSddID8gJ3YtYmluZDp2YWx1ZScgOiAnOnZhbHVlJztcbiAgICAgICAgd2FybiQxKFxuICAgICAgICAgIGJpbmRpbmcgKyBcIj1cXFwiXCIgKyB2YWx1ZSQxICsgXCJcXFwiIGNvbmZsaWN0cyB3aXRoIHYtbW9kZWwgb24gdGhlIHNhbWUgZWxlbWVudCBcIiArXG4gICAgICAgICAgJ2JlY2F1c2UgdGhlIGxhdHRlciBhbHJlYWR5IGV4cGFuZHMgdG8gYSB2YWx1ZSBiaW5kaW5nIGludGVybmFsbHknLFxuICAgICAgICAgIGVsLnJhd0F0dHJzTWFwW2JpbmRpbmddXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlZiA9IG1vZGlmaWVycyB8fCB7fTtcbiAgICB2YXIgbGF6eSA9IHJlZi5sYXp5O1xuICAgIHZhciBudW1iZXIgPSByZWYubnVtYmVyO1xuICAgIHZhciB0cmltID0gcmVmLnRyaW07XG4gICAgdmFyIG5lZWRDb21wb3NpdGlvbkd1YXJkID0gIWxhenkgJiYgdHlwZSAhPT0gJ3JhbmdlJztcbiAgICB2YXIgZXZlbnQgPSBsYXp5XG4gICAgICA/ICdjaGFuZ2UnXG4gICAgICA6IHR5cGUgPT09ICdyYW5nZSdcbiAgICAgICAgPyBSQU5HRV9UT0tFTlxuICAgICAgICA6ICdpbnB1dCc7XG5cbiAgICB2YXIgdmFsdWVFeHByZXNzaW9uID0gJyRldmVudC50YXJnZXQudmFsdWUnO1xuICAgIGlmICh0cmltKSB7XG4gICAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIiRldmVudC50YXJnZXQudmFsdWUudHJpbSgpXCI7XG4gICAgfVxuICAgIGlmIChudW1iZXIpIHtcbiAgICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiX24oXCIgKyB2YWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgICB9XG5cbiAgICB2YXIgY29kZSA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUV4cHJlc3Npb24pO1xuICAgIGlmIChuZWVkQ29tcG9zaXRpb25HdWFyZCkge1xuICAgICAgY29kZSA9IFwiaWYoJGV2ZW50LnRhcmdldC5jb21wb3NpbmcpcmV0dXJuO1wiICsgY29kZTtcbiAgICB9XG5cbiAgICBhZGRQcm9wKGVsLCAndmFsdWUnLCAoXCIoXCIgKyB2YWx1ZSArIFwiKVwiKSk7XG4gICAgYWRkSGFuZGxlcihlbCwgZXZlbnQsIGNvZGUsIG51bGwsIHRydWUpO1xuICAgIGlmICh0cmltIHx8IG51bWJlcikge1xuICAgICAgYWRkSGFuZGxlcihlbCwgJ2JsdXInLCAnJGZvcmNlVXBkYXRlKCknKTtcbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICAvLyBub3JtYWxpemUgdi1tb2RlbCBldmVudCB0b2tlbnMgdGhhdCBjYW4gb25seSBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWUuXG4gIC8vIGl0J3MgaW1wb3J0YW50IHRvIHBsYWNlIHRoZSBldmVudCBhcyB0aGUgZmlyc3QgaW4gdGhlIGFycmF5IGJlY2F1c2VcbiAgLy8gdGhlIHdob2xlIHBvaW50IGlzIGVuc3VyaW5nIHRoZSB2LW1vZGVsIGNhbGxiYWNrIGdldHMgY2FsbGVkIGJlZm9yZVxuICAvLyB1c2VyLWF0dGFjaGVkIGhhbmRsZXJzLlxuICBmdW5jdGlvbiBub3JtYWxpemVFdmVudHMgKG9uKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzRGVmKG9uW1JBTkdFX1RPS0VOXSkpIHtcbiAgICAgIC8vIElFIGlucHV0W3R5cGU9cmFuZ2VdIG9ubHkgc3VwcG9ydHMgYGNoYW5nZWAgZXZlbnRcbiAgICAgIHZhciBldmVudCA9IGlzSUUgPyAnY2hhbmdlJyA6ICdpbnB1dCc7XG4gICAgICBvbltldmVudF0gPSBbXS5jb25jYXQob25bUkFOR0VfVE9LRU5dLCBvbltldmVudF0gfHwgW10pO1xuICAgICAgZGVsZXRlIG9uW1JBTkdFX1RPS0VOXTtcbiAgICB9XG4gICAgLy8gVGhpcyB3YXMgb3JpZ2luYWxseSBpbnRlbmRlZCB0byBmaXggIzQ1MjEgYnV0IG5vIGxvbmdlciBuZWNlc3NhcnlcbiAgICAvLyBhZnRlciAyLjUuIEtlZXBpbmcgaXQgZm9yIGJhY2t3YXJkcyBjb21wYXQgd2l0aCBnZW5lcmF0ZWQgY29kZSBmcm9tIDwgMi40XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzRGVmKG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSkpIHtcbiAgICAgIG9uLmNoYW5nZSA9IFtdLmNvbmNhdChvbltDSEVDS0JPWF9SQURJT19UT0tFTl0sIG9uLmNoYW5nZSB8fCBbXSk7XG4gICAgICBkZWxldGUgb25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dO1xuICAgIH1cbiAgfVxuXG4gIHZhciB0YXJnZXQkMTtcblxuICBmdW5jdGlvbiBjcmVhdGVPbmNlSGFuZGxlciQxIChldmVudCwgaGFuZGxlciwgY2FwdHVyZSkge1xuICAgIHZhciBfdGFyZ2V0ID0gdGFyZ2V0JDE7IC8vIHNhdmUgY3VycmVudCB0YXJnZXQgZWxlbWVudCBpbiBjbG9zdXJlXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG9uY2VIYW5kbGVyICgpIHtcbiAgICAgIHZhciByZXMgPSBoYW5kbGVyLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAocmVzICE9PSBudWxsKSB7XG4gICAgICAgIHJlbW92ZSQyKGV2ZW50LCBvbmNlSGFuZGxlciwgY2FwdHVyZSwgX3RhcmdldCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gIzk0NDY6IEZpcmVmb3ggPD0gNTMgKGluIHBhcnRpY3VsYXIsIEVTUiA1MikgaGFzIGluY29ycmVjdCBFdmVudC50aW1lU3RhbXBcbiAgLy8gaW1wbGVtZW50YXRpb24gYW5kIGRvZXMgbm90IGZpcmUgbWljcm90YXNrcyBpbiBiZXR3ZWVuIGV2ZW50IHByb3BhZ2F0aW9uLCBzb1xuICAvLyBzYWZlIHRvIGV4Y2x1ZGUuXG4gIHZhciB1c2VNaWNyb3Rhc2tGaXggPSBpc1VzaW5nTWljcm9UYXNrICYmICEoaXNGRiAmJiBOdW1iZXIoaXNGRlsxXSkgPD0gNTMpO1xuXG4gIGZ1bmN0aW9uIGFkZCQxIChcbiAgICBuYW1lLFxuICAgIGhhbmRsZXIsXG4gICAgY2FwdHVyZSxcbiAgICBwYXNzaXZlXG4gICkge1xuICAgIC8vIGFzeW5jIGVkZ2UgY2FzZSAjNjU2NjogaW5uZXIgY2xpY2sgZXZlbnQgdHJpZ2dlcnMgcGF0Y2gsIGV2ZW50IGhhbmRsZXJcbiAgICAvLyBhdHRhY2hlZCB0byBvdXRlciBlbGVtZW50IGR1cmluZyBwYXRjaCwgYW5kIHRyaWdnZXJlZCBhZ2Fpbi4gVGhpc1xuICAgIC8vIGhhcHBlbnMgYmVjYXVzZSBicm93c2VycyBmaXJlIG1pY3JvdGFzayB0aWNrcyBiZXR3ZWVuIGV2ZW50IHByb3BhZ2F0aW9uLlxuICAgIC8vIHRoZSBzb2x1dGlvbiBpcyBzaW1wbGU6IHdlIHNhdmUgdGhlIHRpbWVzdGFtcCB3aGVuIGEgaGFuZGxlciBpcyBhdHRhY2hlZCxcbiAgICAvLyBhbmQgdGhlIGhhbmRsZXIgd291bGQgb25seSBmaXJlIGlmIHRoZSBldmVudCBwYXNzZWQgdG8gaXQgd2FzIGZpcmVkXG4gICAgLy8gQUZURVIgaXQgd2FzIGF0dGFjaGVkLlxuICAgIGlmICh1c2VNaWNyb3Rhc2tGaXgpIHtcbiAgICAgIHZhciBhdHRhY2hlZFRpbWVzdGFtcCA9IGN1cnJlbnRGbHVzaFRpbWVzdGFtcDtcbiAgICAgIHZhciBvcmlnaW5hbCA9IGhhbmRsZXI7XG4gICAgICBoYW5kbGVyID0gb3JpZ2luYWwuX3dyYXBwZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgLy8gbm8gYnViYmxpbmcsIHNob3VsZCBhbHdheXMgZmlyZS5cbiAgICAgICAgICAvLyB0aGlzIGlzIGp1c3QgYSBzYWZldHkgbmV0IGluIGNhc2UgZXZlbnQudGltZVN0YW1wIGlzIHVucmVsaWFibGUgaW5cbiAgICAgICAgICAvLyBjZXJ0YWluIHdlaXJkIGVudmlyb25tZW50cy4uLlxuICAgICAgICAgIGUudGFyZ2V0ID09PSBlLmN1cnJlbnRUYXJnZXQgfHxcbiAgICAgICAgICAvLyBldmVudCBpcyBmaXJlZCBhZnRlciBoYW5kbGVyIGF0dGFjaG1lbnRcbiAgICAgICAgICBlLnRpbWVTdGFtcCA+PSBhdHRhY2hlZFRpbWVzdGFtcCB8fFxuICAgICAgICAgIC8vIGJhaWwgZm9yIGVudmlyb25tZW50cyB0aGF0IGhhdmUgYnVnZ3kgZXZlbnQudGltZVN0YW1wIGltcGxlbWVudGF0aW9uc1xuICAgICAgICAgIC8vICM5NDYyIGlPUyA5IGJ1ZzogZXZlbnQudGltZVN0YW1wIGlzIDAgYWZ0ZXIgaGlzdG9yeS5wdXNoU3RhdGVcbiAgICAgICAgICAvLyAjOTY4MSBRdFdlYkVuZ2luZSBldmVudC50aW1lU3RhbXAgaXMgbmVnYXRpdmUgdmFsdWVcbiAgICAgICAgICBlLnRpbWVTdGFtcCA8PSAwIHx8XG4gICAgICAgICAgLy8gIzk0NDggYmFpbCBpZiBldmVudCBpcyBmaXJlZCBpbiBhbm90aGVyIGRvY3VtZW50IGluIGEgbXVsdGktcGFnZVxuICAgICAgICAgIC8vIGVsZWN0cm9uL253LmpzIGFwcCwgc2luY2UgZXZlbnQudGltZVN0YW1wIHdpbGwgYmUgdXNpbmcgYSBkaWZmZXJlbnRcbiAgICAgICAgICAvLyBzdGFydGluZyByZWZlcmVuY2VcbiAgICAgICAgICBlLnRhcmdldC5vd25lckRvY3VtZW50ICE9PSBkb2N1bWVudFxuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICB0YXJnZXQkMS5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgbmFtZSxcbiAgICAgIGhhbmRsZXIsXG4gICAgICBzdXBwb3J0c1Bhc3NpdmVcbiAgICAgICAgPyB7IGNhcHR1cmU6IGNhcHR1cmUsIHBhc3NpdmU6IHBhc3NpdmUgfVxuICAgICAgICA6IGNhcHR1cmVcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlJDIgKFxuICAgIG5hbWUsXG4gICAgaGFuZGxlcixcbiAgICBjYXB0dXJlLFxuICAgIF90YXJnZXRcbiAgKSB7XG4gICAgKF90YXJnZXQgfHwgdGFyZ2V0JDEpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICBuYW1lLFxuICAgICAgaGFuZGxlci5fd3JhcHBlciB8fCBoYW5kbGVyLFxuICAgICAgY2FwdHVyZVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVET01MaXN0ZW5lcnMgKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEub24pICYmIGlzVW5kZWYodm5vZGUuZGF0YS5vbikpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgb24gPSB2bm9kZS5kYXRhLm9uIHx8IHt9O1xuICAgIHZhciBvbGRPbiA9IG9sZFZub2RlLmRhdGEub24gfHwge307XG4gICAgdGFyZ2V0JDEgPSB2bm9kZS5lbG07XG4gICAgbm9ybWFsaXplRXZlbnRzKG9uKTtcbiAgICB1cGRhdGVMaXN0ZW5lcnMob24sIG9sZE9uLCBhZGQkMSwgcmVtb3ZlJDIsIGNyZWF0ZU9uY2VIYW5kbGVyJDEsIHZub2RlLmNvbnRleHQpO1xuICAgIHRhcmdldCQxID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgdmFyIGV2ZW50cyA9IHtcbiAgICBjcmVhdGU6IHVwZGF0ZURPTUxpc3RlbmVycyxcbiAgICB1cGRhdGU6IHVwZGF0ZURPTUxpc3RlbmVyc1xuICB9O1xuXG4gIC8qICAqL1xuXG4gIHZhciBzdmdDb250YWluZXI7XG5cbiAgZnVuY3Rpb24gdXBkYXRlRE9NUHJvcHMgKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEuZG9tUHJvcHMpICYmIGlzVW5kZWYodm5vZGUuZGF0YS5kb21Qcm9wcykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIga2V5LCBjdXI7XG4gICAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgICB2YXIgb2xkUHJvcHMgPSBvbGRWbm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICAgIHZhciBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gICAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gICAgaWYgKGlzRGVmKHByb3BzLl9fb2JfXykpIHtcbiAgICAgIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyA9IGV4dGVuZCh7fSwgcHJvcHMpO1xuICAgIH1cblxuICAgIGZvciAoa2V5IGluIG9sZFByb3BzKSB7XG4gICAgICBpZiAoIShrZXkgaW4gcHJvcHMpKSB7XG4gICAgICAgIGVsbVtrZXldID0gJyc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChrZXkgaW4gcHJvcHMpIHtcbiAgICAgIGN1ciA9IHByb3BzW2tleV07XG4gICAgICAvLyBpZ25vcmUgY2hpbGRyZW4gaWYgdGhlIG5vZGUgaGFzIHRleHRDb250ZW50IG9yIGlubmVySFRNTCxcbiAgICAgIC8vIGFzIHRoZXNlIHdpbGwgdGhyb3cgYXdheSBleGlzdGluZyBET00gbm9kZXMgYW5kIGNhdXNlIHJlbW92YWwgZXJyb3JzXG4gICAgICAvLyBvbiBzdWJzZXF1ZW50IHBhdGNoZXMgKCMzMzYwKVxuICAgICAgaWYgKGtleSA9PT0gJ3RleHRDb250ZW50JyB8fCBrZXkgPT09ICdpbm5lckhUTUwnKSB7XG4gICAgICAgIGlmICh2bm9kZS5jaGlsZHJlbikgeyB2bm9kZS5jaGlsZHJlbi5sZW5ndGggPSAwOyB9XG4gICAgICAgIGlmIChjdXIgPT09IG9sZFByb3BzW2tleV0pIHsgY29udGludWUgfVxuICAgICAgICAvLyAjNjYwMSB3b3JrIGFyb3VuZCBDaHJvbWUgdmVyc2lvbiA8PSA1NSBidWcgd2hlcmUgc2luZ2xlIHRleHROb2RlXG4gICAgICAgIC8vIHJlcGxhY2VkIGJ5IGlubmVySFRNTC90ZXh0Q29udGVudCByZXRhaW5zIGl0cyBwYXJlbnROb2RlIHByb3BlcnR5XG4gICAgICAgIGlmIChlbG0uY2hpbGROb2Rlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBlbG0ucmVtb3ZlQ2hpbGQoZWxtLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChrZXkgPT09ICd2YWx1ZScgJiYgZWxtLnRhZ05hbWUgIT09ICdQUk9HUkVTUycpIHtcbiAgICAgICAgLy8gc3RvcmUgdmFsdWUgYXMgX3ZhbHVlIGFzIHdlbGwgc2luY2VcbiAgICAgICAgLy8gbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZFxuICAgICAgICBlbG0uX3ZhbHVlID0gY3VyO1xuICAgICAgICAvLyBhdm9pZCByZXNldHRpbmcgY3Vyc29yIHBvc2l0aW9uIHdoZW4gdmFsdWUgaXMgdGhlIHNhbWVcbiAgICAgICAgdmFyIHN0ckN1ciA9IGlzVW5kZWYoY3VyKSA/ICcnIDogU3RyaW5nKGN1cik7XG4gICAgICAgIGlmIChzaG91bGRVcGRhdGVWYWx1ZShlbG0sIHN0ckN1cikpIHtcbiAgICAgICAgICBlbG0udmFsdWUgPSBzdHJDdXI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnaW5uZXJIVE1MJyAmJiBpc1NWRyhlbG0udGFnTmFtZSkgJiYgaXNVbmRlZihlbG0uaW5uZXJIVE1MKSkge1xuICAgICAgICAvLyBJRSBkb2Vzbid0IHN1cHBvcnQgaW5uZXJIVE1MIGZvciBTVkcgZWxlbWVudHNcbiAgICAgICAgc3ZnQ29udGFpbmVyID0gc3ZnQ29udGFpbmVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBzdmdDb250YWluZXIuaW5uZXJIVE1MID0gXCI8c3ZnPlwiICsgY3VyICsgXCI8L3N2Zz5cIjtcbiAgICAgICAgdmFyIHN2ZyA9IHN2Z0NvbnRhaW5lci5maXJzdENoaWxkO1xuICAgICAgICB3aGlsZSAoZWxtLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICBlbG0ucmVtb3ZlQ2hpbGQoZWxtLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChzdmcuZmlyc3RDaGlsZCkge1xuICAgICAgICAgIGVsbS5hcHBlbmRDaGlsZChzdmcuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIC8vIHNraXAgdGhlIHVwZGF0ZSBpZiBvbGQgYW5kIG5ldyBWRE9NIHN0YXRlIGlzIHRoZSBzYW1lLlxuICAgICAgICAvLyBgdmFsdWVgIGlzIGhhbmRsZWQgc2VwYXJhdGVseSBiZWNhdXNlIHRoZSBET00gdmFsdWUgbWF5IGJlIHRlbXBvcmFyaWx5XG4gICAgICAgIC8vIG91dCBvZiBzeW5jIHdpdGggVkRPTSBzdGF0ZSBkdWUgdG8gZm9jdXMsIGNvbXBvc2l0aW9uIGFuZCBtb2RpZmllcnMuXG4gICAgICAgIC8vIFRoaXMgICM0NTIxIGJ5IHNraXBwaW5nIHRoZSB1bm5lY2VzYXJyeSBgY2hlY2tlZGAgdXBkYXRlLlxuICAgICAgICBjdXIgIT09IG9sZFByb3BzW2tleV1cbiAgICAgICkge1xuICAgICAgICAvLyBzb21lIHByb3BlcnR5IHVwZGF0ZXMgY2FuIHRocm93XG4gICAgICAgIC8vIGUuZy4gYHZhbHVlYCBvbiA8cHJvZ3Jlc3M+IHcvIG5vbi1maW5pdGUgdmFsdWVcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBlbG1ba2V5XSA9IGN1cjtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBjaGVjayBwbGF0Zm9ybXMvd2ViL3V0aWwvYXR0cnMuanMgYWNjZXB0VmFsdWVcblxuXG4gIGZ1bmN0aW9uIHNob3VsZFVwZGF0ZVZhbHVlIChlbG0sIGNoZWNrVmFsKSB7XG4gICAgcmV0dXJuICghZWxtLmNvbXBvc2luZyAmJiAoXG4gICAgICBlbG0udGFnTmFtZSA9PT0gJ09QVElPTicgfHxcbiAgICAgIGlzTm90SW5Gb2N1c0FuZERpcnR5KGVsbSwgY2hlY2tWYWwpIHx8XG4gICAgICBpc0RpcnR5V2l0aE1vZGlmaWVycyhlbG0sIGNoZWNrVmFsKVxuICAgICkpXG4gIH1cblxuICBmdW5jdGlvbiBpc05vdEluRm9jdXNBbmREaXJ0eSAoZWxtLCBjaGVja1ZhbCkge1xuICAgIC8vIHJldHVybiB0cnVlIHdoZW4gdGV4dGJveCAoLm51bWJlciBhbmQgLnRyaW0pIGxvc2VzIGZvY3VzIGFuZCBpdHMgdmFsdWUgaXNcbiAgICAvLyBub3QgZXF1YWwgdG8gdGhlIHVwZGF0ZWQgdmFsdWVcbiAgICB2YXIgbm90SW5Gb2N1cyA9IHRydWU7XG4gICAgLy8gIzYxNTdcbiAgICAvLyB3b3JrIGFyb3VuZCBJRSBidWcgd2hlbiBhY2Nlc3NpbmcgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpbiBhbiBpZnJhbWVcbiAgICB0cnkgeyBub3RJbkZvY3VzID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gZWxtOyB9IGNhdGNoIChlKSB7fVxuICAgIHJldHVybiBub3RJbkZvY3VzICYmIGVsbS52YWx1ZSAhPT0gY2hlY2tWYWxcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRGlydHlXaXRoTW9kaWZpZXJzIChlbG0sIG5ld1ZhbCkge1xuICAgIHZhciB2YWx1ZSA9IGVsbS52YWx1ZTtcbiAgICB2YXIgbW9kaWZpZXJzID0gZWxtLl92TW9kaWZpZXJzOyAvLyBpbmplY3RlZCBieSB2LW1vZGVsIHJ1bnRpbWVcbiAgICBpZiAoaXNEZWYobW9kaWZpZXJzKSkge1xuICAgICAgaWYgKG1vZGlmaWVycy5udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHRvTnVtYmVyKHZhbHVlKSAhPT0gdG9OdW1iZXIobmV3VmFsKVxuICAgICAgfVxuICAgICAgaWYgKG1vZGlmaWVycy50cmltKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50cmltKCkgIT09IG5ld1ZhbC50cmltKClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlICE9PSBuZXdWYWxcbiAgfVxuXG4gIHZhciBkb21Qcm9wcyA9IHtcbiAgICBjcmVhdGU6IHVwZGF0ZURPTVByb3BzLFxuICAgIHVwZGF0ZTogdXBkYXRlRE9NUHJvcHNcbiAgfTtcblxuICAvKiAgKi9cblxuICB2YXIgcGFyc2VTdHlsZVRleHQgPSBjYWNoZWQoZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgICB2YXIgcmVzID0ge307XG4gICAgdmFyIGxpc3REZWxpbWl0ZXIgPSAvOyg/IVteKF0qXFwpKS9nO1xuICAgIHZhciBwcm9wZXJ0eURlbGltaXRlciA9IC86KC4rKS87XG4gICAgY3NzVGV4dC5zcGxpdChsaXN0RGVsaW1pdGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBpZiAoaXRlbSkge1xuICAgICAgICB2YXIgdG1wID0gaXRlbS5zcGxpdChwcm9wZXJ0eURlbGltaXRlcik7XG4gICAgICAgIHRtcC5sZW5ndGggPiAxICYmIChyZXNbdG1wWzBdLnRyaW0oKV0gPSB0bXBbMV0udHJpbSgpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzXG4gIH0pO1xuXG4gIC8vIG1lcmdlIHN0YXRpYyBhbmQgZHluYW1pYyBzdHlsZSBkYXRhIG9uIHRoZSBzYW1lIHZub2RlXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlRGF0YSAoZGF0YSkge1xuICAgIHZhciBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyhkYXRhLnN0eWxlKTtcbiAgICAvLyBzdGF0aWMgc3R5bGUgaXMgcHJlLXByb2Nlc3NlZCBpbnRvIGFuIG9iamVjdCBkdXJpbmcgY29tcGlsYXRpb25cbiAgICAvLyBhbmQgaXMgYWx3YXlzIGEgZnJlc2ggb2JqZWN0LCBzbyBpdCdzIHNhZmUgdG8gbWVyZ2UgaW50byBpdFxuICAgIHJldHVybiBkYXRhLnN0YXRpY1N0eWxlXG4gICAgICA/IGV4dGVuZChkYXRhLnN0YXRpY1N0eWxlLCBzdHlsZSlcbiAgICAgIDogc3R5bGVcbiAgfVxuXG4gIC8vIG5vcm1hbGl6ZSBwb3NzaWJsZSBhcnJheSAvIHN0cmluZyB2YWx1ZXMgaW50byBPYmplY3RcbiAgZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVCaW5kaW5nIChiaW5kaW5nU3R5bGUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShiaW5kaW5nU3R5bGUpKSB7XG4gICAgICByZXR1cm4gdG9PYmplY3QoYmluZGluZ1N0eWxlKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGJpbmRpbmdTdHlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBwYXJzZVN0eWxlVGV4dChiaW5kaW5nU3R5bGUpXG4gICAgfVxuICAgIHJldHVybiBiaW5kaW5nU3R5bGVcbiAgfVxuXG4gIC8qKlxuICAgKiBwYXJlbnQgY29tcG9uZW50IHN0eWxlIHNob3VsZCBiZSBhZnRlciBjaGlsZCdzXG4gICAqIHNvIHRoYXQgcGFyZW50IGNvbXBvbmVudCdzIHN0eWxlIGNvdWxkIG92ZXJyaWRlIGl0XG4gICAqL1xuICBmdW5jdGlvbiBnZXRTdHlsZSAodm5vZGUsIGNoZWNrQ2hpbGQpIHtcbiAgICB2YXIgcmVzID0ge307XG4gICAgdmFyIHN0eWxlRGF0YTtcblxuICAgIGlmIChjaGVja0NoaWxkKSB7XG4gICAgICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XG4gICAgICB3aGlsZSAoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBjaGlsZE5vZGUgJiYgY2hpbGROb2RlLmRhdGEgJiZcbiAgICAgICAgICAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKGNoaWxkTm9kZS5kYXRhKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICgoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHZub2RlLmRhdGEpKSkge1xuICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICB9XG5cbiAgICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xuICAgIHdoaWxlICgocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgICAgaWYgKHBhcmVudE5vZGUuZGF0YSAmJiAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHBhcmVudE5vZGUuZGF0YSkpKSB7XG4gICAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfVxuXG4gIC8qICAqL1xuXG4gIHZhciBjc3NWYXJSRSA9IC9eLS0vO1xuICB2YXIgaW1wb3J0YW50UkUgPSAvXFxzKiFpbXBvcnRhbnQkLztcbiAgdmFyIHNldFByb3AgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChjc3NWYXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwpO1xuICAgIH0gZWxzZSBpZiAoaW1wb3J0YW50UkUudGVzdCh2YWwpKSB7XG4gICAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShoeXBoZW5hdGUobmFtZSksIHZhbC5yZXBsYWNlKGltcG9ydGFudFJFLCAnJyksICdpbXBvcnRhbnQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG5vcm1hbGl6ZWROYW1lID0gbm9ybWFsaXplKG5hbWUpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICAvLyBTdXBwb3J0IHZhbHVlcyBhcnJheSBjcmVhdGVkIGJ5IGF1dG9wcmVmaXhlciwgZS5nLlxuICAgICAgICAvLyB7ZGlzcGxheTogW1wiLXdlYmtpdC1ib3hcIiwgXCItbXMtZmxleGJveFwiLCBcImZsZXhcIl19XG4gICAgICAgIC8vIFNldCB0aGVtIG9uZSBieSBvbmUsIGFuZCB0aGUgYnJvd3NlciB3aWxsIG9ubHkgc2V0IHRob3NlIGl0IGNhbiByZWNvZ25pemVcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbFtpXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwuc3R5bGVbbm9ybWFsaXplZE5hbWVdID0gdmFsO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgdmVuZG9yTmFtZXMgPSBbJ1dlYmtpdCcsICdNb3onLCAnbXMnXTtcblxuICB2YXIgZW1wdHlTdHlsZTtcbiAgdmFyIG5vcm1hbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAocHJvcCkge1xuICAgIGVtcHR5U3R5bGUgPSBlbXB0eVN0eWxlIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlO1xuICAgIHByb3AgPSBjYW1lbGl6ZShwcm9wKTtcbiAgICBpZiAocHJvcCAhPT0gJ2ZpbHRlcicgJiYgKHByb3AgaW4gZW1wdHlTdHlsZSkpIHtcbiAgICAgIHJldHVybiBwcm9wXG4gICAgfVxuICAgIHZhciBjYXBOYW1lID0gcHJvcC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3Auc2xpY2UoMSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZW5kb3JOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5hbWUgPSB2ZW5kb3JOYW1lc1tpXSArIGNhcE5hbWU7XG4gICAgICBpZiAobmFtZSBpbiBlbXB0eVN0eWxlKSB7XG4gICAgICAgIHJldHVybiBuYW1lXG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBmdW5jdGlvbiB1cGRhdGVTdHlsZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcblxuICAgIGlmIChpc1VuZGVmKGRhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYoZGF0YS5zdHlsZSkgJiZcbiAgICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNTdHlsZSkgJiYgaXNVbmRlZihvbGREYXRhLnN0eWxlKVxuICAgICkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGN1ciwgbmFtZTtcbiAgICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gICAgdmFyIG9sZFN0YXRpY1N0eWxlID0gb2xkRGF0YS5zdGF0aWNTdHlsZTtcbiAgICB2YXIgb2xkU3R5bGVCaW5kaW5nID0gb2xkRGF0YS5ub3JtYWxpemVkU3R5bGUgfHwgb2xkRGF0YS5zdHlsZSB8fCB7fTtcblxuICAgIC8vIGlmIHN0YXRpYyBzdHlsZSBleGlzdHMsIHN0eWxlYmluZGluZyBhbHJlYWR5IG1lcmdlZCBpbnRvIGl0IHdoZW4gZG9pbmcgbm9ybWFsaXplU3R5bGVEYXRhXG4gICAgdmFyIG9sZFN0eWxlID0gb2xkU3RhdGljU3R5bGUgfHwgb2xkU3R5bGVCaW5kaW5nO1xuXG4gICAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKHZub2RlLmRhdGEuc3R5bGUpIHx8IHt9O1xuXG4gICAgLy8gc3RvcmUgbm9ybWFsaXplZCBzdHlsZSB1bmRlciBhIGRpZmZlcmVudCBrZXkgZm9yIG5leHQgZGlmZlxuICAgIC8vIG1ha2Ugc3VyZSB0byBjbG9uZSBpdCBpZiBpdCdzIHJlYWN0aXZlLCBzaW5jZSB0aGUgdXNlciBsaWtlbHkgd2FudHNcbiAgICAvLyB0byBtdXRhdGUgaXQuXG4gICAgdm5vZGUuZGF0YS5ub3JtYWxpemVkU3R5bGUgPSBpc0RlZihzdHlsZS5fX29iX18pXG4gICAgICA/IGV4dGVuZCh7fSwgc3R5bGUpXG4gICAgICA6IHN0eWxlO1xuXG4gICAgdmFyIG5ld1N0eWxlID0gZ2V0U3R5bGUodm5vZGUsIHRydWUpO1xuXG4gICAgZm9yIChuYW1lIGluIG9sZFN0eWxlKSB7XG4gICAgICBpZiAoaXNVbmRlZihuZXdTdHlsZVtuYW1lXSkpIHtcbiAgICAgICAgc2V0UHJvcChlbCwgbmFtZSwgJycpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKG5hbWUgaW4gbmV3U3R5bGUpIHtcbiAgICAgIGN1ciA9IG5ld1N0eWxlW25hbWVdO1xuICAgICAgaWYgKGN1ciAhPT0gb2xkU3R5bGVbbmFtZV0pIHtcbiAgICAgICAgLy8gaWU5IHNldHRpbmcgdG8gbnVsbCBoYXMgbm8gZWZmZWN0LCBtdXN0IHVzZSBlbXB0eSBzdHJpbmdcbiAgICAgICAgc2V0UHJvcChlbCwgbmFtZSwgY3VyID09IG51bGwgPyAnJyA6IGN1cik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHN0eWxlID0ge1xuICAgIGNyZWF0ZTogdXBkYXRlU3R5bGUsXG4gICAgdXBkYXRlOiB1cGRhdGVTdHlsZVxuICB9O1xuXG4gIC8qICAqL1xuXG4gIHZhciB3aGl0ZXNwYWNlUkUgPSAvXFxzKy87XG5cbiAgLyoqXG4gICAqIEFkZCBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICAgKiBTVkcgZWxlbWVudHMgaW4gSUVcbiAgICovXG4gIGZ1bmN0aW9uIGFkZENsYXNzIChlbCwgY2xzKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICAgIGNscy5zcGxpdCh3aGl0ZXNwYWNlUkUpLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5hZGQoYyk7IH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbHMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY3VyID0gXCIgXCIgKyAoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArIFwiIFwiO1xuICAgICAgaWYgKGN1ci5pbmRleE9mKCcgJyArIGNscyArICcgJykgPCAwKSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoY3VyICsgY2xzKS50cmltKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAgICogU1ZHIGVsZW1lbnRzIGluIElFXG4gICAqL1xuICBmdW5jdGlvbiByZW1vdmVDbGFzcyAoZWwsIGNscykge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgICBjbHMuc3BsaXQod2hpdGVzcGFjZVJFKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBlbC5jbGFzc0xpc3QucmVtb3ZlKGMpOyB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTtcbiAgICAgIH1cbiAgICAgIGlmICghZWwuY2xhc3NMaXN0Lmxlbmd0aCkge1xuICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgICB2YXIgdGFyID0gJyAnICsgY2xzICsgJyAnO1xuICAgICAgd2hpbGUgKGN1ci5pbmRleE9mKHRhcikgPj0gMCkge1xuICAgICAgICBjdXIgPSBjdXIucmVwbGFjZSh0YXIsICcgJyk7XG4gICAgICB9XG4gICAgICBjdXIgPSBjdXIudHJpbSgpO1xuICAgICAgaWYgKGN1cikge1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY3VyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvbiAoZGVmJCQxKSB7XG4gICAgaWYgKCFkZWYkJDEpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICh0eXBlb2YgZGVmJCQxID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIHJlcyA9IHt9O1xuICAgICAgaWYgKGRlZiQkMS5jc3MgIT09IGZhbHNlKSB7XG4gICAgICAgIGV4dGVuZChyZXMsIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZiQkMS5uYW1lIHx8ICd2JykpO1xuICAgICAgfVxuICAgICAgZXh0ZW5kKHJlcywgZGVmJCQxKTtcbiAgICAgIHJldHVybiByZXNcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxKVxuICAgIH1cbiAgfVxuXG4gIHZhciBhdXRvQ3NzVHJhbnNpdGlvbiA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiB7XG4gICAgICBlbnRlckNsYXNzOiAobmFtZSArIFwiLWVudGVyXCIpLFxuICAgICAgZW50ZXJUb0NsYXNzOiAobmFtZSArIFwiLWVudGVyLXRvXCIpLFxuICAgICAgZW50ZXJBY3RpdmVDbGFzczogKG5hbWUgKyBcIi1lbnRlci1hY3RpdmVcIiksXG4gICAgICBsZWF2ZUNsYXNzOiAobmFtZSArIFwiLWxlYXZlXCIpLFxuICAgICAgbGVhdmVUb0NsYXNzOiAobmFtZSArIFwiLWxlYXZlLXRvXCIpLFxuICAgICAgbGVhdmVBY3RpdmVDbGFzczogKG5hbWUgKyBcIi1sZWF2ZS1hY3RpdmVcIilcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBoYXNUcmFuc2l0aW9uID0gaW5Ccm93c2VyICYmICFpc0lFOTtcbiAgdmFyIFRSQU5TSVRJT04gPSAndHJhbnNpdGlvbic7XG4gIHZhciBBTklNQVRJT04gPSAnYW5pbWF0aW9uJztcblxuICAvLyBUcmFuc2l0aW9uIHByb3BlcnR5L2V2ZW50IHNuaWZmaW5nXG4gIHZhciB0cmFuc2l0aW9uUHJvcCA9ICd0cmFuc2l0aW9uJztcbiAgdmFyIHRyYW5zaXRpb25FbmRFdmVudCA9ICd0cmFuc2l0aW9uZW5kJztcbiAgdmFyIGFuaW1hdGlvblByb3AgPSAnYW5pbWF0aW9uJztcbiAgdmFyIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ2FuaW1hdGlvbmVuZCc7XG4gIGlmIChoYXNUcmFuc2l0aW9uKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHdpbmRvdy5vbnRyYW5zaXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgd2luZG93Lm9ud2Via2l0dHJhbnNpdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG4gICAgKSB7XG4gICAgICB0cmFuc2l0aW9uUHJvcCA9ICdXZWJraXRUcmFuc2l0aW9uJztcbiAgICAgIHRyYW5zaXRpb25FbmRFdmVudCA9ICd3ZWJraXRUcmFuc2l0aW9uRW5kJztcbiAgICB9XG4gICAgaWYgKHdpbmRvdy5vbmFuaW1hdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgICB3aW5kb3cub253ZWJraXRhbmltYXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICAgICkge1xuICAgICAgYW5pbWF0aW9uUHJvcCA9ICdXZWJraXRBbmltYXRpb24nO1xuICAgICAgYW5pbWF0aW9uRW5kRXZlbnQgPSAnd2Via2l0QW5pbWF0aW9uRW5kJztcbiAgICB9XG4gIH1cblxuICAvLyBiaW5kaW5nIHRvIHdpbmRvdyBpcyBuZWNlc3NhcnkgdG8gbWFrZSBob3QgcmVsb2FkIHdvcmsgaW4gSUUgaW4gc3RyaWN0IG1vZGVcbiAgdmFyIHJhZiA9IGluQnJvd3NlclxuICAgID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KVxuICAgICAgOiBzZXRUaW1lb3V0XG4gICAgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH07XG5cbiAgZnVuY3Rpb24gbmV4dEZyYW1lIChmbikge1xuICAgIHJhZihmdW5jdGlvbiAoKSB7XG4gICAgICByYWYoZm4pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gICAgdmFyIHRyYW5zaXRpb25DbGFzc2VzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzIHx8IChlbC5fdHJhbnNpdGlvbkNsYXNzZXMgPSBbXSk7XG4gICAgaWYgKHRyYW5zaXRpb25DbGFzc2VzLmluZGV4T2YoY2xzKSA8IDApIHtcbiAgICAgIHRyYW5zaXRpb25DbGFzc2VzLnB1c2goY2xzKTtcbiAgICAgIGFkZENsYXNzKGVsLCBjbHMpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZVRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICAgIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICAgIHJlbW92ZShlbC5fdHJhbnNpdGlvbkNsYXNzZXMsIGNscyk7XG4gICAgfVxuICAgIHJlbW92ZUNsYXNzKGVsLCBjbHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzIChcbiAgICBlbCxcbiAgICBleHBlY3RlZFR5cGUsXG4gICAgY2JcbiAgKSB7XG4gICAgdmFyIHJlZiA9IGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpO1xuICAgIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gICAgdmFyIHRpbWVvdXQgPSByZWYudGltZW91dDtcbiAgICB2YXIgcHJvcENvdW50ID0gcmVmLnByb3BDb3VudDtcbiAgICBpZiAoIXR5cGUpIHsgcmV0dXJuIGNiKCkgfVxuICAgIHZhciBldmVudCA9IHR5cGUgPT09IFRSQU5TSVRJT04gPyB0cmFuc2l0aW9uRW5kRXZlbnQgOiBhbmltYXRpb25FbmRFdmVudDtcbiAgICB2YXIgZW5kZWQgPSAwO1xuICAgIHZhciBlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XG4gICAgICBjYigpO1xuICAgIH07XG4gICAgdmFyIG9uRW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChlLnRhcmdldCA9PT0gZWwpIHtcbiAgICAgICAgaWYgKCsrZW5kZWQgPj0gcHJvcENvdW50KSB7XG4gICAgICAgICAgZW5kKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XG4gICAgICAgIGVuZCgpO1xuICAgICAgfVxuICAgIH0sIHRpbWVvdXQgKyAxKTtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XG4gIH1cblxuICB2YXIgdHJhbnNmb3JtUkUgPSAvXFxiKHRyYW5zZm9ybXxhbGwpKCx8JCkvO1xuXG4gIGZ1bmN0aW9uIGdldFRyYW5zaXRpb25JbmZvIChlbCwgZXhwZWN0ZWRUeXBlKSB7XG4gICAgdmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgICAvLyBKU0RPTSBtYXkgcmV0dXJuIHVuZGVmaW5lZCBmb3IgdHJhbnNpdGlvbiBwcm9wZXJ0aWVzXG4gICAgdmFyIHRyYW5zaXRpb25EZWxheXMgPSAoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0RlbGF5J10gfHwgJycpLnNwbGl0KCcsICcpO1xuICAgIHZhciB0cmFuc2l0aW9uRHVyYXRpb25zID0gKHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEdXJhdGlvbiddIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgICB2YXIgdHJhbnNpdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KHRyYW5zaXRpb25EZWxheXMsIHRyYW5zaXRpb25EdXJhdGlvbnMpO1xuICAgIHZhciBhbmltYXRpb25EZWxheXMgPSAoc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRGVsYXknXSB8fCAnJykuc3BsaXQoJywgJyk7XG4gICAgdmFyIGFuaW1hdGlvbkR1cmF0aW9ucyA9IChzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEdXJhdGlvbiddIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgICB2YXIgYW5pbWF0aW9uVGltZW91dCA9IGdldFRpbWVvdXQoYW5pbWF0aW9uRGVsYXlzLCBhbmltYXRpb25EdXJhdGlvbnMpO1xuXG4gICAgdmFyIHR5cGU7XG4gICAgdmFyIHRpbWVvdXQgPSAwO1xuICAgIHZhciBwcm9wQ291bnQgPSAwO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChleHBlY3RlZFR5cGUgPT09IFRSQU5TSVRJT04pIHtcbiAgICAgIGlmICh0cmFuc2l0aW9uVGltZW91dCA+IDApIHtcbiAgICAgICAgdHlwZSA9IFRSQU5TSVRJT047XG4gICAgICAgIHRpbWVvdXQgPSB0cmFuc2l0aW9uVGltZW91dDtcbiAgICAgICAgcHJvcENvdW50ID0gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IEFOSU1BVElPTikge1xuICAgICAgaWYgKGFuaW1hdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICAgIHR5cGUgPSBBTklNQVRJT047XG4gICAgICAgIHRpbWVvdXQgPSBhbmltYXRpb25UaW1lb3V0O1xuICAgICAgICBwcm9wQ291bnQgPSBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xuICAgICAgdHlwZSA9IHRpbWVvdXQgPiAwXG4gICAgICAgID8gdHJhbnNpdGlvblRpbWVvdXQgPiBhbmltYXRpb25UaW1lb3V0XG4gICAgICAgICAgPyBUUkFOU0lUSU9OXG4gICAgICAgICAgOiBBTklNQVRJT05cbiAgICAgICAgOiBudWxsO1xuICAgICAgcHJvcENvdW50ID0gdHlwZVxuICAgICAgICA/IHR5cGUgPT09IFRSQU5TSVRJT05cbiAgICAgICAgICA/IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICAgICAgOiBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICAgIDogMDtcbiAgICB9XG4gICAgdmFyIGhhc1RyYW5zZm9ybSA9XG4gICAgICB0eXBlID09PSBUUkFOU0lUSU9OICYmXG4gICAgICB0cmFuc2Zvcm1SRS50ZXN0KHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdQcm9wZXJ0eSddKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG4gICAgICBwcm9wQ291bnQ6IHByb3BDb3VudCxcbiAgICAgIGhhc1RyYW5zZm9ybTogaGFzVHJhbnNmb3JtXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VGltZW91dCAoZGVsYXlzLCBkdXJhdGlvbnMpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHdoaWxlIChkZWxheXMubGVuZ3RoIDwgZHVyYXRpb25zLmxlbmd0aCkge1xuICAgICAgZGVsYXlzID0gZGVsYXlzLmNvbmNhdChkZWxheXMpO1xuICAgIH1cblxuICAgIHJldHVybiBNYXRoLm1heC5hcHBseShudWxsLCBkdXJhdGlvbnMubWFwKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICByZXR1cm4gdG9NcyhkKSArIHRvTXMoZGVsYXlzW2ldKVxuICAgIH0pKVxuICB9XG5cbiAgLy8gT2xkIHZlcnNpb25zIG9mIENocm9taXVtIChiZWxvdyA2MS4wLjMxNjMuMTAwKSBmb3JtYXRzIGZsb2F0aW5nIHBvaW50ZXIgbnVtYmVyc1xuICAvLyBpbiBhIGxvY2FsZS1kZXBlbmRlbnQgd2F5LCB1c2luZyBhIGNvbW1hIGluc3RlYWQgb2YgYSBkb3QuXG4gIC8vIElmIGNvbW1hIGlzIG5vdCByZXBsYWNlZCB3aXRoIGEgZG90LCB0aGUgaW5wdXQgd2lsbCBiZSByb3VuZGVkIGRvd24gKGkuZS4gYWN0aW5nXG4gIC8vIGFzIGEgZmxvb3IgZnVuY3Rpb24pIGNhdXNpbmcgdW5leHBlY3RlZCBiZWhhdmlvcnNcbiAgZnVuY3Rpb24gdG9NcyAocykge1xuICAgIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkucmVwbGFjZSgnLCcsICcuJykpICogMTAwMFxuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gZW50ZXIgKHZub2RlLCB0b2dnbGVEaXNwbGF5KSB7XG4gICAgdmFyIGVsID0gdm5vZGUuZWxtO1xuXG4gICAgLy8gY2FsbCBsZWF2ZSBjYWxsYmFjayBub3dcbiAgICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XG4gICAgICBlbC5fbGVhdmVDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgZWwuX2xlYXZlQ2IoKTtcbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gICAgaWYgKGlzVW5kZWYoZGF0YSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc0RlZihlbC5fZW50ZXJDYikgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBjc3MgPSBkYXRhLmNzcztcbiAgICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgICB2YXIgZW50ZXJDbGFzcyA9IGRhdGEuZW50ZXJDbGFzcztcbiAgICB2YXIgZW50ZXJUb0NsYXNzID0gZGF0YS5lbnRlclRvQ2xhc3M7XG4gICAgdmFyIGVudGVyQWN0aXZlQ2xhc3MgPSBkYXRhLmVudGVyQWN0aXZlQ2xhc3M7XG4gICAgdmFyIGFwcGVhckNsYXNzID0gZGF0YS5hcHBlYXJDbGFzcztcbiAgICB2YXIgYXBwZWFyVG9DbGFzcyA9IGRhdGEuYXBwZWFyVG9DbGFzcztcbiAgICB2YXIgYXBwZWFyQWN0aXZlQ2xhc3MgPSBkYXRhLmFwcGVhckFjdGl2ZUNsYXNzO1xuICAgIHZhciBiZWZvcmVFbnRlciA9IGRhdGEuYmVmb3JlRW50ZXI7XG4gICAgdmFyIGVudGVyID0gZGF0YS5lbnRlcjtcbiAgICB2YXIgYWZ0ZXJFbnRlciA9IGRhdGEuYWZ0ZXJFbnRlcjtcbiAgICB2YXIgZW50ZXJDYW5jZWxsZWQgPSBkYXRhLmVudGVyQ2FuY2VsbGVkO1xuICAgIHZhciBiZWZvcmVBcHBlYXIgPSBkYXRhLmJlZm9yZUFwcGVhcjtcbiAgICB2YXIgYXBwZWFyID0gZGF0YS5hcHBlYXI7XG4gICAgdmFyIGFmdGVyQXBwZWFyID0gZGF0YS5hZnRlckFwcGVhcjtcbiAgICB2YXIgYXBwZWFyQ2FuY2VsbGVkID0gZGF0YS5hcHBlYXJDYW5jZWxsZWQ7XG4gICAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcblxuICAgIC8vIGFjdGl2ZUluc3RhbmNlIHdpbGwgYWx3YXlzIGJlIHRoZSA8dHJhbnNpdGlvbj4gY29tcG9uZW50IG1hbmFnaW5nIHRoaXNcbiAgICAvLyB0cmFuc2l0aW9uLiBPbmUgZWRnZSBjYXNlIHRvIGNoZWNrIGlzIHdoZW4gdGhlIDx0cmFuc2l0aW9uPiBpcyBwbGFjZWRcbiAgICAvLyBhcyB0aGUgcm9vdCBub2RlIG9mIGEgY2hpbGQgY29tcG9uZW50LiBJbiB0aGF0IGNhc2Ugd2UgbmVlZCB0byBjaGVja1xuICAgIC8vIDx0cmFuc2l0aW9uPidzIHBhcmVudCBmb3IgYXBwZWFyIGNoZWNrLlxuICAgIHZhciBjb250ZXh0ID0gYWN0aXZlSW5zdGFuY2U7XG4gICAgdmFyIHRyYW5zaXRpb25Ob2RlID0gYWN0aXZlSW5zdGFuY2UuJHZub2RlO1xuICAgIHdoaWxlICh0cmFuc2l0aW9uTm9kZSAmJiB0cmFuc2l0aW9uTm9kZS5wYXJlbnQpIHtcbiAgICAgIGNvbnRleHQgPSB0cmFuc2l0aW9uTm9kZS5jb250ZXh0O1xuICAgICAgdHJhbnNpdGlvbk5vZGUgPSB0cmFuc2l0aW9uTm9kZS5wYXJlbnQ7XG4gICAgfVxuXG4gICAgdmFyIGlzQXBwZWFyID0gIWNvbnRleHQuX2lzTW91bnRlZCB8fCAhdm5vZGUuaXNSb290SW5zZXJ0O1xuXG4gICAgaWYgKGlzQXBwZWFyICYmICFhcHBlYXIgJiYgYXBwZWFyICE9PSAnJykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIHN0YXJ0Q2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJDbGFzc1xuICAgICAgPyBhcHBlYXJDbGFzc1xuICAgICAgOiBlbnRlckNsYXNzO1xuICAgIHZhciBhY3RpdmVDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckFjdGl2ZUNsYXNzXG4gICAgICA/IGFwcGVhckFjdGl2ZUNsYXNzXG4gICAgICA6IGVudGVyQWN0aXZlQ2xhc3M7XG4gICAgdmFyIHRvQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJUb0NsYXNzXG4gICAgICA/IGFwcGVhclRvQ2xhc3NcbiAgICAgIDogZW50ZXJUb0NsYXNzO1xuXG4gICAgdmFyIGJlZm9yZUVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgICA/IChiZWZvcmVBcHBlYXIgfHwgYmVmb3JlRW50ZXIpXG4gICAgICA6IGJlZm9yZUVudGVyO1xuICAgIHZhciBlbnRlckhvb2sgPSBpc0FwcGVhclxuICAgICAgPyAodHlwZW9mIGFwcGVhciA9PT0gJ2Z1bmN0aW9uJyA/IGFwcGVhciA6IGVudGVyKVxuICAgICAgOiBlbnRlcjtcbiAgICB2YXIgYWZ0ZXJFbnRlckhvb2sgPSBpc0FwcGVhclxuICAgICAgPyAoYWZ0ZXJBcHBlYXIgfHwgYWZ0ZXJFbnRlcilcbiAgICAgIDogYWZ0ZXJFbnRlcjtcbiAgICB2YXIgZW50ZXJDYW5jZWxsZWRIb29rID0gaXNBcHBlYXJcbiAgICAgID8gKGFwcGVhckNhbmNlbGxlZCB8fCBlbnRlckNhbmNlbGxlZClcbiAgICAgIDogZW50ZXJDYW5jZWxsZWQ7XG5cbiAgICB2YXIgZXhwbGljaXRFbnRlckR1cmF0aW9uID0gdG9OdW1iZXIoXG4gICAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgICAgPyBkdXJhdGlvbi5lbnRlclxuICAgICAgICA6IGR1cmF0aW9uXG4gICAgKTtcblxuICAgIGlmIChleHBsaWNpdEVudGVyRHVyYXRpb24gIT0gbnVsbCkge1xuICAgICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24sICdlbnRlcicsIHZub2RlKTtcbiAgICB9XG5cbiAgICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICAgIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChlbnRlckhvb2spO1xuXG4gICAgdmFyIGNiID0gZWwuX2VudGVyQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgICAgfVxuICAgICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICAgIH1cbiAgICAgICAgZW50ZXJDYW5jZWxsZWRIb29rICYmIGVudGVyQ2FuY2VsbGVkSG9vayhlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZnRlckVudGVySG9vayAmJiBhZnRlckVudGVySG9vayhlbCk7XG4gICAgICB9XG4gICAgICBlbC5fZW50ZXJDYiA9IG51bGw7XG4gICAgfSk7XG5cbiAgICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgICAgLy8gcmVtb3ZlIHBlbmRpbmcgbGVhdmUgZWxlbWVudCBvbiBlbnRlciBieSBpbmplY3RpbmcgYW4gaW5zZXJ0IGhvb2tcbiAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAnaW5zZXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcbiAgICAgICAgdmFyIHBlbmRpbmdOb2RlID0gcGFyZW50ICYmIHBhcmVudC5fcGVuZGluZyAmJiBwYXJlbnQuX3BlbmRpbmdbdm5vZGUua2V5XTtcbiAgICAgICAgaWYgKHBlbmRpbmdOb2RlICYmXG4gICAgICAgICAgcGVuZGluZ05vZGUudGFnID09PSB2bm9kZS50YWcgJiZcbiAgICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2JcbiAgICAgICAgKSB7XG4gICAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiKCk7XG4gICAgICAgIH1cbiAgICAgICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gc3RhcnQgZW50ZXIgdHJhbnNpdGlvblxuICAgIGJlZm9yZUVudGVySG9vayAmJiBiZWZvcmVFbnRlckhvb2soZWwpO1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgICBpZiAoIWNiLmNhbmNlbGxlZCkge1xuICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICAgICAgaWYgKCF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbikpIHtcbiAgICAgICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRFbnRlckR1cmF0aW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHZub2RlLmRhdGEuc2hvdykge1xuICAgICAgdG9nZ2xlRGlzcGxheSAmJiB0b2dnbGVEaXNwbGF5KCk7XG4gICAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gICAgfVxuXG4gICAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICBjYigpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGxlYXZlICh2bm9kZSwgcm0pIHtcbiAgICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgICAvLyBjYWxsIGVudGVyIGNhbGxiYWNrIG5vd1xuICAgIGlmIChpc0RlZihlbC5fZW50ZXJDYikpIHtcbiAgICAgIGVsLl9lbnRlckNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICBlbC5fZW50ZXJDYigpO1xuICAgIH1cblxuICAgIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgICBpZiAoaXNVbmRlZihkYXRhKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgICAgcmV0dXJuIHJtKClcbiAgICB9XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gICAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG4gICAgdmFyIGxlYXZlQ2xhc3MgPSBkYXRhLmxlYXZlQ2xhc3M7XG4gICAgdmFyIGxlYXZlVG9DbGFzcyA9IGRhdGEubGVhdmVUb0NsYXNzO1xuICAgIHZhciBsZWF2ZUFjdGl2ZUNsYXNzID0gZGF0YS5sZWF2ZUFjdGl2ZUNsYXNzO1xuICAgIHZhciBiZWZvcmVMZWF2ZSA9IGRhdGEuYmVmb3JlTGVhdmU7XG4gICAgdmFyIGxlYXZlID0gZGF0YS5sZWF2ZTtcbiAgICB2YXIgYWZ0ZXJMZWF2ZSA9IGRhdGEuYWZ0ZXJMZWF2ZTtcbiAgICB2YXIgbGVhdmVDYW5jZWxsZWQgPSBkYXRhLmxlYXZlQ2FuY2VsbGVkO1xuICAgIHZhciBkZWxheUxlYXZlID0gZGF0YS5kZWxheUxlYXZlO1xuICAgIHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG5cbiAgICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICAgIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChsZWF2ZSk7XG5cbiAgICB2YXIgZXhwbGljaXRMZWF2ZUR1cmF0aW9uID0gdG9OdW1iZXIoXG4gICAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgICAgPyBkdXJhdGlvbi5sZWF2ZVxuICAgICAgICA6IGR1cmF0aW9uXG4gICAgKTtcblxuICAgIGlmIChpc0RlZihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbiwgJ2xlYXZlJywgdm5vZGUpO1xuICAgIH1cblxuICAgIHZhciBjYiA9IGVsLl9sZWF2ZUNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlLl9wZW5kaW5nKSB7XG4gICAgICAgIGVsLnBhcmVudE5vZGUuX3BlbmRpbmdbdm5vZGUua2V5XSA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgICB9XG4gICAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgICAgfVxuICAgICAgICBsZWF2ZUNhbmNlbGxlZCAmJiBsZWF2ZUNhbmNlbGxlZChlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBybSgpO1xuICAgICAgICBhZnRlckxlYXZlICYmIGFmdGVyTGVhdmUoZWwpO1xuICAgICAgfVxuICAgICAgZWwuX2xlYXZlQ2IgPSBudWxsO1xuICAgIH0pO1xuXG4gICAgaWYgKGRlbGF5TGVhdmUpIHtcbiAgICAgIGRlbGF5TGVhdmUocGVyZm9ybUxlYXZlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGVyZm9ybUxlYXZlKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVyZm9ybUxlYXZlICgpIHtcbiAgICAgIC8vIHRoZSBkZWxheWVkIGxlYXZlIG1heSBoYXZlIGFscmVhZHkgYmVlbiBjYW5jZWxsZWRcbiAgICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvLyByZWNvcmQgbGVhdmluZyBlbGVtZW50XG4gICAgICBpZiAoIXZub2RlLmRhdGEuc2hvdyAmJiBlbC5wYXJlbnROb2RlKSB7XG4gICAgICAgIChlbC5wYXJlbnROb2RlLl9wZW5kaW5nIHx8IChlbC5wYXJlbnROb2RlLl9wZW5kaW5nID0ge30pKVsodm5vZGUua2V5KV0gPSB2bm9kZTtcbiAgICAgIH1cbiAgICAgIGJlZm9yZUxlYXZlICYmIGJlZm9yZUxlYXZlKGVsKTtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgICAgICBpZiAoIWNiLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgICAgICAgaWYgKCF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uKSkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0TGVhdmVEdXJhdGlvbik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgbGVhdmUgJiYgbGVhdmUoZWwsIGNiKTtcbiAgICAgIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICBjYigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG9ubHkgdXNlZCBpbiBkZXYgbW9kZVxuICBmdW5jdGlvbiBjaGVja0R1cmF0aW9uICh2YWwsIG5hbWUsIHZub2RlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWwgIT09ICdudW1iZXInKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBub3QgYSB2YWxpZCBudW1iZXIgLSBcIiArXG4gICAgICAgIFwiZ290IFwiICsgKEpTT04uc3RyaW5naWZ5KHZhbCkpICsgXCIuXCIsXG4gICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChpc05hTih2YWwpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBOYU4gLSBcIiArXG4gICAgICAgICd0aGUgZHVyYXRpb24gZXhwcmVzc2lvbiBtaWdodCBiZSBpbmNvcnJlY3QuJyxcbiAgICAgICAgdm5vZGUuY29udGV4dFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1ZhbGlkRHVyYXRpb24gKHZhbCkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsKVxuICB9XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZSBhIHRyYW5zaXRpb24gaG9vaydzIGFyZ3VtZW50IGxlbmd0aC4gVGhlIGhvb2sgbWF5IGJlOlxuICAgKiAtIGEgbWVyZ2VkIGhvb2sgKGludm9rZXIpIHdpdGggdGhlIG9yaWdpbmFsIGluIC5mbnNcbiAgICogLSBhIHdyYXBwZWQgY29tcG9uZW50IG1ldGhvZCAoY2hlY2sgLl9sZW5ndGgpXG4gICAqIC0gYSBwbGFpbiBmdW5jdGlvbiAoLmxlbmd0aClcbiAgICovXG4gIGZ1bmN0aW9uIGdldEhvb2tBcmd1bWVudHNMZW5ndGggKGZuKSB7XG4gICAgaWYgKGlzVW5kZWYoZm4pKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgdmFyIGludm9rZXJGbnMgPSBmbi5mbnM7XG4gICAgaWYgKGlzRGVmKGludm9rZXJGbnMpKSB7XG4gICAgICAvLyBpbnZva2VyXG4gICAgICByZXR1cm4gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChcbiAgICAgICAgQXJyYXkuaXNBcnJheShpbnZva2VyRm5zKVxuICAgICAgICAgID8gaW52b2tlckZuc1swXVxuICAgICAgICAgIDogaW52b2tlckZuc1xuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKGZuLl9sZW5ndGggfHwgZm4ubGVuZ3RoKSA+IDFcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfZW50ZXIgKF8sIHZub2RlKSB7XG4gICAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgICAgZW50ZXIodm5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciB0cmFuc2l0aW9uID0gaW5Ccm93c2VyID8ge1xuICAgIGNyZWF0ZTogX2VudGVyLFxuICAgIGFjdGl2YXRlOiBfZW50ZXIsXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUkJDEgKHZub2RlLCBybSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmICh2bm9kZS5kYXRhLnNob3cgIT09IHRydWUpIHtcbiAgICAgICAgbGVhdmUodm5vZGUsIHJtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJtKCk7XG4gICAgICB9XG4gICAgfVxuICB9IDoge307XG5cbiAgdmFyIHBsYXRmb3JtTW9kdWxlcyA9IFtcbiAgICBhdHRycyxcbiAgICBrbGFzcyxcbiAgICBldmVudHMsXG4gICAgZG9tUHJvcHMsXG4gICAgc3R5bGUsXG4gICAgdHJhbnNpdGlvblxuICBdO1xuXG4gIC8qICAqL1xuXG4gIC8vIHRoZSBkaXJlY3RpdmUgbW9kdWxlIHNob3VsZCBiZSBhcHBsaWVkIGxhc3QsIGFmdGVyIGFsbFxuICAvLyBidWlsdC1pbiBtb2R1bGVzIGhhdmUgYmVlbiBhcHBsaWVkLlxuICB2YXIgbW9kdWxlcyA9IHBsYXRmb3JtTW9kdWxlcy5jb25jYXQoYmFzZU1vZHVsZXMpO1xuXG4gIHZhciBwYXRjaCA9IGNyZWF0ZVBhdGNoRnVuY3Rpb24oeyBub2RlT3BzOiBub2RlT3BzLCBtb2R1bGVzOiBtb2R1bGVzIH0pO1xuXG4gIC8qKlxuICAgKiBOb3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgbGlrZSBhdHRhY2hpbmdcbiAgICogcHJvcGVydGllcyB0byBFbGVtZW50cy5cbiAgICovXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0lFOSkge1xuICAgIC8vIGh0dHA6Ly93d3cubWF0dHM0MTEuY29tL3Bvc3QvaW50ZXJuZXQtZXhwbG9yZXItOS1vbmlucHV0L1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBlbCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICBpZiAoZWwgJiYgZWwudm1vZGVsKSB7XG4gICAgICAgIHRyaWdnZXIoZWwsICdpbnB1dCcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdmFyIGRpcmVjdGl2ZSA9IHtcbiAgICBpbnNlcnRlZDogZnVuY3Rpb24gaW5zZXJ0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSwgb2xkVm5vZGUpIHtcbiAgICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICAgIC8vICM2OTAzXG4gICAgICAgIGlmIChvbGRWbm9kZS5lbG0gJiYgIW9sZFZub2RlLmVsbS5fdk9wdGlvbnMpIHtcbiAgICAgICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ3Bvc3RwYXRjaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGRpcmVjdGl2ZS5jb21wb25lbnRVcGRhdGVkKGVsLCBiaW5kaW5nLCB2bm9kZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsLl92T3B0aW9ucyA9IFtdLm1hcC5jYWxsKGVsLm9wdGlvbnMsIGdldFZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAodm5vZGUudGFnID09PSAndGV4dGFyZWEnIHx8IGlzVGV4dElucHV0VHlwZShlbC50eXBlKSkge1xuICAgICAgICBlbC5fdk1vZGlmaWVycyA9IGJpbmRpbmcubW9kaWZpZXJzO1xuICAgICAgICBpZiAoIWJpbmRpbmcubW9kaWZpZXJzLmxhenkpIHtcbiAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbnN0YXJ0Jywgb25Db21wb3NpdGlvblN0YXJ0KTtcbiAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbmVuZCcsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICAgIC8vIFNhZmFyaSA8IDEwLjIgJiBVSVdlYlZpZXcgZG9lc24ndCBmaXJlIGNvbXBvc2l0aW9uZW5kIHdoZW5cbiAgICAgICAgICAvLyBzd2l0Y2hpbmcgZm9jdXMgYmVmb3JlIGNvbmZpcm1pbmcgY29tcG9zaXRpb24gY2hvaWNlXG4gICAgICAgICAgLy8gdGhpcyBhbHNvIGZpeGVzIHRoZSBpc3N1ZSB3aGVyZSBzb21lIGJyb3dzZXJzIGUuZy4gaU9TIENocm9tZVxuICAgICAgICAgIC8vIGZpcmVzIFwiY2hhbmdlXCIgaW5zdGVhZCBvZiBcImlucHV0XCIgb24gYXV0b2NvbXBsZXRlLlxuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmIChpc0lFOSkge1xuICAgICAgICAgICAgZWwudm1vZGVsID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY29tcG9uZW50VXBkYXRlZDogZnVuY3Rpb24gY29tcG9uZW50VXBkYXRlZCAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICAgIC8vIGluIGNhc2UgdGhlIG9wdGlvbnMgcmVuZGVyZWQgYnkgdi1mb3IgaGF2ZSBjaGFuZ2VkLFxuICAgICAgICAvLyBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHZhbHVlIGlzIG91dC1vZi1zeW5jIHdpdGggdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG4gICAgICAgIC8vIGRldGVjdCBzdWNoIGNhc2VzIGFuZCBmaWx0ZXIgb3V0IHZhbHVlcyB0aGF0IG5vIGxvbmdlciBoYXMgYSBtYXRjaGluZ1xuICAgICAgICAvLyBvcHRpb24gaW4gdGhlIERPTS5cbiAgICAgICAgdmFyIHByZXZPcHRpb25zID0gZWwuX3ZPcHRpb25zO1xuICAgICAgICB2YXIgY3VyT3B0aW9ucyA9IGVsLl92T3B0aW9ucyA9IFtdLm1hcC5jYWxsKGVsLm9wdGlvbnMsIGdldFZhbHVlKTtcbiAgICAgICAgaWYgKGN1ck9wdGlvbnMuc29tZShmdW5jdGlvbiAobywgaSkgeyByZXR1cm4gIWxvb3NlRXF1YWwobywgcHJldk9wdGlvbnNbaV0pOyB9KSkge1xuICAgICAgICAgIC8vIHRyaWdnZXIgY2hhbmdlIGV2ZW50IGlmXG4gICAgICAgICAgLy8gbm8gbWF0Y2hpbmcgb3B0aW9uIGZvdW5kIGZvciBhdCBsZWFzdCBvbmUgdmFsdWVcbiAgICAgICAgICB2YXIgbmVlZFJlc2V0ID0gZWwubXVsdGlwbGVcbiAgICAgICAgICAgID8gYmluZGluZy52YWx1ZS5zb21lKGZ1bmN0aW9uICh2KSB7IHJldHVybiBoYXNOb01hdGNoaW5nT3B0aW9uKHYsIGN1ck9wdGlvbnMpOyB9KVxuICAgICAgICAgICAgOiBiaW5kaW5nLnZhbHVlICE9PSBiaW5kaW5nLm9sZFZhbHVlICYmIGhhc05vTWF0Y2hpbmdPcHRpb24oYmluZGluZy52YWx1ZSwgY3VyT3B0aW9ucyk7XG4gICAgICAgICAgaWYgKG5lZWRSZXNldCkge1xuICAgICAgICAgICAgdHJpZ2dlcihlbCwgJ2NoYW5nZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBzZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gICAgYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc0lFIHx8IGlzRWRnZSkge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGFjdHVhbGx5U2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZtKTtcbiAgICAgIH0sIDApO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFjdHVhbGx5U2V0U2VsZWN0ZWQgKGVsLCBiaW5kaW5nLCB2bSkge1xuICAgIHZhciB2YWx1ZSA9IGJpbmRpbmcudmFsdWU7XG4gICAgdmFyIGlzTXVsdGlwbGUgPSBlbC5tdWx0aXBsZTtcbiAgICBpZiAoaXNNdWx0aXBsZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiPHNlbGVjdCBtdWx0aXBsZSB2LW1vZGVsPVxcXCJcIiArIChiaW5kaW5nLmV4cHJlc3Npb24pICsgXCJcXFwiPiBcIiArXG4gICAgICAgIFwiZXhwZWN0cyBhbiBBcnJheSB2YWx1ZSBmb3IgaXRzIGJpbmRpbmcsIGJ1dCBnb3QgXCIgKyAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSkpLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgc2VsZWN0ZWQsIG9wdGlvbjtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGVsLm9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBvcHRpb24gPSBlbC5vcHRpb25zW2ldO1xuICAgICAgaWYgKGlzTXVsdGlwbGUpIHtcbiAgICAgICAgc2VsZWN0ZWQgPSBsb29zZUluZGV4T2YodmFsdWUsIGdldFZhbHVlKG9wdGlvbikpID4gLTE7XG4gICAgICAgIGlmIChvcHRpb24uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbiksIHZhbHVlKSkge1xuICAgICAgICAgIGlmIChlbC5zZWxlY3RlZEluZGV4ICE9PSBpKSB7XG4gICAgICAgICAgICBlbC5zZWxlY3RlZEluZGV4ID0gaTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpc011bHRpcGxlKSB7XG4gICAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFzTm9NYXRjaGluZ09wdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5ldmVyeShmdW5jdGlvbiAobykgeyByZXR1cm4gIWxvb3NlRXF1YWwobywgdmFsdWUpOyB9KVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VmFsdWUgKG9wdGlvbikge1xuICAgIHJldHVybiAnX3ZhbHVlJyBpbiBvcHRpb25cbiAgICAgID8gb3B0aW9uLl92YWx1ZVxuICAgICAgOiBvcHRpb24udmFsdWVcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ29tcG9zaXRpb25TdGFydCAoZSkge1xuICAgIGUudGFyZ2V0LmNvbXBvc2luZyA9IHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBvbkNvbXBvc2l0aW9uRW5kIChlKSB7XG4gICAgLy8gcHJldmVudCB0cmlnZ2VyaW5nIGFuIGlucHV0IGV2ZW50IGZvciBubyByZWFzb25cbiAgICBpZiAoIWUudGFyZ2V0LmNvbXBvc2luZykgeyByZXR1cm4gfVxuICAgIGUudGFyZ2V0LmNvbXBvc2luZyA9IGZhbHNlO1xuICAgIHRyaWdnZXIoZS50YXJnZXQsICdpbnB1dCcpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJpZ2dlciAoZWwsIHR5cGUpIHtcbiAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XG4gICAgZS5pbml0RXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgZWwuZGlzcGF0Y2hFdmVudChlKTtcbiAgfVxuXG4gIC8qICAqL1xuXG4gIC8vIHJlY3Vyc2l2ZWx5IHNlYXJjaCBmb3IgcG9zc2libGUgdHJhbnNpdGlvbiBkZWZpbmVkIGluc2lkZSB0aGUgY29tcG9uZW50IHJvb3RcbiAgZnVuY3Rpb24gbG9jYXRlTm9kZSAodm5vZGUpIHtcbiAgICByZXR1cm4gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgJiYgKCF2bm9kZS5kYXRhIHx8ICF2bm9kZS5kYXRhLnRyYW5zaXRpb24pXG4gICAgICA/IGxvY2F0ZU5vZGUodm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlKVxuICAgICAgOiB2bm9kZVxuICB9XG5cbiAgdmFyIHNob3cgPSB7XG4gICAgYmluZDogZnVuY3Rpb24gYmluZCAoZWwsIHJlZiwgdm5vZGUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcblxuICAgICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICAgIHZhciB0cmFuc2l0aW9uJCQxID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgICB2YXIgb3JpZ2luYWxEaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5ID1cbiAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnID8gJycgOiBlbC5zdHlsZS5kaXNwbGF5O1xuICAgICAgaWYgKHZhbHVlICYmIHRyYW5zaXRpb24kJDEpIHtcbiAgICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gb3JpZ2luYWxEaXNwbGF5O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IG9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKGVsLCByZWYsIHZub2RlKSB7XG4gICAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG4gICAgICB2YXIgb2xkVmFsdWUgPSByZWYub2xkVmFsdWU7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCF2YWx1ZSA9PT0gIW9sZFZhbHVlKSB7IHJldHVybiB9XG4gICAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgICAgdmFyIHRyYW5zaXRpb24kJDEgPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICAgIGlmICh0cmFuc2l0aW9uJCQxKSB7XG4gICAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIGVudGVyKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxlYXZlKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kIChcbiAgICAgIGVsLFxuICAgICAgYmluZGluZyxcbiAgICAgIHZub2RlLFxuICAgICAgb2xkVm5vZGUsXG4gICAgICBpc0Rlc3Ryb3lcbiAgICApIHtcbiAgICAgIGlmICghaXNEZXN0cm95KSB7XG4gICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBwbGF0Zm9ybURpcmVjdGl2ZXMgPSB7XG4gICAgbW9kZWw6IGRpcmVjdGl2ZSxcbiAgICBzaG93OiBzaG93XG4gIH07XG5cbiAgLyogICovXG5cbiAgdmFyIHRyYW5zaXRpb25Qcm9wcyA9IHtcbiAgICBuYW1lOiBTdHJpbmcsXG4gICAgYXBwZWFyOiBCb29sZWFuLFxuICAgIGNzczogQm9vbGVhbixcbiAgICBtb2RlOiBTdHJpbmcsXG4gICAgdHlwZTogU3RyaW5nLFxuICAgIGVudGVyQ2xhc3M6IFN0cmluZyxcbiAgICBsZWF2ZUNsYXNzOiBTdHJpbmcsXG4gICAgZW50ZXJUb0NsYXNzOiBTdHJpbmcsXG4gICAgbGVhdmVUb0NsYXNzOiBTdHJpbmcsXG4gICAgZW50ZXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICAgIGxlYXZlQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgICBhcHBlYXJDbGFzczogU3RyaW5nLFxuICAgIGFwcGVhckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gICAgYXBwZWFyVG9DbGFzczogU3RyaW5nLFxuICAgIGR1cmF0aW9uOiBbTnVtYmVyLCBTdHJpbmcsIE9iamVjdF1cbiAgfTtcblxuICAvLyBpbiBjYXNlIHRoZSBjaGlsZCBpcyBhbHNvIGFuIGFic3RyYWN0IGNvbXBvbmVudCwgZS5nLiA8a2VlcC1hbGl2ZT5cbiAgLy8gd2Ugd2FudCB0byByZWN1cnNpdmVseSByZXRyaWV2ZSB0aGUgcmVhbCBjb21wb25lbnQgdG8gYmUgcmVuZGVyZWRcbiAgZnVuY3Rpb24gZ2V0UmVhbENoaWxkICh2bm9kZSkge1xuICAgIHZhciBjb21wT3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgaWYgKGNvbXBPcHRpb25zICYmIGNvbXBPcHRpb25zLkN0b3Iub3B0aW9ucy5hYnN0cmFjdCkge1xuICAgICAgcmV0dXJuIGdldFJlYWxDaGlsZChnZXRGaXJzdENvbXBvbmVudENoaWxkKGNvbXBPcHRpb25zLmNoaWxkcmVuKSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZub2RlXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZXh0cmFjdFRyYW5zaXRpb25EYXRhIChjb21wKSB7XG4gICAgdmFyIGRhdGEgPSB7fTtcbiAgICB2YXIgb3B0aW9ucyA9IGNvbXAuJG9wdGlvbnM7XG4gICAgLy8gcHJvcHNcbiAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5wcm9wc0RhdGEpIHtcbiAgICAgIGRhdGFba2V5XSA9IGNvbXBba2V5XTtcbiAgICB9XG4gICAgLy8gZXZlbnRzLlxuICAgIC8vIGV4dHJhY3QgbGlzdGVuZXJzIGFuZCBwYXNzIHRoZW0gZGlyZWN0bHkgdG8gdGhlIHRyYW5zaXRpb24gbWV0aG9kc1xuICAgIHZhciBsaXN0ZW5lcnMgPSBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gICAgZm9yICh2YXIga2V5JDEgaW4gbGlzdGVuZXJzKSB7XG4gICAgICBkYXRhW2NhbWVsaXplKGtleSQxKV0gPSBsaXN0ZW5lcnNba2V5JDFdO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YVxuICB9XG5cbiAgZnVuY3Rpb24gcGxhY2Vob2xkZXIgKGgsIHJhd0NoaWxkKSB7XG4gICAgaWYgKC9cXGQta2VlcC1hbGl2ZSQvLnRlc3QocmF3Q2hpbGQudGFnKSkge1xuICAgICAgcmV0dXJuIGgoJ2tlZXAtYWxpdmUnLCB7XG4gICAgICAgIHByb3BzOiByYXdDaGlsZC5jb21wb25lbnRPcHRpb25zLnByb3BzRGF0YVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYXNQYXJlbnRUcmFuc2l0aW9uICh2bm9kZSkge1xuICAgIHdoaWxlICgodm5vZGUgPSB2bm9kZS5wYXJlbnQpKSB7XG4gICAgICBpZiAodm5vZGUuZGF0YS50cmFuc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNTYW1lQ2hpbGQgKGNoaWxkLCBvbGRDaGlsZCkge1xuICAgIHJldHVybiBvbGRDaGlsZC5rZXkgPT09IGNoaWxkLmtleSAmJiBvbGRDaGlsZC50YWcgPT09IGNoaWxkLnRhZ1xuICB9XG5cbiAgdmFyIGlzTm90VGV4dE5vZGUgPSBmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50YWcgfHwgaXNBc3luY1BsYWNlaG9sZGVyKGMpOyB9O1xuXG4gIHZhciBpc1ZTaG93RGlyZWN0aXZlID0gZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQubmFtZSA9PT0gJ3Nob3cnOyB9O1xuXG4gIHZhciBUcmFuc2l0aW9uID0ge1xuICAgIG5hbWU6ICd0cmFuc2l0aW9uJyxcbiAgICBwcm9wczogdHJhbnNpdGlvblByb3BzLFxuICAgIGFic3RyYWN0OiB0cnVlLFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0O1xuICAgICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gZmlsdGVyIG91dCB0ZXh0IG5vZGVzIChwb3NzaWJsZSB3aGl0ZXNwYWNlcylcbiAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW4uZmlsdGVyKGlzTm90VGV4dE5vZGUpO1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gd2FybiBtdWx0aXBsZSBlbGVtZW50c1xuICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnPHRyYW5zaXRpb24+IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBzaW5nbGUgZWxlbWVudC4gVXNlICcgK1xuICAgICAgICAgICc8dHJhbnNpdGlvbi1ncm91cD4gZm9yIGxpc3RzLicsXG4gICAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHZhciBtb2RlID0gdGhpcy5tb2RlO1xuXG4gICAgICAvLyB3YXJuIGludmFsaWQgbW9kZVxuICAgICAgaWYgKG1vZGUgJiYgbW9kZSAhPT0gJ2luLW91dCcgJiYgbW9kZSAhPT0gJ291dC1pbidcbiAgICAgICkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdpbnZhbGlkIDx0cmFuc2l0aW9uPiBtb2RlOiAnICsgbW9kZSxcbiAgICAgICAgICB0aGlzLiRwYXJlbnRcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJhd0NoaWxkID0gY2hpbGRyZW5bMF07XG5cbiAgICAgIC8vIGlmIHRoaXMgaXMgYSBjb21wb25lbnQgcm9vdCBub2RlIGFuZCB0aGUgY29tcG9uZW50J3NcbiAgICAgIC8vIHBhcmVudCBjb250YWluZXIgbm9kZSBhbHNvIGhhcyB0cmFuc2l0aW9uLCBza2lwLlxuICAgICAgaWYgKGhhc1BhcmVudFRyYW5zaXRpb24odGhpcy4kdm5vZGUpKSB7XG4gICAgICAgIHJldHVybiByYXdDaGlsZFxuICAgICAgfVxuXG4gICAgICAvLyBhcHBseSB0cmFuc2l0aW9uIGRhdGEgdG8gY2hpbGRcbiAgICAgIC8vIHVzZSBnZXRSZWFsQ2hpbGQoKSB0byBpZ25vcmUgYWJzdHJhY3QgY29tcG9uZW50cyBlLmcuIGtlZXAtYWxpdmVcbiAgICAgIHZhciBjaGlsZCA9IGdldFJlYWxDaGlsZChyYXdDaGlsZCk7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICghY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9sZWF2aW5nKSB7XG4gICAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcbiAgICAgIH1cblxuICAgICAgLy8gZW5zdXJlIGEga2V5IHRoYXQgaXMgdW5pcXVlIHRvIHRoZSB2bm9kZSB0eXBlIGFuZCB0byB0aGlzIHRyYW5zaXRpb25cbiAgICAgIC8vIGNvbXBvbmVudCBpbnN0YW5jZS4gVGhpcyBrZXkgd2lsbCBiZSB1c2VkIHRvIHJlbW92ZSBwZW5kaW5nIGxlYXZpbmcgbm9kZXNcbiAgICAgIC8vIGR1cmluZyBlbnRlcmluZy5cbiAgICAgIHZhciBpZCA9IFwiX190cmFuc2l0aW9uLVwiICsgKHRoaXMuX3VpZCkgKyBcIi1cIjtcbiAgICAgIGNoaWxkLmtleSA9IGNoaWxkLmtleSA9PSBudWxsXG4gICAgICAgID8gY2hpbGQuaXNDb21tZW50XG4gICAgICAgICAgPyBpZCArICdjb21tZW50J1xuICAgICAgICAgIDogaWQgKyBjaGlsZC50YWdcbiAgICAgICAgOiBpc1ByaW1pdGl2ZShjaGlsZC5rZXkpXG4gICAgICAgICAgPyAoU3RyaW5nKGNoaWxkLmtleSkuaW5kZXhPZihpZCkgPT09IDAgPyBjaGlsZC5rZXkgOiBpZCArIGNoaWxkLmtleSlcbiAgICAgICAgICA6IGNoaWxkLmtleTtcblxuICAgICAgdmFyIGRhdGEgPSAoY2hpbGQuZGF0YSB8fCAoY2hpbGQuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcbiAgICAgIHZhciBvbGRSYXdDaGlsZCA9IHRoaXMuX3Zub2RlO1xuICAgICAgdmFyIG9sZENoaWxkID0gZ2V0UmVhbENoaWxkKG9sZFJhd0NoaWxkKTtcblxuICAgICAgLy8gbWFyayB2LXNob3dcbiAgICAgIC8vIHNvIHRoYXQgdGhlIHRyYW5zaXRpb24gbW9kdWxlIGNhbiBoYW5kIG92ZXIgdGhlIGNvbnRyb2wgdG8gdGhlIGRpcmVjdGl2ZVxuICAgICAgaWYgKGNoaWxkLmRhdGEuZGlyZWN0aXZlcyAmJiBjaGlsZC5kYXRhLmRpcmVjdGl2ZXMuc29tZShpc1ZTaG93RGlyZWN0aXZlKSkge1xuICAgICAgICBjaGlsZC5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIG9sZENoaWxkICYmXG4gICAgICAgIG9sZENoaWxkLmRhdGEgJiZcbiAgICAgICAgIWlzU2FtZUNoaWxkKGNoaWxkLCBvbGRDaGlsZCkgJiZcbiAgICAgICAgIWlzQXN5bmNQbGFjZWhvbGRlcihvbGRDaGlsZCkgJiZcbiAgICAgICAgLy8gIzY2ODcgY29tcG9uZW50IHJvb3QgaXMgYSBjb21tZW50IG5vZGVcbiAgICAgICAgIShvbGRDaGlsZC5jb21wb25lbnRJbnN0YW5jZSAmJiBvbGRDaGlsZC5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUuaXNDb21tZW50KVxuICAgICAgKSB7XG4gICAgICAgIC8vIHJlcGxhY2Ugb2xkIGNoaWxkIHRyYW5zaXRpb24gZGF0YSB3aXRoIGZyZXNoIG9uZVxuICAgICAgICAvLyBpbXBvcnRhbnQgZm9yIGR5bmFtaWMgdHJhbnNpdGlvbnMhXG4gICAgICAgIHZhciBvbGREYXRhID0gb2xkQ2hpbGQuZGF0YS50cmFuc2l0aW9uID0gZXh0ZW5kKHt9LCBkYXRhKTtcbiAgICAgICAgLy8gaGFuZGxlIHRyYW5zaXRpb24gbW9kZVxuICAgICAgICBpZiAobW9kZSA9PT0gJ291dC1pbicpIHtcbiAgICAgICAgICAvLyByZXR1cm4gcGxhY2Vob2xkZXIgbm9kZSBhbmQgcXVldWUgdXBkYXRlIHdoZW4gbGVhdmUgZmluaXNoZXNcbiAgICAgICAgICB0aGlzLl9sZWF2aW5nID0gdHJ1ZTtcbiAgICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnYWZ0ZXJMZWF2ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMkMS5fbGVhdmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcyQxLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcbiAgICAgICAgfSBlbHNlIGlmIChtb2RlID09PSAnaW4tb3V0Jykge1xuICAgICAgICAgIGlmIChpc0FzeW5jUGxhY2Vob2xkZXIoY2hpbGQpKSB7XG4gICAgICAgICAgICByZXR1cm4gb2xkUmF3Q2hpbGRcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGRlbGF5ZWRMZWF2ZTtcbiAgICAgICAgICB2YXIgcGVyZm9ybUxlYXZlID0gZnVuY3Rpb24gKCkgeyBkZWxheWVkTGVhdmUoKTsgfTtcbiAgICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnYWZ0ZXJFbnRlcicsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2VudGVyQ2FuY2VsbGVkJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnZGVsYXlMZWF2ZScsIGZ1bmN0aW9uIChsZWF2ZSkgeyBkZWxheWVkTGVhdmUgPSBsZWF2ZTsgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuICB9O1xuXG4gIC8qICAqL1xuXG4gIHZhciBwcm9wcyA9IGV4dGVuZCh7XG4gICAgdGFnOiBTdHJpbmcsXG4gICAgbW92ZUNsYXNzOiBTdHJpbmdcbiAgfSwgdHJhbnNpdGlvblByb3BzKTtcblxuICBkZWxldGUgcHJvcHMubW9kZTtcblxuICB2YXIgVHJhbnNpdGlvbkdyb3VwID0ge1xuICAgIHByb3BzOiBwcm9wcyxcblxuICAgIGJlZm9yZU1vdW50OiBmdW5jdGlvbiBiZWZvcmVNb3VudCAoKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgdmFyIHVwZGF0ZSA9IHRoaXMuX3VwZGF0ZTtcbiAgICAgIHRoaXMuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgICAgIHZhciByZXN0b3JlQWN0aXZlSW5zdGFuY2UgPSBzZXRBY3RpdmVJbnN0YW5jZSh0aGlzJDEpO1xuICAgICAgICAvLyBmb3JjZSByZW1vdmluZyBwYXNzXG4gICAgICAgIHRoaXMkMS5fX3BhdGNoX18oXG4gICAgICAgICAgdGhpcyQxLl92bm9kZSxcbiAgICAgICAgICB0aGlzJDEua2VwdCxcbiAgICAgICAgICBmYWxzZSwgLy8gaHlkcmF0aW5nXG4gICAgICAgICAgdHJ1ZSAvLyByZW1vdmVPbmx5ICghaW1wb3J0YW50LCBhdm9pZHMgdW5uZWNlc3NhcnkgbW92ZXMpXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMkMS5fdm5vZGUgPSB0aGlzJDEua2VwdDtcbiAgICAgICAgcmVzdG9yZUFjdGl2ZUluc3RhbmNlKCk7XG4gICAgICAgIHVwZGF0ZS5jYWxsKHRoaXMkMSwgdm5vZGUsIGh5ZHJhdGluZyk7XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgICAgdmFyIHRhZyA9IHRoaXMudGFnIHx8IHRoaXMuJHZub2RlLmRhdGEudGFnIHx8ICdzcGFuJztcbiAgICAgIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICAgIHZhciByYXdDaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQgfHwgW107XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgICB2YXIgdHJhbnNpdGlvbkRhdGEgPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmF3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGMgPSByYXdDaGlsZHJlbltpXTtcbiAgICAgICAgaWYgKGMudGFnKSB7XG4gICAgICAgICAgaWYgKGMua2V5ICE9IG51bGwgJiYgU3RyaW5nKGMua2V5KS5pbmRleE9mKCdfX3ZsaXN0JykgIT09IDApIHtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goYyk7XG4gICAgICAgICAgICBtYXBbYy5rZXldID0gY1xuICAgICAgICAgICAgOyhjLmRhdGEgfHwgKGMuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgb3B0cyA9IGMuY29tcG9uZW50T3B0aW9ucztcbiAgICAgICAgICAgIHZhciBuYW1lID0gb3B0cyA/IChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnIHx8ICcnKSA6IGMudGFnO1xuICAgICAgICAgICAgd2FybigoXCI8dHJhbnNpdGlvbi1ncm91cD4gY2hpbGRyZW4gbXVzdCBiZSBrZXllZDogPFwiICsgbmFtZSArIFwiPlwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwcmV2Q2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGtlcHQgPSBbXTtcbiAgICAgICAgdmFyIHJlbW92ZWQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcHJldkNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICB2YXIgYyQxID0gcHJldkNoaWxkcmVuW2kkMV07XG4gICAgICAgICAgYyQxLmRhdGEudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICAgIGMkMS5kYXRhLnBvcyA9IGMkMS5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgaWYgKG1hcFtjJDEua2V5XSkge1xuICAgICAgICAgICAga2VwdC5wdXNoKGMkMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbW92ZWQucHVzaChjJDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmtlcHQgPSBoKHRhZywgbnVsbCwga2VwdCk7XG4gICAgICAgIHRoaXMucmVtb3ZlZCA9IHJlbW92ZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoKHRhZywgbnVsbCwgY2hpbGRyZW4pXG4gICAgfSxcblxuICAgIHVwZGF0ZWQ6IGZ1bmN0aW9uIHVwZGF0ZWQgKCkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW47XG4gICAgICB2YXIgbW92ZUNsYXNzID0gdGhpcy5tb3ZlQ2xhc3MgfHwgKCh0aGlzLm5hbWUgfHwgJ3YnKSArICctbW92ZScpO1xuICAgICAgaWYgKCFjaGlsZHJlbi5sZW5ndGggfHwgIXRoaXMuaGFzTW92ZShjaGlsZHJlblswXS5lbG0sIG1vdmVDbGFzcykpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIHdlIGRpdmlkZSB0aGUgd29yayBpbnRvIHRocmVlIGxvb3BzIHRvIGF2b2lkIG1peGluZyBET00gcmVhZHMgYW5kIHdyaXRlc1xuICAgICAgLy8gaW4gZWFjaCBpdGVyYXRpb24gLSB3aGljaCBoZWxwcyBwcmV2ZW50IGxheW91dCB0aHJhc2hpbmcuXG4gICAgICBjaGlsZHJlbi5mb3JFYWNoKGNhbGxQZW5kaW5nQ2JzKTtcbiAgICAgIGNoaWxkcmVuLmZvckVhY2gocmVjb3JkUG9zaXRpb24pO1xuICAgICAgY2hpbGRyZW4uZm9yRWFjaChhcHBseVRyYW5zbGF0aW9uKTtcblxuICAgICAgLy8gZm9yY2UgcmVmbG93IHRvIHB1dCBldmVyeXRoaW5nIGluIHBvc2l0aW9uXG4gICAgICAvLyBhc3NpZ24gdG8gdGhpcyB0byBhdm9pZCBiZWluZyByZW1vdmVkIGluIHRyZWUtc2hha2luZ1xuICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICB0aGlzLl9yZWZsb3cgPSBkb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodDtcblxuICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAoYy5kYXRhLm1vdmVkKSB7XG4gICAgICAgICAgdmFyIGVsID0gYy5lbG07XG4gICAgICAgICAgdmFyIHMgPSBlbC5zdHlsZTtcbiAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJyc7XG4gICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGVsLl9tb3ZlQ2IgPSBmdW5jdGlvbiBjYiAoZSkge1xuICAgICAgICAgICAgaWYgKGUgJiYgZS50YXJnZXQgIT09IGVsKSB7XG4gICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFlIHx8IC90cmFuc2Zvcm0kLy50ZXN0KGUucHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgY2IpO1xuICAgICAgICAgICAgICBlbC5fbW92ZUNiID0gbnVsbDtcbiAgICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgbWV0aG9kczoge1xuICAgICAgaGFzTW92ZTogZnVuY3Rpb24gaGFzTW92ZSAoZWwsIG1vdmVDbGFzcykge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFoYXNUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICh0aGlzLl9oYXNNb3ZlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2hhc01vdmVcbiAgICAgICAgfVxuICAgICAgICAvLyBEZXRlY3Qgd2hldGhlciBhbiBlbGVtZW50IHdpdGggdGhlIG1vdmUgY2xhc3MgYXBwbGllZCBoYXNcbiAgICAgICAgLy8gQ1NTIHRyYW5zaXRpb25zLiBTaW5jZSB0aGUgZWxlbWVudCBtYXkgYmUgaW5zaWRlIGFuIGVudGVyaW5nXG4gICAgICAgIC8vIHRyYW5zaXRpb24gYXQgdGhpcyB2ZXJ5IG1vbWVudCwgd2UgbWFrZSBhIGNsb25lIG9mIGl0IGFuZCByZW1vdmVcbiAgICAgICAgLy8gYWxsIG90aGVyIHRyYW5zaXRpb24gY2xhc3NlcyBhcHBsaWVkIHRvIGVuc3VyZSBvbmx5IHRoZSBtb3ZlIGNsYXNzXG4gICAgICAgIC8vIGlzIGFwcGxpZWQuXG4gICAgICAgIHZhciBjbG9uZSA9IGVsLmNsb25lTm9kZSgpO1xuICAgICAgICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgICAgICAgZWwuX3RyYW5zaXRpb25DbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNscykgeyByZW1vdmVDbGFzcyhjbG9uZSwgY2xzKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkQ2xhc3MoY2xvbmUsIG1vdmVDbGFzcyk7XG4gICAgICAgIGNsb25lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMuJGVsLmFwcGVuZENoaWxkKGNsb25lKTtcbiAgICAgICAgdmFyIGluZm8gPSBnZXRUcmFuc2l0aW9uSW5mbyhjbG9uZSk7XG4gICAgICAgIHRoaXMuJGVsLnJlbW92ZUNoaWxkKGNsb25lKTtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9oYXNNb3ZlID0gaW5mby5oYXNUcmFuc2Zvcm0pXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGNhbGxQZW5kaW5nQ2JzIChjKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGMuZWxtLl9tb3ZlQ2IpIHtcbiAgICAgIGMuZWxtLl9tb3ZlQ2IoKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGMuZWxtLl9lbnRlckNiKSB7XG4gICAgICBjLmVsbS5fZW50ZXJDYigpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uIChjKSB7XG4gICAgYy5kYXRhLm5ld1BvcyA9IGMuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbiAoYykge1xuICAgIHZhciBvbGRQb3MgPSBjLmRhdGEucG9zO1xuICAgIHZhciBuZXdQb3MgPSBjLmRhdGEubmV3UG9zO1xuICAgIHZhciBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XG4gICAgdmFyIGR5ID0gb2xkUG9zLnRvcCAtIG5ld1Bvcy50b3A7XG4gICAgaWYgKGR4IHx8IGR5KSB7XG4gICAgICBjLmRhdGEubW92ZWQgPSB0cnVlO1xuICAgICAgdmFyIHMgPSBjLmVsbS5zdHlsZTtcbiAgICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIGR4ICsgXCJweCxcIiArIGR5ICsgXCJweClcIjtcbiAgICAgIHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcbiAgICB9XG4gIH1cblxuICB2YXIgcGxhdGZvcm1Db21wb25lbnRzID0ge1xuICAgIFRyYW5zaXRpb246IFRyYW5zaXRpb24sXG4gICAgVHJhbnNpdGlvbkdyb3VwOiBUcmFuc2l0aW9uR3JvdXBcbiAgfTtcblxuICAvKiAgKi9cblxuICAvLyBpbnN0YWxsIHBsYXRmb3JtIHNwZWNpZmljIHV0aWxzXG4gIFZ1ZS5jb25maWcubXVzdFVzZVByb3AgPSBtdXN0VXNlUHJvcDtcbiAgVnVlLmNvbmZpZy5pc1Jlc2VydmVkVGFnID0gaXNSZXNlcnZlZFRhZztcbiAgVnVlLmNvbmZpZy5pc1Jlc2VydmVkQXR0ciA9IGlzUmVzZXJ2ZWRBdHRyO1xuICBWdWUuY29uZmlnLmdldFRhZ05hbWVzcGFjZSA9IGdldFRhZ05hbWVzcGFjZTtcbiAgVnVlLmNvbmZpZy5pc1Vua25vd25FbGVtZW50ID0gaXNVbmtub3duRWxlbWVudDtcblxuICAvLyBpbnN0YWxsIHBsYXRmb3JtIHJ1bnRpbWUgZGlyZWN0aXZlcyAmIGNvbXBvbmVudHNcbiAgZXh0ZW5kKFZ1ZS5vcHRpb25zLmRpcmVjdGl2ZXMsIHBsYXRmb3JtRGlyZWN0aXZlcyk7XG4gIGV4dGVuZChWdWUub3B0aW9ucy5jb21wb25lbnRzLCBwbGF0Zm9ybUNvbXBvbmVudHMpO1xuXG4gIC8vIGluc3RhbGwgcGxhdGZvcm0gcGF0Y2ggZnVuY3Rpb25cbiAgVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gPSBpbkJyb3dzZXIgPyBwYXRjaCA6IG5vb3A7XG5cbiAgLy8gcHVibGljIG1vdW50IG1ldGhvZFxuICBWdWUucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgICBlbCxcbiAgICBoeWRyYXRpbmdcbiAgKSB7XG4gICAgZWwgPSBlbCAmJiBpbkJyb3dzZXIgPyBxdWVyeShlbCkgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIG1vdW50Q29tcG9uZW50KHRoaXMsIGVsLCBoeWRyYXRpbmcpXG4gIH07XG5cbiAgLy8gZGV2dG9vbHMgZ2xvYmFsIGhvb2tcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgaWYgKGluQnJvd3Nlcikge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGNvbmZpZy5kZXZ0b29scykge1xuICAgICAgICBpZiAoZGV2dG9vbHMpIHtcbiAgICAgICAgICBkZXZ0b29scy5lbWl0KCdpbml0JywgVnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgICAgICdEb3dubG9hZCB0aGUgVnVlIERldnRvb2xzIGV4dGVuc2lvbiBmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTpcXG4nICtcbiAgICAgICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlLWRldnRvb2xzJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjb25maWcucHJvZHVjdGlvblRpcCAhPT0gZmFsc2UgJiZcbiAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnXG4gICAgICApIHtcbiAgICAgICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXG4gICAgICAgICAgXCJZb3UgYXJlIHJ1bm5pbmcgVnVlIGluIGRldmVsb3BtZW50IG1vZGUuXFxuXCIgK1xuICAgICAgICAgIFwiTWFrZSBzdXJlIHRvIHR1cm4gb24gcHJvZHVjdGlvbiBtb2RlIHdoZW4gZGVwbG95aW5nIGZvciBwcm9kdWN0aW9uLlxcblwiICtcbiAgICAgICAgICBcIlNlZSBtb3JlIHRpcHMgYXQgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvZGVwbG95bWVudC5odG1sXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LCAwKTtcbiAgfVxuXG4gIC8qICAqL1xuXG4gIHZhciBkZWZhdWx0VGFnUkUgPSAvXFx7XFx7KCg/Oi58XFxyP1xcbikrPylcXH1cXH0vZztcbiAgdmFyIHJlZ2V4RXNjYXBlUkUgPSAvWy0uKis/XiR7fSgpfFtcXF1cXC9cXFxcXS9nO1xuXG4gIHZhciBidWlsZFJlZ2V4ID0gY2FjaGVkKGZ1bmN0aW9uIChkZWxpbWl0ZXJzKSB7XG4gICAgdmFyIG9wZW4gPSBkZWxpbWl0ZXJzWzBdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xuICAgIHZhciBjbG9zZSA9IGRlbGltaXRlcnNbMV0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAob3BlbiArICcoKD86LnxcXFxcbikrPyknICsgY2xvc2UsICdnJylcbiAgfSk7XG5cblxuXG4gIGZ1bmN0aW9uIHBhcnNlVGV4dCAoXG4gICAgdGV4dCxcbiAgICBkZWxpbWl0ZXJzXG4gICkge1xuICAgIHZhciB0YWdSRSA9IGRlbGltaXRlcnMgPyBidWlsZFJlZ2V4KGRlbGltaXRlcnMpIDogZGVmYXVsdFRhZ1JFO1xuICAgIGlmICghdGFnUkUudGVzdCh0ZXh0KSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciB0b2tlbnMgPSBbXTtcbiAgICB2YXIgcmF3VG9rZW5zID0gW107XG4gICAgdmFyIGxhc3RJbmRleCA9IHRhZ1JFLmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIG1hdGNoLCBpbmRleCwgdG9rZW5WYWx1ZTtcbiAgICB3aGlsZSAoKG1hdGNoID0gdGFnUkUuZXhlYyh0ZXh0KSkpIHtcbiAgICAgIGluZGV4ID0gbWF0Y2guaW5kZXg7XG4gICAgICAvLyBwdXNoIHRleHQgdG9rZW5cbiAgICAgIGlmIChpbmRleCA+IGxhc3RJbmRleCkge1xuICAgICAgICByYXdUb2tlbnMucHVzaCh0b2tlblZhbHVlID0gdGV4dC5zbGljZShsYXN0SW5kZXgsIGluZGV4KSk7XG4gICAgICAgIHRva2Vucy5wdXNoKEpTT04uc3RyaW5naWZ5KHRva2VuVmFsdWUpKTtcbiAgICAgIH1cbiAgICAgIC8vIHRhZyB0b2tlblxuICAgICAgdmFyIGV4cCA9IHBhcnNlRmlsdGVycyhtYXRjaFsxXS50cmltKCkpO1xuICAgICAgdG9rZW5zLnB1c2goKFwiX3MoXCIgKyBleHAgKyBcIilcIikpO1xuICAgICAgcmF3VG9rZW5zLnB1c2goeyAnQGJpbmRpbmcnOiBleHAgfSk7XG4gICAgICBsYXN0SW5kZXggPSBpbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKGxhc3RJbmRleCA8IHRleHQubGVuZ3RoKSB7XG4gICAgICByYXdUb2tlbnMucHVzaCh0b2tlblZhbHVlID0gdGV4dC5zbGljZShsYXN0SW5kZXgpKTtcbiAgICAgIHRva2Vucy5wdXNoKEpTT04uc3RyaW5naWZ5KHRva2VuVmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGV4cHJlc3Npb246IHRva2Vucy5qb2luKCcrJyksXG4gICAgICB0b2tlbnM6IHJhd1Rva2Vuc1xuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIHRyYW5zZm9ybU5vZGUgKGVsLCBvcHRpb25zKSB7XG4gICAgdmFyIHdhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gICAgdmFyIHN0YXRpY0NsYXNzID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2NsYXNzJyk7XG4gICAgaWYgKHN0YXRpY0NsYXNzKSB7XG4gICAgICB2YXIgcmVzID0gcGFyc2VUZXh0KHN0YXRpY0NsYXNzLCBvcHRpb25zLmRlbGltaXRlcnMpO1xuICAgICAgaWYgKHJlcykge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiY2xhc3M9XFxcIlwiICsgc3RhdGljQ2xhc3MgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IGNsYXNzPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6Y2xhc3M9XCJ2YWxcIj4uJyxcbiAgICAgICAgICBlbC5yYXdBdHRyc01hcFsnY2xhc3MnXVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhdGljQ2xhc3MpIHtcbiAgICAgIGVsLnN0YXRpY0NsYXNzID0gSlNPTi5zdHJpbmdpZnkoc3RhdGljQ2xhc3MpO1xuICAgIH1cbiAgICB2YXIgY2xhc3NCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdjbGFzcycsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG4gICAgaWYgKGNsYXNzQmluZGluZykge1xuICAgICAgZWwuY2xhc3NCaW5kaW5nID0gY2xhc3NCaW5kaW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbkRhdGEgKGVsKSB7XG4gICAgdmFyIGRhdGEgPSAnJztcbiAgICBpZiAoZWwuc3RhdGljQ2xhc3MpIHtcbiAgICAgIGRhdGEgKz0gXCJzdGF0aWNDbGFzczpcIiArIChlbC5zdGF0aWNDbGFzcykgKyBcIixcIjtcbiAgICB9XG4gICAgaWYgKGVsLmNsYXNzQmluZGluZykge1xuICAgICAgZGF0YSArPSBcImNsYXNzOlwiICsgKGVsLmNsYXNzQmluZGluZykgKyBcIixcIjtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGFcbiAgfVxuXG4gIHZhciBrbGFzcyQxID0ge1xuICAgIHN0YXRpY0tleXM6IFsnc3RhdGljQ2xhc3MnXSxcbiAgICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlLFxuICAgIGdlbkRhdGE6IGdlbkRhdGFcbiAgfTtcblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiB0cmFuc2Zvcm1Ob2RlJDEgKGVsLCBvcHRpb25zKSB7XG4gICAgdmFyIHdhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gICAgdmFyIHN0YXRpY1N0eWxlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3N0eWxlJyk7XG4gICAgaWYgKHN0YXRpY1N0eWxlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIHtcbiAgICAgICAgdmFyIHJlcyA9IHBhcnNlVGV4dChzdGF0aWNTdHlsZSwgb3B0aW9ucy5kZWxpbWl0ZXJzKTtcbiAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBcInN0eWxlPVxcXCJcIiArIHN0YXRpY1N0eWxlICsgXCJcXFwiOiBcIiArXG4gICAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBzdHlsZT1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOnN0eWxlPVwidmFsXCI+LicsXG4gICAgICAgICAgICBlbC5yYXdBdHRyc01hcFsnc3R5bGUnXVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsLnN0YXRpY1N0eWxlID0gSlNPTi5zdHJpbmdpZnkocGFyc2VTdHlsZVRleHQoc3RhdGljU3R5bGUpKTtcbiAgICB9XG5cbiAgICB2YXIgc3R5bGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzdHlsZScsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG4gICAgaWYgKHN0eWxlQmluZGluZykge1xuICAgICAgZWwuc3R5bGVCaW5kaW5nID0gc3R5bGVCaW5kaW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbkRhdGEkMSAoZWwpIHtcbiAgICB2YXIgZGF0YSA9ICcnO1xuICAgIGlmIChlbC5zdGF0aWNTdHlsZSkge1xuICAgICAgZGF0YSArPSBcInN0YXRpY1N0eWxlOlwiICsgKGVsLnN0YXRpY1N0eWxlKSArIFwiLFwiO1xuICAgIH1cbiAgICBpZiAoZWwuc3R5bGVCaW5kaW5nKSB7XG4gICAgICBkYXRhICs9IFwic3R5bGU6KFwiICsgKGVsLnN0eWxlQmluZGluZykgKyBcIiksXCI7XG4gICAgfVxuICAgIHJldHVybiBkYXRhXG4gIH1cblxuICB2YXIgc3R5bGUkMSA9IHtcbiAgICBzdGF0aWNLZXlzOiBbJ3N0YXRpY1N0eWxlJ10sXG4gICAgdHJhbnNmb3JtTm9kZTogdHJhbnNmb3JtTm9kZSQxLFxuICAgIGdlbkRhdGE6IGdlbkRhdGEkMVxuICB9O1xuXG4gIC8qICAqL1xuXG4gIHZhciBkZWNvZGVyO1xuXG4gIHZhciBoZSA9IHtcbiAgICBkZWNvZGU6IGZ1bmN0aW9uIGRlY29kZSAoaHRtbCkge1xuICAgICAgZGVjb2RlciA9IGRlY29kZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBkZWNvZGVyLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICByZXR1cm4gZGVjb2Rlci50ZXh0Q29udGVudFxuICAgIH1cbiAgfTtcblxuICAvKiAgKi9cblxuICB2YXIgaXNVbmFyeVRhZyA9IG1ha2VNYXAoXG4gICAgJ2FyZWEsYmFzZSxicixjb2wsZW1iZWQsZnJhbWUsaHIsaW1nLGlucHV0LGlzaW5kZXgsa2V5Z2VuLCcgK1xuICAgICdsaW5rLG1ldGEscGFyYW0sc291cmNlLHRyYWNrLHdicidcbiAgKTtcblxuICAvLyBFbGVtZW50cyB0aGF0IHlvdSBjYW4sIGludGVudGlvbmFsbHksIGxlYXZlIG9wZW5cbiAgLy8gKGFuZCB3aGljaCBjbG9zZSB0aGVtc2VsdmVzKVxuICB2YXIgY2FuQmVMZWZ0T3BlblRhZyA9IG1ha2VNYXAoXG4gICAgJ2NvbGdyb3VwLGRkLGR0LGxpLG9wdGlvbnMscCx0ZCx0Zm9vdCx0aCx0aGVhZCx0cixzb3VyY2UnXG4gICk7XG5cbiAgLy8gSFRNTDUgdGFncyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmRpY2VzLmh0bWwjZWxlbWVudHMtM1xuICAvLyBQaHJhc2luZyBDb250ZW50IGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2RvbS5odG1sI3BocmFzaW5nLWNvbnRlbnRcbiAgdmFyIGlzTm9uUGhyYXNpbmdUYWcgPSBtYWtlTWFwKFxuICAgICdhZGRyZXNzLGFydGljbGUsYXNpZGUsYmFzZSxibG9ja3F1b3RlLGJvZHksY2FwdGlvbixjb2wsY29sZ3JvdXAsZGQsJyArXG4gICAgJ2RldGFpbHMsZGlhbG9nLGRpdixkbCxkdCxmaWVsZHNldCxmaWdjYXB0aW9uLGZpZ3VyZSxmb290ZXIsZm9ybSwnICtcbiAgICAnaDEsaDIsaDMsaDQsaDUsaDYsaGVhZCxoZWFkZXIsaGdyb3VwLGhyLGh0bWwsbGVnZW5kLGxpLG1lbnVpdGVtLG1ldGEsJyArXG4gICAgJ29wdGdyb3VwLG9wdGlvbixwYXJhbSxycCxydCxzb3VyY2Usc3R5bGUsc3VtbWFyeSx0Ym9keSx0ZCx0Zm9vdCx0aCx0aGVhZCwnICtcbiAgICAndGl0bGUsdHIsdHJhY2snXG4gICk7XG5cbiAgLyoqXG4gICAqIE5vdCB0eXBlLWNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGl0J3MgbW9zdGx5IHZlbmRvciBjb2RlLlxuICAgKi9cblxuICAvLyBSZWd1bGFyIEV4cHJlc3Npb25zIGZvciBwYXJzaW5nIHRhZ3MgYW5kIGF0dHJpYnV0ZXNcbiAgdmFyIGF0dHJpYnV0ZSA9IC9eXFxzKihbXlxcc1wiJzw+XFwvPV0rKSg/OlxccyooPSlcXHMqKD86XCIoW15cIl0qKVwiK3wnKFteJ10qKScrfChbXlxcc1wiJz08PmBdKykpKT8vO1xuICB2YXIgZHluYW1pY0FyZ0F0dHJpYnV0ZSA9IC9eXFxzKigoPzp2LVtcXHctXSs6fEB8OnwjKVxcW1tePV0rXFxdW15cXHNcIic8PlxcLz1dKikoPzpcXHMqKD0pXFxzKig/OlwiKFteXCJdKilcIit8JyhbXiddKiknK3woW15cXHNcIic9PD5gXSspKSk/LztcbiAgdmFyIG5jbmFtZSA9IFwiW2EtekEtWl9dW1xcXFwtXFxcXC4wLTlfYS16QS1aXCIgKyAodW5pY29kZVJlZ0V4cC5zb3VyY2UpICsgXCJdKlwiO1xuICB2YXIgcW5hbWVDYXB0dXJlID0gXCIoKD86XCIgKyBuY25hbWUgKyBcIlxcXFw6KT9cIiArIG5jbmFtZSArIFwiKVwiO1xuICB2YXIgc3RhcnRUYWdPcGVuID0gbmV3IFJlZ0V4cCgoXCJePFwiICsgcW5hbWVDYXB0dXJlKSk7XG4gIHZhciBzdGFydFRhZ0Nsb3NlID0gL15cXHMqKFxcLz8pPi87XG4gIHZhciBlbmRUYWcgPSBuZXcgUmVnRXhwKChcIl48XFxcXC9cIiArIHFuYW1lQ2FwdHVyZSArIFwiW14+XSo+XCIpKTtcbiAgdmFyIGRvY3R5cGUgPSAvXjwhRE9DVFlQRSBbXj5dKz4vaTtcbiAgLy8gIzcyOTg6IGVzY2FwZSAtIHRvIGF2b2lkIGJlaW5nIHBhc2VkIGFzIEhUTUwgY29tbWVudCB3aGVuIGlubGluZWQgaW4gcGFnZVxuICB2YXIgY29tbWVudCA9IC9ePCFcXC0tLztcbiAgdmFyIGNvbmRpdGlvbmFsQ29tbWVudCA9IC9ePCFcXFsvO1xuXG4gIC8vIFNwZWNpYWwgRWxlbWVudHMgKGNhbiBjb250YWluIGFueXRoaW5nKVxuICB2YXIgaXNQbGFpblRleHRFbGVtZW50ID0gbWFrZU1hcCgnc2NyaXB0LHN0eWxlLHRleHRhcmVhJywgdHJ1ZSk7XG4gIHZhciByZUNhY2hlID0ge307XG5cbiAgdmFyIGRlY29kaW5nTWFwID0ge1xuICAgICcmbHQ7JzogJzwnLFxuICAgICcmZ3Q7JzogJz4nLFxuICAgICcmcXVvdDsnOiAnXCInLFxuICAgICcmYW1wOyc6ICcmJyxcbiAgICAnJiMxMDsnOiAnXFxuJyxcbiAgICAnJiM5Oyc6ICdcXHQnLFxuICAgICcmIzM5Oyc6IFwiJ1wiXG4gIH07XG4gIHZhciBlbmNvZGVkQXR0ciA9IC8mKD86bHR8Z3R8cXVvdHxhbXB8IzM5KTsvZztcbiAgdmFyIGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzID0gLyYoPzpsdHxndHxxdW90fGFtcHwjMzl8IzEwfCM5KTsvZztcblxuICAvLyAjNTk5MlxuICB2YXIgaXNJZ25vcmVOZXdsaW5lVGFnID0gbWFrZU1hcCgncHJlLHRleHRhcmVhJywgdHJ1ZSk7XG4gIHZhciBzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUgPSBmdW5jdGlvbiAodGFnLCBodG1sKSB7IHJldHVybiB0YWcgJiYgaXNJZ25vcmVOZXdsaW5lVGFnKHRhZykgJiYgaHRtbFswXSA9PT0gJ1xcbic7IH07XG5cbiAgZnVuY3Rpb24gZGVjb2RlQXR0ciAodmFsdWUsIHNob3VsZERlY29kZU5ld2xpbmVzKSB7XG4gICAgdmFyIHJlID0gc2hvdWxkRGVjb2RlTmV3bGluZXMgPyBlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyA6IGVuY29kZWRBdHRyO1xuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKHJlLCBmdW5jdGlvbiAobWF0Y2gpIHsgcmV0dXJuIGRlY29kaW5nTWFwW21hdGNoXTsgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSFRNTCAoaHRtbCwgb3B0aW9ucykge1xuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIHZhciBleHBlY3RIVE1MID0gb3B0aW9ucy5leHBlY3RIVE1MO1xuICAgIHZhciBpc1VuYXJ5VGFnJCQxID0gb3B0aW9ucy5pc1VuYXJ5VGFnIHx8IG5vO1xuICAgIHZhciBjYW5CZUxlZnRPcGVuVGFnJCQxID0gb3B0aW9ucy5jYW5CZUxlZnRPcGVuVGFnIHx8IG5vO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGxhc3QsIGxhc3RUYWc7XG4gICAgd2hpbGUgKGh0bWwpIHtcbiAgICAgIGxhc3QgPSBodG1sO1xuICAgICAgLy8gTWFrZSBzdXJlIHdlJ3JlIG5vdCBpbiBhIHBsYWludGV4dCBjb250ZW50IGVsZW1lbnQgbGlrZSBzY3JpcHQvc3R5bGVcbiAgICAgIGlmICghbGFzdFRhZyB8fCAhaXNQbGFpblRleHRFbGVtZW50KGxhc3RUYWcpKSB7XG4gICAgICAgIHZhciB0ZXh0RW5kID0gaHRtbC5pbmRleE9mKCc8Jyk7XG4gICAgICAgIGlmICh0ZXh0RW5kID09PSAwKSB7XG4gICAgICAgICAgLy8gQ29tbWVudDpcbiAgICAgICAgICBpZiAoY29tbWVudC50ZXN0KGh0bWwpKSB7XG4gICAgICAgICAgICB2YXIgY29tbWVudEVuZCA9IGh0bWwuaW5kZXhPZignLS0+Jyk7XG5cbiAgICAgICAgICAgIGlmIChjb21tZW50RW5kID49IDApIHtcbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2hvdWxkS2VlcENvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmNvbW1lbnQoaHRtbC5zdWJzdHJpbmcoNCwgY29tbWVudEVuZCksIGluZGV4LCBpbmRleCArIGNvbW1lbnRFbmQgKyAzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhZHZhbmNlKGNvbW1lbnRFbmQgKyAzKTtcbiAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbmRpdGlvbmFsX2NvbW1lbnQjRG93bmxldmVsLXJldmVhbGVkX2NvbmRpdGlvbmFsX2NvbW1lbnRcbiAgICAgICAgICBpZiAoY29uZGl0aW9uYWxDb21tZW50LnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICAgIHZhciBjb25kaXRpb25hbEVuZCA9IGh0bWwuaW5kZXhPZignXT4nKTtcblxuICAgICAgICAgICAgaWYgKGNvbmRpdGlvbmFsRW5kID49IDApIHtcbiAgICAgICAgICAgICAgYWR2YW5jZShjb25kaXRpb25hbEVuZCArIDIpO1xuICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIERvY3R5cGU6XG4gICAgICAgICAgdmFyIGRvY3R5cGVNYXRjaCA9IGh0bWwubWF0Y2goZG9jdHlwZSk7XG4gICAgICAgICAgaWYgKGRvY3R5cGVNYXRjaCkge1xuICAgICAgICAgICAgYWR2YW5jZShkb2N0eXBlTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRW5kIHRhZzpcbiAgICAgICAgICB2YXIgZW5kVGFnTWF0Y2ggPSBodG1sLm1hdGNoKGVuZFRhZyk7XG4gICAgICAgICAgaWYgKGVuZFRhZ01hdGNoKSB7XG4gICAgICAgICAgICB2YXIgY3VySW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIGFkdmFuY2UoZW5kVGFnTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIHBhcnNlRW5kVGFnKGVuZFRhZ01hdGNoWzFdLCBjdXJJbmRleCwgaW5kZXgpO1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTdGFydCB0YWc6XG4gICAgICAgICAgdmFyIHN0YXJ0VGFnTWF0Y2ggPSBwYXJzZVN0YXJ0VGFnKCk7XG4gICAgICAgICAgaWYgKHN0YXJ0VGFnTWF0Y2gpIHtcbiAgICAgICAgICAgIGhhbmRsZVN0YXJ0VGFnKHN0YXJ0VGFnTWF0Y2gpO1xuICAgICAgICAgICAgaWYgKHNob3VsZElnbm9yZUZpcnN0TmV3bGluZShzdGFydFRhZ01hdGNoLnRhZ05hbWUsIGh0bWwpKSB7XG4gICAgICAgICAgICAgIGFkdmFuY2UoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0ZXh0ID0gKHZvaWQgMCksIHJlc3QgPSAodm9pZCAwKSwgbmV4dCA9ICh2b2lkIDApO1xuICAgICAgICBpZiAodGV4dEVuZCA+PSAwKSB7XG4gICAgICAgICAgcmVzdCA9IGh0bWwuc2xpY2UodGV4dEVuZCk7XG4gICAgICAgICAgd2hpbGUgKFxuICAgICAgICAgICAgIWVuZFRhZy50ZXN0KHJlc3QpICYmXG4gICAgICAgICAgICAhc3RhcnRUYWdPcGVuLnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAgICFjb21tZW50LnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAgICFjb25kaXRpb25hbENvbW1lbnQudGVzdChyZXN0KVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgLy8gPCBpbiBwbGFpbiB0ZXh0LCBiZSBmb3JnaXZpbmcgYW5kIHRyZWF0IGl0IGFzIHRleHRcbiAgICAgICAgICAgIG5leHQgPSByZXN0LmluZGV4T2YoJzwnLCAxKTtcbiAgICAgICAgICAgIGlmIChuZXh0IDwgMCkgeyBicmVhayB9XG4gICAgICAgICAgICB0ZXh0RW5kICs9IG5leHQ7XG4gICAgICAgICAgICByZXN0ID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGV4dCA9IGh0bWwuc3Vic3RyaW5nKDAsIHRleHRFbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRleHRFbmQgPCAwKSB7XG4gICAgICAgICAgdGV4dCA9IGh0bWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgIGFkdmFuY2UodGV4dC5sZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuY2hhcnMgJiYgdGV4dCkge1xuICAgICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCwgaW5kZXggLSB0ZXh0Lmxlbmd0aCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZW5kVGFnTGVuZ3RoID0gMDtcbiAgICAgICAgdmFyIHN0YWNrZWRUYWcgPSBsYXN0VGFnLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciByZVN0YWNrZWRUYWcgPSByZUNhY2hlW3N0YWNrZWRUYWddIHx8IChyZUNhY2hlW3N0YWNrZWRUYWddID0gbmV3IFJlZ0V4cCgnKFtcXFxcc1xcXFxTXSo/KSg8LycgKyBzdGFja2VkVGFnICsgJ1tePl0qPiknLCAnaScpKTtcbiAgICAgICAgdmFyIHJlc3QkMSA9IGh0bWwucmVwbGFjZShyZVN0YWNrZWRUYWcsIGZ1bmN0aW9uIChhbGwsIHRleHQsIGVuZFRhZykge1xuICAgICAgICAgIGVuZFRhZ0xlbmd0aCA9IGVuZFRhZy5sZW5ndGg7XG4gICAgICAgICAgaWYgKCFpc1BsYWluVGV4dEVsZW1lbnQoc3RhY2tlZFRhZykgJiYgc3RhY2tlZFRhZyAhPT0gJ25vc2NyaXB0Jykge1xuICAgICAgICAgICAgdGV4dCA9IHRleHRcbiAgICAgICAgICAgICAgLnJlcGxhY2UoLzwhXFwtLShbXFxzXFxTXSo/KS0tPi9nLCAnJDEnKSAvLyAjNzI5OFxuICAgICAgICAgICAgICAucmVwbGFjZSgvPCFcXFtDREFUQVxcWyhbXFxzXFxTXSo/KV1dPi9nLCAnJDEnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNob3VsZElnbm9yZUZpcnN0TmV3bGluZShzdGFja2VkVGFnLCB0ZXh0KSkge1xuICAgICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHRpb25zLmNoYXJzKSB7XG4gICAgICAgICAgICBvcHRpb25zLmNoYXJzKHRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gJydcbiAgICAgICAgfSk7XG4gICAgICAgIGluZGV4ICs9IGh0bWwubGVuZ3RoIC0gcmVzdCQxLmxlbmd0aDtcbiAgICAgICAgaHRtbCA9IHJlc3QkMTtcbiAgICAgICAgcGFyc2VFbmRUYWcoc3RhY2tlZFRhZywgaW5kZXggLSBlbmRUYWdMZW5ndGgsIGluZGV4KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGh0bWwgPT09IGxhc3QpIHtcbiAgICAgICAgb3B0aW9ucy5jaGFycyAmJiBvcHRpb25zLmNoYXJzKGh0bWwpO1xuICAgICAgICBpZiAoIXN0YWNrLmxlbmd0aCAmJiBvcHRpb25zLndhcm4pIHtcbiAgICAgICAgICBvcHRpb25zLndhcm4oKFwiTWFsLWZvcm1hdHRlZCB0YWcgYXQgZW5kIG9mIHRlbXBsYXRlOiBcXFwiXCIgKyBodG1sICsgXCJcXFwiXCIpLCB7IHN0YXJ0OiBpbmRleCArIGh0bWwubGVuZ3RoIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2xlYW4gdXAgYW55IHJlbWFpbmluZyB0YWdzXG4gICAgcGFyc2VFbmRUYWcoKTtcblxuICAgIGZ1bmN0aW9uIGFkdmFuY2UgKG4pIHtcbiAgICAgIGluZGV4ICs9IG47XG4gICAgICBodG1sID0gaHRtbC5zdWJzdHJpbmcobik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VTdGFydFRhZyAoKSB7XG4gICAgICB2YXIgc3RhcnQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnT3Blbik7XG4gICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgdmFyIG1hdGNoID0ge1xuICAgICAgICAgIHRhZ05hbWU6IHN0YXJ0WzFdLFxuICAgICAgICAgIGF0dHJzOiBbXSxcbiAgICAgICAgICBzdGFydDogaW5kZXhcbiAgICAgICAgfTtcbiAgICAgICAgYWR2YW5jZShzdGFydFswXS5sZW5ndGgpO1xuICAgICAgICB2YXIgZW5kLCBhdHRyO1xuICAgICAgICB3aGlsZSAoIShlbmQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnQ2xvc2UpKSAmJiAoYXR0ciA9IGh0bWwubWF0Y2goZHluYW1pY0FyZ0F0dHJpYnV0ZSkgfHwgaHRtbC5tYXRjaChhdHRyaWJ1dGUpKSkge1xuICAgICAgICAgIGF0dHIuc3RhcnQgPSBpbmRleDtcbiAgICAgICAgICBhZHZhbmNlKGF0dHJbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBhdHRyLmVuZCA9IGluZGV4O1xuICAgICAgICAgIG1hdGNoLmF0dHJzLnB1c2goYXR0cik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCkge1xuICAgICAgICAgIG1hdGNoLnVuYXJ5U2xhc2ggPSBlbmRbMV07XG4gICAgICAgICAgYWR2YW5jZShlbmRbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBtYXRjaC5lbmQgPSBpbmRleDtcbiAgICAgICAgICByZXR1cm4gbWF0Y2hcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZVN0YXJ0VGFnIChtYXRjaCkge1xuICAgICAgdmFyIHRhZ05hbWUgPSBtYXRjaC50YWdOYW1lO1xuICAgICAgdmFyIHVuYXJ5U2xhc2ggPSBtYXRjaC51bmFyeVNsYXNoO1xuXG4gICAgICBpZiAoZXhwZWN0SFRNTCkge1xuICAgICAgICBpZiAobGFzdFRhZyA9PT0gJ3AnICYmIGlzTm9uUGhyYXNpbmdUYWcodGFnTmFtZSkpIHtcbiAgICAgICAgICBwYXJzZUVuZFRhZyhsYXN0VGFnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FuQmVMZWZ0T3BlblRhZyQkMSh0YWdOYW1lKSAmJiBsYXN0VGFnID09PSB0YWdOYW1lKSB7XG4gICAgICAgICAgcGFyc2VFbmRUYWcodGFnTmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHVuYXJ5ID0gaXNVbmFyeVRhZyQkMSh0YWdOYW1lKSB8fCAhIXVuYXJ5U2xhc2g7XG5cbiAgICAgIHZhciBsID0gbWF0Y2guYXR0cnMubGVuZ3RoO1xuICAgICAgdmFyIGF0dHJzID0gbmV3IEFycmF5KGwpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBtYXRjaC5hdHRyc1tpXTtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJnc1szXSB8fCBhcmdzWzRdIHx8IGFyZ3NbNV0gfHwgJyc7XG4gICAgICAgIHZhciBzaG91bGREZWNvZGVOZXdsaW5lcyA9IHRhZ05hbWUgPT09ICdhJyAmJiBhcmdzWzFdID09PSAnaHJlZidcbiAgICAgICAgICA/IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmXG4gICAgICAgICAgOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzO1xuICAgICAgICBhdHRyc1tpXSA9IHtcbiAgICAgICAgICBuYW1lOiBhcmdzWzFdLFxuICAgICAgICAgIHZhbHVlOiBkZWNvZGVBdHRyKHZhbHVlLCBzaG91bGREZWNvZGVOZXdsaW5lcylcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICBhdHRyc1tpXS5zdGFydCA9IGFyZ3Muc3RhcnQgKyBhcmdzWzBdLm1hdGNoKC9eXFxzKi8pLmxlbmd0aDtcbiAgICAgICAgICBhdHRyc1tpXS5lbmQgPSBhcmdzLmVuZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXVuYXJ5KSB7XG4gICAgICAgIHN0YWNrLnB1c2goeyB0YWc6IHRhZ05hbWUsIGxvd2VyQ2FzZWRUYWc6IHRhZ05hbWUudG9Mb3dlckNhc2UoKSwgYXR0cnM6IGF0dHJzLCBzdGFydDogbWF0Y2guc3RhcnQsIGVuZDogbWF0Y2guZW5kIH0pO1xuICAgICAgICBsYXN0VGFnID0gdGFnTmFtZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBhdHRycywgdW5hcnksIG1hdGNoLnN0YXJ0LCBtYXRjaC5lbmQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlRW5kVGFnICh0YWdOYW1lLCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgcG9zLCBsb3dlckNhc2VkVGFnTmFtZTtcbiAgICAgIGlmIChzdGFydCA9PSBudWxsKSB7IHN0YXJ0ID0gaW5kZXg7IH1cbiAgICAgIGlmIChlbmQgPT0gbnVsbCkgeyBlbmQgPSBpbmRleDsgfVxuXG4gICAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IG9wZW5lZCB0YWcgb2YgdGhlIHNhbWUgdHlwZVxuICAgICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgICAgbG93ZXJDYXNlZFRhZ05hbWUgPSB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGZvciAocG9zID0gc3RhY2subGVuZ3RoIC0gMTsgcG9zID49IDA7IHBvcy0tKSB7XG4gICAgICAgICAgaWYgKHN0YWNrW3Bvc10ubG93ZXJDYXNlZFRhZyA9PT0gbG93ZXJDYXNlZFRhZ05hbWUpIHtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiBubyB0YWcgbmFtZSBpcyBwcm92aWRlZCwgY2xlYW4gc2hvcFxuICAgICAgICBwb3MgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAocG9zID49IDApIHtcbiAgICAgICAgLy8gQ2xvc2UgYWxsIHRoZSBvcGVuIGVsZW1lbnRzLCB1cCB0aGUgc3RhY2tcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gcG9zOyBpLS0pIHtcbiAgICAgICAgICBpZiAoaSA+IHBvcyB8fCAhdGFnTmFtZSAmJlxuICAgICAgICAgICAgb3B0aW9ucy53YXJuXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBvcHRpb25zLndhcm4oXG4gICAgICAgICAgICAgIChcInRhZyA8XCIgKyAoc3RhY2tbaV0udGFnKSArIFwiPiBoYXMgbm8gbWF0Y2hpbmcgZW5kIHRhZy5cIiksXG4gICAgICAgICAgICAgIHsgc3RhcnQ6IHN0YWNrW2ldLnN0YXJ0LCBlbmQ6IHN0YWNrW2ldLmVuZCB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZW5kKHN0YWNrW2ldLnRhZywgc3RhcnQsIGVuZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBvcGVuIGVsZW1lbnRzIGZyb20gdGhlIHN0YWNrXG4gICAgICAgIHN0YWNrLmxlbmd0aCA9IHBvcztcbiAgICAgICAgbGFzdFRhZyA9IHBvcyAmJiBzdGFja1twb3MgLSAxXS50YWc7XG4gICAgICB9IGVsc2UgaWYgKGxvd2VyQ2FzZWRUYWdOYW1lID09PSAnYnInKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBbXSwgdHJ1ZSwgc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobG93ZXJDYXNlZFRhZ05hbWUgPT09ICdwJykge1xuICAgICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgW10sIGZhbHNlLCBzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgICBvcHRpb25zLmVuZCh0YWdOYW1lLCBzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIHZhciBvblJFID0gL15AfF52LW9uOi87XG4gIHZhciBkaXJSRSA9IC9edi18XkB8XjovO1xuICB2YXIgZm9yQWxpYXNSRSA9IC8oW1xcc1xcU10qPylcXHMrKD86aW58b2YpXFxzKyhbXFxzXFxTXSopLztcbiAgdmFyIGZvckl0ZXJhdG9yUkUgPSAvLChbXixcXH1cXF1dKikoPzosKFteLFxcfVxcXV0qKSk/JC87XG4gIHZhciBzdHJpcFBhcmVuc1JFID0gL15cXCh8XFwpJC9nO1xuICB2YXIgZHluYW1pY0FyZ1JFID0gL15cXFsuKlxcXSQvO1xuXG4gIHZhciBhcmdSRSA9IC86KC4qKSQvO1xuICB2YXIgYmluZFJFID0gL146fF5cXC58XnYtYmluZDovO1xuICB2YXIgbW9kaWZpZXJSRSA9IC9cXC5bXi5cXF1dKyg/PVteXFxdXSokKS9nO1xuXG4gIHZhciBzbG90UkUgPSAvXnYtc2xvdCg6fCQpfF4jLztcblxuICB2YXIgbGluZUJyZWFrUkUgPSAvW1xcclxcbl0vO1xuICB2YXIgd2hpdGVzcGFjZVJFJDEgPSAvXFxzKy9nO1xuXG4gIHZhciBpbnZhbGlkQXR0cmlidXRlUkUgPSAvW1xcc1wiJzw+XFwvPV0vO1xuXG4gIHZhciBkZWNvZGVIVE1MQ2FjaGVkID0gY2FjaGVkKGhlLmRlY29kZSk7XG5cbiAgdmFyIGVtcHR5U2xvdFNjb3BlVG9rZW4gPSBcIl9lbXB0eV9cIjtcblxuICAvLyBjb25maWd1cmFibGUgc3RhdGVcbiAgdmFyIHdhcm4kMjtcbiAgdmFyIGRlbGltaXRlcnM7XG4gIHZhciB0cmFuc2Zvcm1zO1xuICB2YXIgcHJlVHJhbnNmb3JtcztcbiAgdmFyIHBvc3RUcmFuc2Zvcm1zO1xuICB2YXIgcGxhdGZvcm1Jc1ByZVRhZztcbiAgdmFyIHBsYXRmb3JtTXVzdFVzZVByb3A7XG4gIHZhciBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZTtcbiAgdmFyIG1heWJlQ29tcG9uZW50O1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFTVEVsZW1lbnQgKFxuICAgIHRhZyxcbiAgICBhdHRycyxcbiAgICBwYXJlbnRcbiAgKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IDEsXG4gICAgICB0YWc6IHRhZyxcbiAgICAgIGF0dHJzTGlzdDogYXR0cnMsXG4gICAgICBhdHRyc01hcDogbWFrZUF0dHJzTWFwKGF0dHJzKSxcbiAgICAgIHJhd0F0dHJzTWFwOiB7fSxcbiAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgY2hpbGRyZW46IFtdXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgSFRNTCBzdHJpbmcgdG8gQVNULlxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2UgKFxuICAgIHRlbXBsYXRlLFxuICAgIG9wdGlvbnNcbiAgKSB7XG4gICAgd2FybiQyID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuXG4gICAgcGxhdGZvcm1Jc1ByZVRhZyA9IG9wdGlvbnMuaXNQcmVUYWcgfHwgbm87XG4gICAgcGxhdGZvcm1NdXN0VXNlUHJvcCA9IG9wdGlvbnMubXVzdFVzZVByb3AgfHwgbm87XG4gICAgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UgPSBvcHRpb25zLmdldFRhZ05hbWVzcGFjZSB8fCBubztcbiAgICB2YXIgaXNSZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcbiAgICBtYXliZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gISFlbC5jb21wb25lbnQgfHwgIWlzUmVzZXJ2ZWRUYWcoZWwudGFnKTsgfTtcblxuICAgIHRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybU5vZGUnKTtcbiAgICBwcmVUcmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdwcmVUcmFuc2Zvcm1Ob2RlJyk7XG4gICAgcG9zdFRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3Bvc3RUcmFuc2Zvcm1Ob2RlJyk7XG5cbiAgICBkZWxpbWl0ZXJzID0gb3B0aW9ucy5kZWxpbWl0ZXJzO1xuXG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgdmFyIHByZXNlcnZlV2hpdGVzcGFjZSA9IG9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlICE9PSBmYWxzZTtcbiAgICB2YXIgd2hpdGVzcGFjZU9wdGlvbiA9IG9wdGlvbnMud2hpdGVzcGFjZTtcbiAgICB2YXIgcm9vdDtcbiAgICB2YXIgY3VycmVudFBhcmVudDtcbiAgICB2YXIgaW5WUHJlID0gZmFsc2U7XG4gICAgdmFyIGluUHJlID0gZmFsc2U7XG4gICAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuXG4gICAgZnVuY3Rpb24gd2Fybk9uY2UgKG1zZywgcmFuZ2UpIHtcbiAgICAgIGlmICghd2FybmVkKSB7XG4gICAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICAgIHdhcm4kMihtc2csIHJhbmdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9zZUVsZW1lbnQgKGVsZW1lbnQpIHtcbiAgICAgIHRyaW1FbmRpbmdXaGl0ZXNwYWNlKGVsZW1lbnQpO1xuICAgICAgaWYgKCFpblZQcmUgJiYgIWVsZW1lbnQucHJvY2Vzc2VkKSB7XG4gICAgICAgIGVsZW1lbnQgPSBwcm9jZXNzRWxlbWVudChlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIC8vIHRyZWUgbWFuYWdlbWVudFxuICAgICAgaWYgKCFzdGFjay5sZW5ndGggJiYgZWxlbWVudCAhPT0gcm9vdCkge1xuICAgICAgICAvLyBhbGxvdyByb290IGVsZW1lbnRzIHdpdGggdi1pZiwgdi1lbHNlLWlmIGFuZCB2LWVsc2VcbiAgICAgICAgaWYgKHJvb3QuaWYgJiYgKGVsZW1lbnQuZWxzZWlmIHx8IGVsZW1lbnQuZWxzZSkpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhlbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYWRkSWZDb25kaXRpb24ocm9vdCwge1xuICAgICAgICAgICAgZXhwOiBlbGVtZW50LmVsc2VpZixcbiAgICAgICAgICAgIGJsb2NrOiBlbGVtZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICBcIkNvbXBvbmVudCB0ZW1wbGF0ZSBzaG91bGQgY29udGFpbiBleGFjdGx5IG9uZSByb290IGVsZW1lbnQuIFwiICtcbiAgICAgICAgICAgIFwiSWYgeW91IGFyZSB1c2luZyB2LWlmIG9uIG11bHRpcGxlIGVsZW1lbnRzLCBcIiArXG4gICAgICAgICAgICBcInVzZSB2LWVsc2UtaWYgdG8gY2hhaW4gdGhlbSBpbnN0ZWFkLlwiLFxuICAgICAgICAgICAgeyBzdGFydDogZWxlbWVudC5zdGFydCB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRQYXJlbnQgJiYgIWVsZW1lbnQuZm9yYmlkZGVuKSB7XG4gICAgICAgIGlmIChlbGVtZW50LmVsc2VpZiB8fCBlbGVtZW50LmVsc2UpIHtcbiAgICAgICAgICBwcm9jZXNzSWZDb25kaXRpb25zKGVsZW1lbnQsIGN1cnJlbnRQYXJlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChlbGVtZW50LnNsb3RTY29wZSkge1xuICAgICAgICAgICAgLy8gc2NvcGVkIHNsb3RcbiAgICAgICAgICAgIC8vIGtlZXAgaXQgaW4gdGhlIGNoaWxkcmVuIGxpc3Qgc28gdGhhdCB2LWVsc2UoLWlmKSBjb25kaXRpb25zIGNhblxuICAgICAgICAgICAgLy8gZmluZCBpdCBhcyB0aGUgcHJldiBub2RlLlxuICAgICAgICAgICAgdmFyIG5hbWUgPSBlbGVtZW50LnNsb3RUYXJnZXQgfHwgJ1wiZGVmYXVsdFwiJ1xuICAgICAgICAgICAgOyhjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzIHx8IChjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzID0ge30pKVtuYW1lXSA9IGVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnJlbnRQYXJlbnQuY2hpbGRyZW4ucHVzaChlbGVtZW50KTtcbiAgICAgICAgICBlbGVtZW50LnBhcmVudCA9IGN1cnJlbnRQYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZmluYWwgY2hpbGRyZW4gY2xlYW51cFxuICAgICAgLy8gZmlsdGVyIG91dCBzY29wZWQgc2xvdHNcbiAgICAgIGVsZW1lbnQuY2hpbGRyZW4gPSBlbGVtZW50LmNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gIShjKS5zbG90U2NvcGU7IH0pO1xuICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHdoaXRlc3BhY2Ugbm9kZSBhZ2FpblxuICAgICAgdHJpbUVuZGluZ1doaXRlc3BhY2UoZWxlbWVudCk7XG5cbiAgICAgIC8vIGNoZWNrIHByZSBzdGF0ZVxuICAgICAgaWYgKGVsZW1lbnQucHJlKSB7XG4gICAgICAgIGluVlByZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICAgIGluUHJlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBhcHBseSBwb3N0LXRyYW5zZm9ybXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9zdFRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcG9zdFRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJpbUVuZGluZ1doaXRlc3BhY2UgKGVsKSB7XG4gICAgICAvLyByZW1vdmUgdHJhaWxpbmcgd2hpdGVzcGFjZSBub2RlXG4gICAgICBpZiAoIWluUHJlKSB7XG4gICAgICAgIHZhciBsYXN0Tm9kZTtcbiAgICAgICAgd2hpbGUgKFxuICAgICAgICAgIChsYXN0Tm9kZSA9IGVsLmNoaWxkcmVuW2VsLmNoaWxkcmVuLmxlbmd0aCAtIDFdKSAmJlxuICAgICAgICAgIGxhc3ROb2RlLnR5cGUgPT09IDMgJiZcbiAgICAgICAgICBsYXN0Tm9kZS50ZXh0ID09PSAnICdcbiAgICAgICAgKSB7XG4gICAgICAgICAgZWwuY2hpbGRyZW4ucG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja1Jvb3RDb25zdHJhaW50cyAoZWwpIHtcbiAgICAgIGlmIChlbC50YWcgPT09ICdzbG90JyB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgXCJDYW5ub3QgdXNlIDxcIiArIChlbC50YWcpICsgXCI+IGFzIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSBpdCBtYXkgXCIgK1xuICAgICAgICAgICdjb250YWluIG11bHRpcGxlIG5vZGVzLicsXG4gICAgICAgICAgeyBzdGFydDogZWwuc3RhcnQgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGVsLmF0dHJzTWFwLmhhc093blByb3BlcnR5KCd2LWZvcicpKSB7XG4gICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICdDYW5ub3QgdXNlIHYtZm9yIG9uIHN0YXRlZnVsIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSAnICtcbiAgICAgICAgICAnaXQgcmVuZGVycyBtdWx0aXBsZSBlbGVtZW50cy4nLFxuICAgICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LWZvciddXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcGFyc2VIVE1MKHRlbXBsYXRlLCB7XG4gICAgICB3YXJuOiB3YXJuJDIsXG4gICAgICBleHBlY3RIVE1MOiBvcHRpb25zLmV4cGVjdEhUTUwsXG4gICAgICBpc1VuYXJ5VGFnOiBvcHRpb25zLmlzVW5hcnlUYWcsXG4gICAgICBjYW5CZUxlZnRPcGVuVGFnOiBvcHRpb25zLmNhbkJlTGVmdE9wZW5UYWcsXG4gICAgICBzaG91bGREZWNvZGVOZXdsaW5lczogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICAgIHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZjogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYsXG4gICAgICBzaG91bGRLZWVwQ29tbWVudDogb3B0aW9ucy5jb21tZW50cyxcbiAgICAgIG91dHB1dFNvdXJjZVJhbmdlOiBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlLFxuICAgICAgc3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0ICh0YWcsIGF0dHJzLCB1bmFyeSwgc3RhcnQkMSwgZW5kKSB7XG4gICAgICAgIC8vIGNoZWNrIG5hbWVzcGFjZS5cbiAgICAgICAgLy8gaW5oZXJpdCBwYXJlbnQgbnMgaWYgdGhlcmUgaXMgb25lXG4gICAgICAgIHZhciBucyA9IChjdXJyZW50UGFyZW50ICYmIGN1cnJlbnRQYXJlbnQubnMpIHx8IHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlKHRhZyk7XG5cbiAgICAgICAgLy8gaGFuZGxlIElFIHN2ZyBidWdcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChpc0lFICYmIG5zID09PSAnc3ZnJykge1xuICAgICAgICAgIGF0dHJzID0gZ3VhcmRJRVNWR0J1ZyhhdHRycyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWxlbWVudCA9IGNyZWF0ZUFTVEVsZW1lbnQodGFnLCBhdHRycywgY3VycmVudFBhcmVudCk7XG4gICAgICAgIGlmIChucykge1xuICAgICAgICAgIGVsZW1lbnQubnMgPSBucztcbiAgICAgICAgfVxuXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgICAgZWxlbWVudC5zdGFydCA9IHN0YXJ0JDE7XG4gICAgICAgICAgICBlbGVtZW50LmVuZCA9IGVuZDtcbiAgICAgICAgICAgIGVsZW1lbnQucmF3QXR0cnNNYXAgPSBlbGVtZW50LmF0dHJzTGlzdC5yZWR1Y2UoZnVuY3Rpb24gKGN1bXVsYXRlZCwgYXR0cikge1xuICAgICAgICAgICAgICBjdW11bGF0ZWRbYXR0ci5uYW1lXSA9IGF0dHI7XG4gICAgICAgICAgICAgIHJldHVybiBjdW11bGF0ZWRcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICAgaWYgKGludmFsaWRBdHRyaWJ1dGVSRS50ZXN0KGF0dHIubmFtZSkpIHtcbiAgICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICAgIFwiSW52YWxpZCBkeW5hbWljIGFyZ3VtZW50IGV4cHJlc3Npb246IGF0dHJpYnV0ZSBuYW1lcyBjYW5ub3QgY29udGFpbiBcIiArXG4gICAgICAgICAgICAgICAgXCJzcGFjZXMsIHF1b3RlcywgPCwgPiwgLyBvciA9LlwiLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHN0YXJ0OiBhdHRyLnN0YXJ0ICsgYXR0ci5uYW1lLmluZGV4T2YoXCJbXCIpLFxuICAgICAgICAgICAgICAgICAgZW5kOiBhdHRyLnN0YXJ0ICsgYXR0ci5uYW1lLmxlbmd0aFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0ZvcmJpZGRlblRhZyhlbGVtZW50KSAmJiAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSkge1xuICAgICAgICAgIGVsZW1lbnQuZm9yYmlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAnVGVtcGxhdGVzIHNob3VsZCBvbmx5IGJlIHJlc3BvbnNpYmxlIGZvciBtYXBwaW5nIHRoZSBzdGF0ZSB0byB0aGUgJyArXG4gICAgICAgICAgICAnVUkuIEF2b2lkIHBsYWNpbmcgdGFncyB3aXRoIHNpZGUtZWZmZWN0cyBpbiB5b3VyIHRlbXBsYXRlcywgc3VjaCBhcyAnICtcbiAgICAgICAgICAgIFwiPFwiICsgdGFnICsgXCI+XCIgKyAnLCBhcyB0aGV5IHdpbGwgbm90IGJlIHBhcnNlZC4nLFxuICAgICAgICAgICAgeyBzdGFydDogZWxlbWVudC5zdGFydCB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFwcGx5IHByZS10cmFuc2Zvcm1zXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlVHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGVsZW1lbnQgPSBwcmVUcmFuc2Zvcm1zW2ldKGVsZW1lbnQsIG9wdGlvbnMpIHx8IGVsZW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWluVlByZSkge1xuICAgICAgICAgIHByb2Nlc3NQcmUoZWxlbWVudCk7XG4gICAgICAgICAgaWYgKGVsZW1lbnQucHJlKSB7XG4gICAgICAgICAgICBpblZQcmUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcbiAgICAgICAgICBpblByZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluVlByZSkge1xuICAgICAgICAgIHByb2Nlc3NSYXdBdHRycyhlbGVtZW50KTtcbiAgICAgICAgfSBlbHNlIGlmICghZWxlbWVudC5wcm9jZXNzZWQpIHtcbiAgICAgICAgICAvLyBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZXNcbiAgICAgICAgICBwcm9jZXNzRm9yKGVsZW1lbnQpO1xuICAgICAgICAgIHByb2Nlc3NJZihlbGVtZW50KTtcbiAgICAgICAgICBwcm9jZXNzT25jZShlbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcm9vdCkge1xuICAgICAgICAgIHJvb3QgPSBlbGVtZW50O1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKHJvb3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdW5hcnkpIHtcbiAgICAgICAgICBjdXJyZW50UGFyZW50ID0gZWxlbWVudDtcbiAgICAgICAgICBzdGFjay5wdXNoKGVsZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsb3NlRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZW5kOiBmdW5jdGlvbiBlbmQgKHRhZywgc3RhcnQsIGVuZCQxKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgIC8vIHBvcCBzdGFja1xuICAgICAgICBzdGFjay5sZW5ndGggLT0gMTtcbiAgICAgICAgY3VycmVudFBhcmVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgIGVsZW1lbnQuZW5kID0gZW5kJDE7XG4gICAgICAgIH1cbiAgICAgICAgY2xvc2VFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgfSxcblxuICAgICAgY2hhcnM6IGZ1bmN0aW9uIGNoYXJzICh0ZXh0LCBzdGFydCwgZW5kKSB7XG4gICAgICAgIGlmICghY3VycmVudFBhcmVudCkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0ZXh0ID09PSB0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgICAnQ29tcG9uZW50IHRlbXBsYXRlIHJlcXVpcmVzIGEgcm9vdCBlbGVtZW50LCByYXRoZXIgdGhhbiBqdXN0IHRleHQuJyxcbiAgICAgICAgICAgICAgICB7IHN0YXJ0OiBzdGFydCB9XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCh0ZXh0ID0gdGV4dC50cmltKCkpKSB7XG4gICAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAgIChcInRleHQgXFxcIlwiICsgdGV4dCArIFwiXFxcIiBvdXRzaWRlIHJvb3QgZWxlbWVudCB3aWxsIGJlIGlnbm9yZWQuXCIpLFxuICAgICAgICAgICAgICAgIHsgc3RhcnQ6IHN0YXJ0IH1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgLy8gSUUgdGV4dGFyZWEgcGxhY2Vob2xkZXIgYnVnXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoaXNJRSAmJlxuICAgICAgICAgIGN1cnJlbnRQYXJlbnQudGFnID09PSAndGV4dGFyZWEnICYmXG4gICAgICAgICAgY3VycmVudFBhcmVudC5hdHRyc01hcC5wbGFjZWhvbGRlciA9PT0gdGV4dFxuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hpbGRyZW4gPSBjdXJyZW50UGFyZW50LmNoaWxkcmVuO1xuICAgICAgICBpZiAoaW5QcmUgfHwgdGV4dC50cmltKCkpIHtcbiAgICAgICAgICB0ZXh0ID0gaXNUZXh0VGFnKGN1cnJlbnRQYXJlbnQpID8gdGV4dCA6IGRlY29kZUhUTUxDYWNoZWQodGV4dCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgIC8vIHJlbW92ZSB0aGUgd2hpdGVzcGFjZS1vbmx5IG5vZGUgcmlnaHQgYWZ0ZXIgYW4gb3BlbmluZyB0YWdcbiAgICAgICAgICB0ZXh0ID0gJyc7XG4gICAgICAgIH0gZWxzZSBpZiAod2hpdGVzcGFjZU9wdGlvbikge1xuICAgICAgICAgIGlmICh3aGl0ZXNwYWNlT3B0aW9uID09PSAnY29uZGVuc2UnKSB7XG4gICAgICAgICAgICAvLyBpbiBjb25kZW5zZSBtb2RlLCByZW1vdmUgdGhlIHdoaXRlc3BhY2Ugbm9kZSBpZiBpdCBjb250YWluc1xuICAgICAgICAgICAgLy8gbGluZSBicmVhaywgb3RoZXJ3aXNlIGNvbmRlbnNlIHRvIGEgc2luZ2xlIHNwYWNlXG4gICAgICAgICAgICB0ZXh0ID0gbGluZUJyZWFrUkUudGVzdCh0ZXh0KSA/ICcnIDogJyAnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXh0ID0gJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0ID0gcHJlc2VydmVXaGl0ZXNwYWNlID8gJyAnIDogJyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICBpZiAoIWluUHJlICYmIHdoaXRlc3BhY2VPcHRpb24gPT09ICdjb25kZW5zZScpIHtcbiAgICAgICAgICAgIC8vIGNvbmRlbnNlIGNvbnNlY3V0aXZlIHdoaXRlc3BhY2VzIGludG8gc2luZ2xlIHNwYWNlXG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKHdoaXRlc3BhY2VSRSQxLCAnICcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmVzO1xuICAgICAgICAgIHZhciBjaGlsZDtcbiAgICAgICAgICBpZiAoIWluVlByZSAmJiB0ZXh0ICE9PSAnICcgJiYgKHJlcyA9IHBhcnNlVGV4dCh0ZXh0LCBkZWxpbWl0ZXJzKSkpIHtcbiAgICAgICAgICAgIGNoaWxkID0ge1xuICAgICAgICAgICAgICB0eXBlOiAyLFxuICAgICAgICAgICAgICBleHByZXNzaW9uOiByZXMuZXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgdG9rZW5zOiByZXMudG9rZW5zLFxuICAgICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSBpZiAodGV4dCAhPT0gJyAnIHx8ICFjaGlsZHJlbi5sZW5ndGggfHwgY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0udGV4dCAhPT0gJyAnKSB7XG4gICAgICAgICAgICBjaGlsZCA9IHtcbiAgICAgICAgICAgICAgdHlwZTogMyxcbiAgICAgICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgICAgICBjaGlsZC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgICBjaGlsZC5lbmQgPSBlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjb21tZW50OiBmdW5jdGlvbiBjb21tZW50ICh0ZXh0LCBzdGFydCwgZW5kKSB7XG4gICAgICAgIC8vIGFkZGluZyBhbnl0aW5nIGFzIGEgc2libGluZyB0byB0aGUgcm9vdCBub2RlIGlzIGZvcmJpZGRlblxuICAgICAgICAvLyBjb21tZW50cyBzaG91bGQgc3RpbGwgYmUgYWxsb3dlZCwgYnV0IGlnbm9yZWRcbiAgICAgICAgaWYgKGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgICB2YXIgY2hpbGQgPSB7XG4gICAgICAgICAgICB0eXBlOiAzLFxuICAgICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICAgIGlzQ29tbWVudDogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICAgIGNoaWxkLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICBjaGlsZC5lbmQgPSBlbmQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnJlbnRQYXJlbnQuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcm9vdFxuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc1ByZSAoZWwpIHtcbiAgICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtcHJlJykgIT0gbnVsbCkge1xuICAgICAgZWwucHJlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzUmF3QXR0cnMgKGVsKSB7XG4gICAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gICAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICAgIGlmIChsZW4pIHtcbiAgICAgIHZhciBhdHRycyA9IGVsLmF0dHJzID0gbmV3IEFycmF5KGxlbik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICAgIG5hbWU6IGxpc3RbaV0ubmFtZSxcbiAgICAgICAgICB2YWx1ZTogSlNPTi5zdHJpbmdpZnkobGlzdFtpXS52YWx1ZSlcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGxpc3RbaV0uc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICAgIGF0dHJzW2ldLnN0YXJ0ID0gbGlzdFtpXS5zdGFydDtcbiAgICAgICAgICBhdHRyc1tpXS5lbmQgPSBsaXN0W2ldLmVuZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWVsLnByZSkge1xuICAgICAgLy8gbm9uIHJvb3Qgbm9kZSBpbiBwcmUgYmxvY2tzIHdpdGggbm8gYXR0cmlidXRlc1xuICAgICAgZWwucGxhaW4gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NFbGVtZW50IChcbiAgICBlbGVtZW50LFxuICAgIG9wdGlvbnNcbiAgKSB7XG4gICAgcHJvY2Vzc0tleShlbGVtZW50KTtcblxuICAgIC8vIGRldGVybWluZSB3aGV0aGVyIHRoaXMgaXMgYSBwbGFpbiBlbGVtZW50IGFmdGVyXG4gICAgLy8gcmVtb3Zpbmcgc3RydWN0dXJhbCBhdHRyaWJ1dGVzXG4gICAgZWxlbWVudC5wbGFpbiA9IChcbiAgICAgICFlbGVtZW50LmtleSAmJlxuICAgICAgIWVsZW1lbnQuc2NvcGVkU2xvdHMgJiZcbiAgICAgICFlbGVtZW50LmF0dHJzTGlzdC5sZW5ndGhcbiAgICApO1xuXG4gICAgcHJvY2Vzc1JlZihlbGVtZW50KTtcbiAgICBwcm9jZXNzU2xvdENvbnRlbnQoZWxlbWVudCk7XG4gICAgcHJvY2Vzc1Nsb3RPdXRsZXQoZWxlbWVudCk7XG4gICAgcHJvY2Vzc0NvbXBvbmVudChlbGVtZW50KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGVsZW1lbnQgPSB0cmFuc2Zvcm1zW2ldKGVsZW1lbnQsIG9wdGlvbnMpIHx8IGVsZW1lbnQ7XG4gICAgfVxuICAgIHByb2Nlc3NBdHRycyhlbGVtZW50KTtcbiAgICByZXR1cm4gZWxlbWVudFxuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc0tleSAoZWwpIHtcbiAgICB2YXIgZXhwID0gZ2V0QmluZGluZ0F0dHIoZWwsICdrZXknKTtcbiAgICBpZiAoZXhwKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICBcIjx0ZW1wbGF0ZT4gY2Fubm90IGJlIGtleWVkLiBQbGFjZSB0aGUga2V5IG9uIHJlYWwgZWxlbWVudHMgaW5zdGVhZC5cIixcbiAgICAgICAgICAgIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAna2V5JylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbC5mb3IpIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBlbC5pdGVyYXRvcjIgfHwgZWwuaXRlcmF0b3IxO1xuICAgICAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnQ7XG4gICAgICAgICAgaWYgKGl0ZXJhdG9yICYmIGl0ZXJhdG9yID09PSBleHAgJiYgcGFyZW50ICYmIHBhcmVudC50YWcgPT09ICd0cmFuc2l0aW9uLWdyb3VwJykge1xuICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICBcIkRvIG5vdCB1c2Ugdi1mb3IgaW5kZXggYXMga2V5IG9uIDx0cmFuc2l0aW9uLWdyb3VwPiBjaGlsZHJlbiwgXCIgK1xuICAgICAgICAgICAgICBcInRoaXMgaXMgdGhlIHNhbWUgYXMgbm90IHVzaW5nIGtleXMuXCIsXG4gICAgICAgICAgICAgIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAna2V5JyksXG4gICAgICAgICAgICAgIHRydWUgLyogdGlwICovXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWwua2V5ID0gZXhwO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NSZWYgKGVsKSB7XG4gICAgdmFyIHJlZiA9IGdldEJpbmRpbmdBdHRyKGVsLCAncmVmJyk7XG4gICAgaWYgKHJlZikge1xuICAgICAgZWwucmVmID0gcmVmO1xuICAgICAgZWwucmVmSW5Gb3IgPSBjaGVja0luRm9yKGVsKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzRm9yIChlbCkge1xuICAgIHZhciBleHA7XG4gICAgaWYgKChleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1mb3InKSkpIHtcbiAgICAgIHZhciByZXMgPSBwYXJzZUZvcihleHApO1xuICAgICAgaWYgKHJlcykge1xuICAgICAgICBleHRlbmQoZWwsIHJlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgKFwiSW52YWxpZCB2LWZvciBleHByZXNzaW9uOiBcIiArIGV4cCksXG4gICAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtZm9yJ11cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuXG5cbiAgZnVuY3Rpb24gcGFyc2VGb3IgKGV4cCkge1xuICAgIHZhciBpbk1hdGNoID0gZXhwLm1hdGNoKGZvckFsaWFzUkUpO1xuICAgIGlmICghaW5NYXRjaCkgeyByZXR1cm4gfVxuICAgIHZhciByZXMgPSB7fTtcbiAgICByZXMuZm9yID0gaW5NYXRjaFsyXS50cmltKCk7XG4gICAgdmFyIGFsaWFzID0gaW5NYXRjaFsxXS50cmltKCkucmVwbGFjZShzdHJpcFBhcmVuc1JFLCAnJyk7XG4gICAgdmFyIGl0ZXJhdG9yTWF0Y2ggPSBhbGlhcy5tYXRjaChmb3JJdGVyYXRvclJFKTtcbiAgICBpZiAoaXRlcmF0b3JNYXRjaCkge1xuICAgICAgcmVzLmFsaWFzID0gYWxpYXMucmVwbGFjZShmb3JJdGVyYXRvclJFLCAnJykudHJpbSgpO1xuICAgICAgcmVzLml0ZXJhdG9yMSA9IGl0ZXJhdG9yTWF0Y2hbMV0udHJpbSgpO1xuICAgICAgaWYgKGl0ZXJhdG9yTWF0Y2hbMl0pIHtcbiAgICAgICAgcmVzLml0ZXJhdG9yMiA9IGl0ZXJhdG9yTWF0Y2hbMl0udHJpbSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXMuYWxpYXMgPSBhbGlhcztcbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc0lmIChlbCkge1xuICAgIHZhciBleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1pZicpO1xuICAgIGlmIChleHApIHtcbiAgICAgIGVsLmlmID0gZXhwO1xuICAgICAgYWRkSWZDb25kaXRpb24oZWwsIHtcbiAgICAgICAgZXhwOiBleHAsXG4gICAgICAgIGJsb2NrOiBlbFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlJykgIT0gbnVsbCkge1xuICAgICAgICBlbC5lbHNlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBlbHNlaWYgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlLWlmJyk7XG4gICAgICBpZiAoZWxzZWlmKSB7XG4gICAgICAgIGVsLmVsc2VpZiA9IGVsc2VpZjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzSWZDb25kaXRpb25zIChlbCwgcGFyZW50KSB7XG4gICAgdmFyIHByZXYgPSBmaW5kUHJldkVsZW1lbnQocGFyZW50LmNoaWxkcmVuKTtcbiAgICBpZiAocHJldiAmJiBwcmV2LmlmKSB7XG4gICAgICBhZGRJZkNvbmRpdGlvbihwcmV2LCB7XG4gICAgICAgIGV4cDogZWwuZWxzZWlmLFxuICAgICAgICBibG9jazogZWxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIFwidi1cIiArIChlbC5lbHNlaWYgPyAoJ2Vsc2UtaWY9XCInICsgZWwuZWxzZWlmICsgJ1wiJykgOiAnZWxzZScpICsgXCIgXCIgK1xuICAgICAgICBcInVzZWQgb24gZWxlbWVudCA8XCIgKyAoZWwudGFnKSArIFwiPiB3aXRob3V0IGNvcnJlc3BvbmRpbmcgdi1pZi5cIixcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbZWwuZWxzZWlmID8gJ3YtZWxzZS1pZicgOiAndi1lbHNlJ11cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmluZFByZXZFbGVtZW50IChjaGlsZHJlbikge1xuICAgIHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGlmIChjaGlsZHJlbltpXS50eXBlID09PSAxKSB7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbltpXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNoaWxkcmVuW2ldLnRleHQgIT09ICcgJykge1xuICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgIFwidGV4dCBcXFwiXCIgKyAoY2hpbGRyZW5baV0udGV4dC50cmltKCkpICsgXCJcXFwiIGJldHdlZW4gdi1pZiBhbmQgdi1lbHNlKC1pZikgXCIgK1xuICAgICAgICAgICAgXCJ3aWxsIGJlIGlnbm9yZWQuXCIsXG4gICAgICAgICAgICBjaGlsZHJlbltpXVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRyZW4ucG9wKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkSWZDb25kaXRpb24gKGVsLCBjb25kaXRpb24pIHtcbiAgICBpZiAoIWVsLmlmQ29uZGl0aW9ucykge1xuICAgICAgZWwuaWZDb25kaXRpb25zID0gW107XG4gICAgfVxuICAgIGVsLmlmQ29uZGl0aW9ucy5wdXNoKGNvbmRpdGlvbik7XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzT25jZSAoZWwpIHtcbiAgICB2YXIgb25jZSQkMSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LW9uY2UnKTtcbiAgICBpZiAob25jZSQkMSAhPSBudWxsKSB7XG4gICAgICBlbC5vbmNlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBoYW5kbGUgY29udGVudCBiZWluZyBwYXNzZWQgdG8gYSBjb21wb25lbnQgYXMgc2xvdCxcbiAgLy8gZS5nLiA8dGVtcGxhdGUgc2xvdD1cInh4eFwiPiwgPGRpdiBzbG90LXNjb3BlPVwieHh4XCI+XG4gIGZ1bmN0aW9uIHByb2Nlc3NTbG90Q29udGVudCAoZWwpIHtcbiAgICB2YXIgc2xvdFNjb3BlO1xuICAgIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIHNsb3RTY29wZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzY29wZScpO1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoc2xvdFNjb3BlKSB7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICBcInRoZSBcXFwic2NvcGVcXFwiIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIHNsb3RzIGhhdmUgYmVlbiBkZXByZWNhdGVkIGFuZCBcIiArXG4gICAgICAgICAgXCJyZXBsYWNlZCBieSBcXFwic2xvdC1zY29wZVxcXCIgc2luY2UgMi41LiBUaGUgbmV3IFxcXCJzbG90LXNjb3BlXFxcIiBhdHRyaWJ1dGUgXCIgK1xuICAgICAgICAgIFwiY2FuIGFsc28gYmUgdXNlZCBvbiBwbGFpbiBlbGVtZW50cyBpbiBhZGRpdGlvbiB0byA8dGVtcGxhdGU+IHRvIFwiICtcbiAgICAgICAgICBcImRlbm90ZSBzY29wZWQgc2xvdHMuXCIsXG4gICAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3Njb3BlJ10sXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZWwuc2xvdFNjb3BlID0gc2xvdFNjb3BlIHx8IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzbG90LXNjb3BlJyk7XG4gICAgfSBlbHNlIGlmICgoc2xvdFNjb3BlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Nsb3Qtc2NvcGUnKSkpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGVsLmF0dHJzTWFwWyd2LWZvciddKSB7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICBcIkFtYmlndW91cyBjb21iaW5lZCB1c2FnZSBvZiBzbG90LXNjb3BlIGFuZCB2LWZvciBvbiA8XCIgKyAoZWwudGFnKSArIFwiPiBcIiArXG4gICAgICAgICAgXCIodi1mb3IgdGFrZXMgaGlnaGVyIHByaW9yaXR5KS4gVXNlIGEgd3JhcHBlciA8dGVtcGxhdGU+IGZvciB0aGUgXCIgK1xuICAgICAgICAgIFwic2NvcGVkIHNsb3QgdG8gbWFrZSBpdCBjbGVhcmVyLlwiLFxuICAgICAgICAgIGVsLnJhd0F0dHJzTWFwWydzbG90LXNjb3BlJ10sXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZWwuc2xvdFNjb3BlID0gc2xvdFNjb3BlO1xuICAgIH1cblxuICAgIC8vIHNsb3Q9XCJ4eHhcIlxuICAgIHZhciBzbG90VGFyZ2V0ID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzbG90Jyk7XG4gICAgaWYgKHNsb3RUYXJnZXQpIHtcbiAgICAgIGVsLnNsb3RUYXJnZXQgPSBzbG90VGFyZ2V0ID09PSAnXCJcIicgPyAnXCJkZWZhdWx0XCInIDogc2xvdFRhcmdldDtcbiAgICAgIGVsLnNsb3RUYXJnZXREeW5hbWljID0gISEoZWwuYXR0cnNNYXBbJzpzbG90J10gfHwgZWwuYXR0cnNNYXBbJ3YtYmluZDpzbG90J10pO1xuICAgICAgLy8gcHJlc2VydmUgc2xvdCBhcyBhbiBhdHRyaWJ1dGUgZm9yIG5hdGl2ZSBzaGFkb3cgRE9NIGNvbXBhdFxuICAgICAgLy8gb25seSBmb3Igbm9uLXNjb3BlZCBzbG90cy5cbiAgICAgIGlmIChlbC50YWcgIT09ICd0ZW1wbGF0ZScgJiYgIWVsLnNsb3RTY29wZSkge1xuICAgICAgICBhZGRBdHRyKGVsLCAnc2xvdCcsIHNsb3RUYXJnZXQsIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAnc2xvdCcpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAyLjYgdi1zbG90IHN5bnRheFxuICAgIHtcbiAgICAgIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgLy8gdi1zbG90IG9uIDx0ZW1wbGF0ZT5cbiAgICAgICAgdmFyIHNsb3RCaW5kaW5nID0gZ2V0QW5kUmVtb3ZlQXR0ckJ5UmVnZXgoZWwsIHNsb3RSRSk7XG4gICAgICAgIGlmIChzbG90QmluZGluZykge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChlbC5zbG90VGFyZ2V0IHx8IGVsLnNsb3RTY29wZSkge1xuICAgICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgICAgXCJVbmV4cGVjdGVkIG1peGVkIHVzYWdlIG9mIGRpZmZlcmVudCBzbG90IHN5bnRheGVzLlwiLFxuICAgICAgICAgICAgICAgIGVsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZWwucGFyZW50ICYmICFtYXliZUNvbXBvbmVudChlbC5wYXJlbnQpKSB7XG4gICAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgICBcIjx0ZW1wbGF0ZSB2LXNsb3Q+IGNhbiBvbmx5IGFwcGVhciBhdCB0aGUgcm9vdCBsZXZlbCBpbnNpZGUgXCIgK1xuICAgICAgICAgICAgICAgIFwidGhlIHJlY2VpdmluZyB0aGUgY29tcG9uZW50XCIsXG4gICAgICAgICAgICAgICAgZWxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJlZiA9IGdldFNsb3ROYW1lKHNsb3RCaW5kaW5nKTtcbiAgICAgICAgICB2YXIgbmFtZSA9IHJlZi5uYW1lO1xuICAgICAgICAgIHZhciBkeW5hbWljID0gcmVmLmR5bmFtaWM7XG4gICAgICAgICAgZWwuc2xvdFRhcmdldCA9IG5hbWU7XG4gICAgICAgICAgZWwuc2xvdFRhcmdldER5bmFtaWMgPSBkeW5hbWljO1xuICAgICAgICAgIGVsLnNsb3RTY29wZSA9IHNsb3RCaW5kaW5nLnZhbHVlIHx8IGVtcHR5U2xvdFNjb3BlVG9rZW47IC8vIGZvcmNlIGl0IGludG8gYSBzY29wZWQgc2xvdCBmb3IgcGVyZlxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB2LXNsb3Qgb24gY29tcG9uZW50LCBkZW5vdGVzIGRlZmF1bHQgc2xvdFxuICAgICAgICB2YXIgc2xvdEJpbmRpbmckMSA9IGdldEFuZFJlbW92ZUF0dHJCeVJlZ2V4KGVsLCBzbG90UkUpO1xuICAgICAgICBpZiAoc2xvdEJpbmRpbmckMSkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICghbWF5YmVDb21wb25lbnQoZWwpKSB7XG4gICAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgICBcInYtc2xvdCBjYW4gb25seSBiZSB1c2VkIG9uIGNvbXBvbmVudHMgb3IgPHRlbXBsYXRlPi5cIixcbiAgICAgICAgICAgICAgICBzbG90QmluZGluZyQxXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZWwuc2xvdFNjb3BlIHx8IGVsLnNsb3RUYXJnZXQpIHtcbiAgICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICAgIFwiVW5leHBlY3RlZCBtaXhlZCB1c2FnZSBvZiBkaWZmZXJlbnQgc2xvdCBzeW50YXhlcy5cIixcbiAgICAgICAgICAgICAgICBlbFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVsLnNjb3BlZFNsb3RzKSB7XG4gICAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgICBcIlRvIGF2b2lkIHNjb3BlIGFtYmlndWl0eSwgdGhlIGRlZmF1bHQgc2xvdCBzaG91bGQgYWxzbyB1c2UgXCIgK1xuICAgICAgICAgICAgICAgIFwiPHRlbXBsYXRlPiBzeW50YXggd2hlbiB0aGVyZSBhcmUgb3RoZXIgbmFtZWQgc2xvdHMuXCIsXG4gICAgICAgICAgICAgICAgc2xvdEJpbmRpbmckMVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBhZGQgdGhlIGNvbXBvbmVudCdzIGNoaWxkcmVuIHRvIGl0cyBkZWZhdWx0IHNsb3RcbiAgICAgICAgICB2YXIgc2xvdHMgPSBlbC5zY29wZWRTbG90cyB8fCAoZWwuc2NvcGVkU2xvdHMgPSB7fSk7XG4gICAgICAgICAgdmFyIHJlZiQxID0gZ2V0U2xvdE5hbWUoc2xvdEJpbmRpbmckMSk7XG4gICAgICAgICAgdmFyIG5hbWUkMSA9IHJlZiQxLm5hbWU7XG4gICAgICAgICAgdmFyIGR5bmFtaWMkMSA9IHJlZiQxLmR5bmFtaWM7XG4gICAgICAgICAgdmFyIHNsb3RDb250YWluZXIgPSBzbG90c1tuYW1lJDFdID0gY3JlYXRlQVNURWxlbWVudCgndGVtcGxhdGUnLCBbXSwgZWwpO1xuICAgICAgICAgIHNsb3RDb250YWluZXIuc2xvdFRhcmdldCA9IG5hbWUkMTtcbiAgICAgICAgICBzbG90Q29udGFpbmVyLnNsb3RUYXJnZXREeW5hbWljID0gZHluYW1pYyQxO1xuICAgICAgICAgIHNsb3RDb250YWluZXIuY2hpbGRyZW4gPSBlbC5jaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIGlmICghYy5zbG90U2NvcGUpIHtcbiAgICAgICAgICAgICAgYy5wYXJlbnQgPSBzbG90Q29udGFpbmVyO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNsb3RDb250YWluZXIuc2xvdFNjb3BlID0gc2xvdEJpbmRpbmckMS52YWx1ZSB8fCBlbXB0eVNsb3RTY29wZVRva2VuO1xuICAgICAgICAgIC8vIHJlbW92ZSBjaGlsZHJlbiBhcyB0aGV5IGFyZSByZXR1cm5lZCBmcm9tIHNjb3BlZFNsb3RzIG5vd1xuICAgICAgICAgIGVsLmNoaWxkcmVuID0gW107XG4gICAgICAgICAgLy8gbWFyayBlbCBub24tcGxhaW4gc28gZGF0YSBnZXRzIGdlbmVyYXRlZFxuICAgICAgICAgIGVsLnBsYWluID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRTbG90TmFtZSAoYmluZGluZykge1xuICAgIHZhciBuYW1lID0gYmluZGluZy5uYW1lLnJlcGxhY2Uoc2xvdFJFLCAnJyk7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICBpZiAoYmluZGluZy5uYW1lWzBdICE9PSAnIycpIHtcbiAgICAgICAgbmFtZSA9ICdkZWZhdWx0JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICBcInYtc2xvdCBzaG9ydGhhbmQgc3ludGF4IHJlcXVpcmVzIGEgc2xvdCBuYW1lLlwiLFxuICAgICAgICAgIGJpbmRpbmdcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGR5bmFtaWNBcmdSRS50ZXN0KG5hbWUpXG4gICAgICAvLyBkeW5hbWljIFtuYW1lXVxuICAgICAgPyB7IG5hbWU6IG5hbWUuc2xpY2UoMSwgLTEpLCBkeW5hbWljOiB0cnVlIH1cbiAgICAgIC8vIHN0YXRpYyBuYW1lXG4gICAgICA6IHsgbmFtZTogKFwiXFxcIlwiICsgbmFtZSArIFwiXFxcIlwiKSwgZHluYW1pYzogZmFsc2UgfVxuICB9XG5cbiAgLy8gaGFuZGxlIDxzbG90Lz4gb3V0bGV0c1xuICBmdW5jdGlvbiBwcm9jZXNzU2xvdE91dGxldCAoZWwpIHtcbiAgICBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICAgIGVsLnNsb3ROYW1lID0gZ2V0QmluZGluZ0F0dHIoZWwsICduYW1lJyk7XG4gICAgICBpZiAoZWwua2V5KSB7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICBcImBrZXlgIGRvZXMgbm90IHdvcmsgb24gPHNsb3Q+IGJlY2F1c2Ugc2xvdHMgYXJlIGFic3RyYWN0IG91dGxldHMgXCIgK1xuICAgICAgICAgIFwiYW5kIGNhbiBwb3NzaWJseSBleHBhbmQgaW50byBtdWx0aXBsZSBlbGVtZW50cy4gXCIgK1xuICAgICAgICAgIFwiVXNlIHRoZSBrZXkgb24gYSB3cmFwcGluZyBlbGVtZW50IGluc3RlYWQuXCIsXG4gICAgICAgICAgZ2V0UmF3QmluZGluZ0F0dHIoZWwsICdrZXknKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NDb21wb25lbnQgKGVsKSB7XG4gICAgdmFyIGJpbmRpbmc7XG4gICAgaWYgKChiaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdpcycpKSkge1xuICAgICAgZWwuY29tcG9uZW50ID0gYmluZGluZztcbiAgICB9XG4gICAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICdpbmxpbmUtdGVtcGxhdGUnKSAhPSBudWxsKSB7XG4gICAgICBlbC5pbmxpbmVUZW1wbGF0ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc0F0dHJzIChlbCkge1xuICAgIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICAgIHZhciBpLCBsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBzeW5jR2VuLCBpc0R5bmFtaWM7XG4gICAgZm9yIChpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBuYW1lID0gcmF3TmFtZSA9IGxpc3RbaV0ubmFtZTtcbiAgICAgIHZhbHVlID0gbGlzdFtpXS52YWx1ZTtcbiAgICAgIGlmIChkaXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIC8vIG1hcmsgZWxlbWVudCBhcyBkeW5hbWljXG4gICAgICAgIGVsLmhhc0JpbmRpbmdzID0gdHJ1ZTtcbiAgICAgICAgLy8gbW9kaWZpZXJzXG4gICAgICAgIG1vZGlmaWVycyA9IHBhcnNlTW9kaWZpZXJzKG5hbWUucmVwbGFjZShkaXJSRSwgJycpKTtcbiAgICAgICAgLy8gc3VwcG9ydCAuZm9vIHNob3J0aGFuZCBzeW50YXggZm9yIHRoZSAucHJvcCBtb2RpZmllclxuICAgICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShtb2RpZmllclJFLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJpbmRSRS50ZXN0KG5hbWUpKSB7IC8vIHYtYmluZFxuICAgICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoYmluZFJFLCAnJyk7XG4gICAgICAgICAgdmFsdWUgPSBwYXJzZUZpbHRlcnModmFsdWUpO1xuICAgICAgICAgIGlzRHluYW1pYyA9IGR5bmFtaWNBcmdSRS50ZXN0KG5hbWUpO1xuICAgICAgICAgIGlmIChpc0R5bmFtaWMpIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdmFsdWUudHJpbSgpLmxlbmd0aCA9PT0gMFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICAoXCJUaGUgdmFsdWUgZm9yIGEgdi1iaW5kIGV4cHJlc3Npb24gY2Fubm90IGJlIGVtcHR5LiBGb3VuZCBpbiBcXFwidi1iaW5kOlwiICsgbmFtZSArIFwiXFxcIlwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgICAgaWYgKG1vZGlmaWVycy5wcm9wICYmICFpc0R5bmFtaWMpIHtcbiAgICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2lubmVySHRtbCcpIHsgbmFtZSA9ICdpbm5lckhUTUwnOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobW9kaWZpZXJzLmNhbWVsICYmICFpc0R5bmFtaWMpIHtcbiAgICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vZGlmaWVycy5zeW5jKSB7XG4gICAgICAgICAgICAgIHN5bmNHZW4gPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgXCIkZXZlbnRcIik7XG4gICAgICAgICAgICAgIGlmICghaXNEeW5hbWljKSB7XG4gICAgICAgICAgICAgICAgYWRkSGFuZGxlcihcbiAgICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgICAgKFwidXBkYXRlOlwiICsgKGNhbWVsaXplKG5hbWUpKSksXG4gICAgICAgICAgICAgICAgICBzeW5jR2VuLFxuICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgd2FybiQyLFxuICAgICAgICAgICAgICAgICAgbGlzdFtpXVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKGh5cGhlbmF0ZShuYW1lKSAhPT0gY2FtZWxpemUobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgIGFkZEhhbmRsZXIoXG4gICAgICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgICAgICAoXCJ1cGRhdGU6XCIgKyAoaHlwaGVuYXRlKG5hbWUpKSksXG4gICAgICAgICAgICAgICAgICAgIHN5bmNHZW4sXG4gICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB3YXJuJDIsXG4gICAgICAgICAgICAgICAgICAgIGxpc3RbaV1cbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGhhbmRsZXIgdy8gZHluYW1pYyBldmVudCBuYW1lXG4gICAgICAgICAgICAgICAgYWRkSGFuZGxlcihcbiAgICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgICAgKFwiXFxcInVwZGF0ZTpcXFwiKyhcIiArIG5hbWUgKyBcIilcIiksXG4gICAgICAgICAgICAgICAgICBzeW5jR2VuLFxuICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgd2FybiQyLFxuICAgICAgICAgICAgICAgICAgbGlzdFtpXSxcbiAgICAgICAgICAgICAgICAgIHRydWUgLy8gZHluYW1pY1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLnByb3ApIHx8IChcbiAgICAgICAgICAgICFlbC5jb21wb25lbnQgJiYgcGxhdGZvcm1NdXN0VXNlUHJvcChlbC50YWcsIGVsLmF0dHJzTWFwLnR5cGUsIG5hbWUpXG4gICAgICAgICAgKSkge1xuICAgICAgICAgICAgYWRkUHJvcChlbCwgbmFtZSwgdmFsdWUsIGxpc3RbaV0sIGlzRHluYW1pYyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIHZhbHVlLCBsaXN0W2ldLCBpc0R5bmFtaWMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChvblJFLnRlc3QobmFtZSkpIHsgLy8gdi1vblxuICAgICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2Uob25SRSwgJycpO1xuICAgICAgICAgIGlzRHluYW1pYyA9IGR5bmFtaWNBcmdSRS50ZXN0KG5hbWUpO1xuICAgICAgICAgIGlmIChpc0R5bmFtaWMpIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYWRkSGFuZGxlcihlbCwgbmFtZSwgdmFsdWUsIG1vZGlmaWVycywgZmFsc2UsIHdhcm4kMiwgbGlzdFtpXSwgaXNEeW5hbWljKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gbm9ybWFsIGRpcmVjdGl2ZXNcbiAgICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGRpclJFLCAnJyk7XG4gICAgICAgICAgLy8gcGFyc2UgYXJnXG4gICAgICAgICAgdmFyIGFyZ01hdGNoID0gbmFtZS5tYXRjaChhcmdSRSk7XG4gICAgICAgICAgdmFyIGFyZyA9IGFyZ01hdGNoICYmIGFyZ01hdGNoWzFdO1xuICAgICAgICAgIGlzRHluYW1pYyA9IGZhbHNlO1xuICAgICAgICAgIGlmIChhcmcpIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDAsIC0oYXJnLmxlbmd0aCArIDEpKTtcbiAgICAgICAgICAgIGlmIChkeW5hbWljQXJnUkUudGVzdChhcmcpKSB7XG4gICAgICAgICAgICAgIGFyZyA9IGFyZy5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgICAgIGlzRHluYW1pYyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGFkZERpcmVjdGl2ZShlbCwgbmFtZSwgcmF3TmFtZSwgdmFsdWUsIGFyZywgaXNEeW5hbWljLCBtb2RpZmllcnMsIGxpc3RbaV0pO1xuICAgICAgICAgIGlmIChuYW1lID09PSAnbW9kZWwnKSB7XG4gICAgICAgICAgICBjaGVja0ZvckFsaWFzTW9kZWwoZWwsIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGxpdGVyYWwgYXR0cmlidXRlXG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgcmVzID0gcGFyc2VUZXh0KHZhbHVlLCBkZWxpbWl0ZXJzKTtcbiAgICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIjogXCIgK1xuICAgICAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgaWQ9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDppZD1cInZhbFwiPi4nLFxuICAgICAgICAgICAgICBsaXN0W2ldXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhZGRBdHRyKGVsLCBuYW1lLCBKU09OLnN0cmluZ2lmeSh2YWx1ZSksIGxpc3RbaV0pO1xuICAgICAgICAvLyAjNjg4NyBmaXJlZm94IGRvZXNuJ3QgdXBkYXRlIG11dGVkIHN0YXRlIGlmIHNldCB2aWEgYXR0cmlidXRlXG4gICAgICAgIC8vIGV2ZW4gaW1tZWRpYXRlbHkgYWZ0ZXIgZWxlbWVudCBjcmVhdGlvblxuICAgICAgICBpZiAoIWVsLmNvbXBvbmVudCAmJlxuICAgICAgICAgICAgbmFtZSA9PT0gJ211dGVkJyAmJlxuICAgICAgICAgICAgcGxhdGZvcm1NdXN0VXNlUHJvcChlbC50YWcsIGVsLmF0dHJzTWFwLnR5cGUsIG5hbWUpKSB7XG4gICAgICAgICAgYWRkUHJvcChlbCwgbmFtZSwgJ3RydWUnLCBsaXN0W2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrSW5Gb3IgKGVsKSB7XG4gICAgdmFyIHBhcmVudCA9IGVsO1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQuZm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VNb2RpZmllcnMgKG5hbWUpIHtcbiAgICB2YXIgbWF0Y2ggPSBuYW1lLm1hdGNoKG1vZGlmaWVyUkUpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgdmFyIHJldCA9IHt9O1xuICAgICAgbWF0Y2guZm9yRWFjaChmdW5jdGlvbiAobSkgeyByZXRbbS5zbGljZSgxKV0gPSB0cnVlOyB9KTtcbiAgICAgIHJldHVybiByZXRcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlQXR0cnNNYXAgKGF0dHJzKSB7XG4gICAgdmFyIG1hcCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAoXG4gICAgICAgIG1hcFthdHRyc1tpXS5uYW1lXSAmJiAhaXNJRSAmJiAhaXNFZGdlXG4gICAgICApIHtcbiAgICAgICAgd2FybiQyKCdkdXBsaWNhdGUgYXR0cmlidXRlOiAnICsgYXR0cnNbaV0ubmFtZSwgYXR0cnNbaV0pO1xuICAgICAgfVxuICAgICAgbWFwW2F0dHJzW2ldLm5hbWVdID0gYXR0cnNbaV0udmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBtYXBcbiAgfVxuXG4gIC8vIGZvciBzY3JpcHQgKGUuZy4gdHlwZT1cIngvdGVtcGxhdGVcIikgb3Igc3R5bGUsIGRvIG5vdCBkZWNvZGUgY29udGVudFxuICBmdW5jdGlvbiBpc1RleHRUYWcgKGVsKSB7XG4gICAgcmV0dXJuIGVsLnRhZyA9PT0gJ3NjcmlwdCcgfHwgZWwudGFnID09PSAnc3R5bGUnXG4gIH1cblxuICBmdW5jdGlvbiBpc0ZvcmJpZGRlblRhZyAoZWwpIHtcbiAgICByZXR1cm4gKFxuICAgICAgZWwudGFnID09PSAnc3R5bGUnIHx8XG4gICAgICAoZWwudGFnID09PSAnc2NyaXB0JyAmJiAoXG4gICAgICAgICFlbC5hdHRyc01hcC50eXBlIHx8XG4gICAgICAgIGVsLmF0dHJzTWFwLnR5cGUgPT09ICd0ZXh0L2phdmFzY3JpcHQnXG4gICAgICApKVxuICAgIClcbiAgfVxuXG4gIHZhciBpZU5TQnVnID0gL154bWxuczpOU1xcZCsvO1xuICB2YXIgaWVOU1ByZWZpeCA9IC9eTlNcXGQrOi87XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZnVuY3Rpb24gZ3VhcmRJRVNWR0J1ZyAoYXR0cnMpIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGF0dHIgPSBhdHRyc1tpXTtcbiAgICAgIGlmICghaWVOU0J1Zy50ZXN0KGF0dHIubmFtZSkpIHtcbiAgICAgICAgYXR0ci5uYW1lID0gYXR0ci5uYW1lLnJlcGxhY2UoaWVOU1ByZWZpeCwgJycpO1xuICAgICAgICByZXMucHVzaChhdHRyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tGb3JBbGlhc01vZGVsIChlbCwgdmFsdWUpIHtcbiAgICB2YXIgX2VsID0gZWw7XG4gICAgd2hpbGUgKF9lbCkge1xuICAgICAgaWYgKF9lbC5mb3IgJiYgX2VsLmFsaWFzID09PSB2YWx1ZSkge1xuICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI+OiBcIiArXG4gICAgICAgICAgXCJZb3UgYXJlIGJpbmRpbmcgdi1tb2RlbCBkaXJlY3RseSB0byBhIHYtZm9yIGl0ZXJhdGlvbiBhbGlhcy4gXCIgK1xuICAgICAgICAgIFwiVGhpcyB3aWxsIG5vdCBiZSBhYmxlIHRvIG1vZGlmeSB0aGUgdi1mb3Igc291cmNlIGFycmF5IGJlY2F1c2UgXCIgK1xuICAgICAgICAgIFwid3JpdGluZyB0byB0aGUgYWxpYXMgaXMgbGlrZSBtb2RpZnlpbmcgYSBmdW5jdGlvbiBsb2NhbCB2YXJpYWJsZS4gXCIgK1xuICAgICAgICAgIFwiQ29uc2lkZXIgdXNpbmcgYW4gYXJyYXkgb2Ygb2JqZWN0cyBhbmQgdXNlIHYtbW9kZWwgb24gYW4gb2JqZWN0IHByb3BlcnR5IGluc3RlYWQuXCIsXG4gICAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtbW9kZWwnXVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgX2VsID0gX2VsLnBhcmVudDtcbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBwcmVUcmFuc2Zvcm1Ob2RlIChlbCwgb3B0aW9ucykge1xuICAgIGlmIChlbC50YWcgPT09ICdpbnB1dCcpIHtcbiAgICAgIHZhciBtYXAgPSBlbC5hdHRyc01hcDtcbiAgICAgIGlmICghbWFwWyd2LW1vZGVsJ10pIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHZhciB0eXBlQmluZGluZztcbiAgICAgIGlmIChtYXBbJzp0eXBlJ10gfHwgbWFwWyd2LWJpbmQ6dHlwZSddKSB7XG4gICAgICAgIHR5cGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd0eXBlJyk7XG4gICAgICB9XG4gICAgICBpZiAoIW1hcC50eXBlICYmICF0eXBlQmluZGluZyAmJiBtYXBbJ3YtYmluZCddKSB7XG4gICAgICAgIHR5cGVCaW5kaW5nID0gXCIoXCIgKyAobWFwWyd2LWJpbmQnXSkgKyBcIikudHlwZVwiO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZUJpbmRpbmcpIHtcbiAgICAgICAgdmFyIGlmQ29uZGl0aW9uID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtaWYnLCB0cnVlKTtcbiAgICAgICAgdmFyIGlmQ29uZGl0aW9uRXh0cmEgPSBpZkNvbmRpdGlvbiA/IChcIiYmKFwiICsgaWZDb25kaXRpb24gKyBcIilcIikgOiBcIlwiO1xuICAgICAgICB2YXIgaGFzRWxzZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UnLCB0cnVlKSAhPSBudWxsO1xuICAgICAgICB2YXIgZWxzZUlmQ29uZGl0aW9uID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZS1pZicsIHRydWUpO1xuICAgICAgICAvLyAxLiBjaGVja2JveFxuICAgICAgICB2YXIgYnJhbmNoMCA9IGNsb25lQVNURWxlbWVudChlbCk7XG4gICAgICAgIC8vIHByb2Nlc3MgZm9yIG9uIHRoZSBtYWluIG5vZGVcbiAgICAgICAgcHJvY2Vzc0ZvcihicmFuY2gwKTtcbiAgICAgICAgYWRkUmF3QXR0cihicmFuY2gwLCAndHlwZScsICdjaGVja2JveCcpO1xuICAgICAgICBwcm9jZXNzRWxlbWVudChicmFuY2gwLCBvcHRpb25zKTtcbiAgICAgICAgYnJhbmNoMC5wcm9jZXNzZWQgPSB0cnVlOyAvLyBwcmV2ZW50IGl0IGZyb20gZG91YmxlLXByb2Nlc3NlZFxuICAgICAgICBicmFuY2gwLmlmID0gXCIoXCIgKyB0eXBlQmluZGluZyArIFwiKT09PSdjaGVja2JveCdcIiArIGlmQ29uZGl0aW9uRXh0cmE7XG4gICAgICAgIGFkZElmQ29uZGl0aW9uKGJyYW5jaDAsIHtcbiAgICAgICAgICBleHA6IGJyYW5jaDAuaWYsXG4gICAgICAgICAgYmxvY2s6IGJyYW5jaDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIDIuIGFkZCByYWRpbyBlbHNlLWlmIGNvbmRpdGlvblxuICAgICAgICB2YXIgYnJhbmNoMSA9IGNsb25lQVNURWxlbWVudChlbCk7XG4gICAgICAgIGdldEFuZFJlbW92ZUF0dHIoYnJhbmNoMSwgJ3YtZm9yJywgdHJ1ZSk7XG4gICAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMSwgJ3R5cGUnLCAncmFkaW8nKTtcbiAgICAgICAgcHJvY2Vzc0VsZW1lbnQoYnJhbmNoMSwgb3B0aW9ucyk7XG4gICAgICAgIGFkZElmQ29uZGl0aW9uKGJyYW5jaDAsIHtcbiAgICAgICAgICBleHA6IFwiKFwiICsgdHlwZUJpbmRpbmcgKyBcIik9PT0ncmFkaW8nXCIgKyBpZkNvbmRpdGlvbkV4dHJhLFxuICAgICAgICAgIGJsb2NrOiBicmFuY2gxXG4gICAgICAgIH0pO1xuICAgICAgICAvLyAzLiBvdGhlclxuICAgICAgICB2YXIgYnJhbmNoMiA9IGNsb25lQVNURWxlbWVudChlbCk7XG4gICAgICAgIGdldEFuZFJlbW92ZUF0dHIoYnJhbmNoMiwgJ3YtZm9yJywgdHJ1ZSk7XG4gICAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMiwgJzp0eXBlJywgdHlwZUJpbmRpbmcpO1xuICAgICAgICBwcm9jZXNzRWxlbWVudChicmFuY2gyLCBvcHRpb25zKTtcbiAgICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICAgIGV4cDogaWZDb25kaXRpb24sXG4gICAgICAgICAgYmxvY2s6IGJyYW5jaDJcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGhhc0Vsc2UpIHtcbiAgICAgICAgICBicmFuY2gwLmVsc2UgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGVsc2VJZkNvbmRpdGlvbikge1xuICAgICAgICAgIGJyYW5jaDAuZWxzZWlmID0gZWxzZUlmQ29uZGl0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJyYW5jaDBcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbG9uZUFTVEVsZW1lbnQgKGVsKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUFTVEVsZW1lbnQoZWwudGFnLCBlbC5hdHRyc0xpc3Quc2xpY2UoKSwgZWwucGFyZW50KVxuICB9XG5cbiAgdmFyIG1vZGVsJDEgPSB7XG4gICAgcHJlVHJhbnNmb3JtTm9kZTogcHJlVHJhbnNmb3JtTm9kZVxuICB9O1xuXG4gIHZhciBtb2R1bGVzJDEgPSBbXG4gICAga2xhc3MkMSxcbiAgICBzdHlsZSQxLFxuICAgIG1vZGVsJDFcbiAgXTtcblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiB0ZXh0IChlbCwgZGlyKSB7XG4gICAgaWYgKGRpci52YWx1ZSkge1xuICAgICAgYWRkUHJvcChlbCwgJ3RleHRDb250ZW50JywgKFwiX3MoXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKSwgZGlyKTtcbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBodG1sIChlbCwgZGlyKSB7XG4gICAgaWYgKGRpci52YWx1ZSkge1xuICAgICAgYWRkUHJvcChlbCwgJ2lubmVySFRNTCcsIChcIl9zKFwiICsgKGRpci52YWx1ZSkgKyBcIilcIiksIGRpcik7XG4gICAgfVxuICB9XG5cbiAgdmFyIGRpcmVjdGl2ZXMkMSA9IHtcbiAgICBtb2RlbDogbW9kZWwsXG4gICAgdGV4dDogdGV4dCxcbiAgICBodG1sOiBodG1sXG4gIH07XG5cbiAgLyogICovXG5cbiAgdmFyIGJhc2VPcHRpb25zID0ge1xuICAgIGV4cGVjdEhUTUw6IHRydWUsXG4gICAgbW9kdWxlczogbW9kdWxlcyQxLFxuICAgIGRpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMkMSxcbiAgICBpc1ByZVRhZzogaXNQcmVUYWcsXG4gICAgaXNVbmFyeVRhZzogaXNVbmFyeVRhZyxcbiAgICBtdXN0VXNlUHJvcDogbXVzdFVzZVByb3AsXG4gICAgY2FuQmVMZWZ0T3BlblRhZzogY2FuQmVMZWZ0T3BlblRhZyxcbiAgICBpc1Jlc2VydmVkVGFnOiBpc1Jlc2VydmVkVGFnLFxuICAgIGdldFRhZ05hbWVzcGFjZTogZ2V0VGFnTmFtZXNwYWNlLFxuICAgIHN0YXRpY0tleXM6IGdlblN0YXRpY0tleXMobW9kdWxlcyQxKVxuICB9O1xuXG4gIC8qICAqL1xuXG4gIHZhciBpc1N0YXRpY0tleTtcbiAgdmFyIGlzUGxhdGZvcm1SZXNlcnZlZFRhZztcblxuICB2YXIgZ2VuU3RhdGljS2V5c0NhY2hlZCA9IGNhY2hlZChnZW5TdGF0aWNLZXlzJDEpO1xuXG4gIC8qKlxuICAgKiBHb2FsIG9mIHRoZSBvcHRpbWl6ZXI6IHdhbGsgdGhlIGdlbmVyYXRlZCB0ZW1wbGF0ZSBBU1QgdHJlZVxuICAgKiBhbmQgZGV0ZWN0IHN1Yi10cmVlcyB0aGF0IGFyZSBwdXJlbHkgc3RhdGljLCBpLmUuIHBhcnRzIG9mXG4gICAqIHRoZSBET00gdGhhdCBuZXZlciBuZWVkcyB0byBjaGFuZ2UuXG4gICAqXG4gICAqIE9uY2Ugd2UgZGV0ZWN0IHRoZXNlIHN1Yi10cmVlcywgd2UgY2FuOlxuICAgKlxuICAgKiAxLiBIb2lzdCB0aGVtIGludG8gY29uc3RhbnRzLCBzbyB0aGF0IHdlIG5vIGxvbmdlciBuZWVkIHRvXG4gICAqICAgIGNyZWF0ZSBmcmVzaCBub2RlcyBmb3IgdGhlbSBvbiBlYWNoIHJlLXJlbmRlcjtcbiAgICogMi4gQ29tcGxldGVseSBza2lwIHRoZW0gaW4gdGhlIHBhdGNoaW5nIHByb2Nlc3MuXG4gICAqL1xuICBmdW5jdGlvbiBvcHRpbWl6ZSAocm9vdCwgb3B0aW9ucykge1xuICAgIGlmICghcm9vdCkgeyByZXR1cm4gfVxuICAgIGlzU3RhdGljS2V5ID0gZ2VuU3RhdGljS2V5c0NhY2hlZChvcHRpb25zLnN0YXRpY0tleXMgfHwgJycpO1xuICAgIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcbiAgICAvLyBmaXJzdCBwYXNzOiBtYXJrIGFsbCBub24tc3RhdGljIG5vZGVzLlxuICAgIG1hcmtTdGF0aWMkMShyb290KTtcbiAgICAvLyBzZWNvbmQgcGFzczogbWFyayBzdGF0aWMgcm9vdHMuXG4gICAgbWFya1N0YXRpY1Jvb3RzKHJvb3QsIGZhbHNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlblN0YXRpY0tleXMkMSAoa2V5cykge1xuICAgIHJldHVybiBtYWtlTWFwKFxuICAgICAgJ3R5cGUsdGFnLGF0dHJzTGlzdCxhdHRyc01hcCxwbGFpbixwYXJlbnQsY2hpbGRyZW4sYXR0cnMsc3RhcnQsZW5kLHJhd0F0dHJzTWFwJyArXG4gICAgICAoa2V5cyA/ICcsJyArIGtleXMgOiAnJylcbiAgICApXG4gIH1cblxuICBmdW5jdGlvbiBtYXJrU3RhdGljJDEgKG5vZGUpIHtcbiAgICBub2RlLnN0YXRpYyA9IGlzU3RhdGljKG5vZGUpO1xuICAgIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICAgIC8vIGRvIG5vdCBtYWtlIGNvbXBvbmVudCBzbG90IGNvbnRlbnQgc3RhdGljLiB0aGlzIGF2b2lkc1xuICAgICAgLy8gMS4gY29tcG9uZW50cyBub3QgYWJsZSB0byBtdXRhdGUgc2xvdCBub2Rlc1xuICAgICAgLy8gMi4gc3RhdGljIHNsb3QgY29udGVudCBmYWlscyBmb3IgaG90LXJlbG9hZGluZ1xuICAgICAgaWYgKFxuICAgICAgICAhaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJlxuICAgICAgICBub2RlLnRhZyAhPT0gJ3Nsb3QnICYmXG4gICAgICAgIG5vZGUuYXR0cnNNYXBbJ2lubGluZS10ZW1wbGF0ZSddID09IG51bGxcbiAgICAgICkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgbWFya1N0YXRpYyQxKGNoaWxkKTtcbiAgICAgICAgaWYgKCFjaGlsZC5zdGF0aWMpIHtcbiAgICAgICAgICBub2RlLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5pZkNvbmRpdGlvbnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSQxID0gMSwgbCQxID0gbm9kZS5pZkNvbmRpdGlvbnMubGVuZ3RoOyBpJDEgPCBsJDE7IGkkMSsrKSB7XG4gICAgICAgICAgdmFyIGJsb2NrID0gbm9kZS5pZkNvbmRpdGlvbnNbaSQxXS5ibG9jaztcbiAgICAgICAgICBtYXJrU3RhdGljJDEoYmxvY2spO1xuICAgICAgICAgIGlmICghYmxvY2suc3RhdGljKSB7XG4gICAgICAgICAgICBub2RlLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtTdGF0aWNSb290cyAobm9kZSwgaXNJbkZvcikge1xuICAgIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICAgIGlmIChub2RlLnN0YXRpYyB8fCBub2RlLm9uY2UpIHtcbiAgICAgICAgbm9kZS5zdGF0aWNJbkZvciA9IGlzSW5Gb3I7XG4gICAgICB9XG4gICAgICAvLyBGb3IgYSBub2RlIHRvIHF1YWxpZnkgYXMgYSBzdGF0aWMgcm9vdCwgaXQgc2hvdWxkIGhhdmUgY2hpbGRyZW4gdGhhdFxuICAgICAgLy8gYXJlIG5vdCBqdXN0IHN0YXRpYyB0ZXh0LiBPdGhlcndpc2UgdGhlIGNvc3Qgb2YgaG9pc3Rpbmcgb3V0IHdpbGxcbiAgICAgIC8vIG91dHdlaWdoIHRoZSBiZW5lZml0cyBhbmQgaXQncyBiZXR0ZXIgb2ZmIHRvIGp1c3QgYWx3YXlzIHJlbmRlciBpdCBmcmVzaC5cbiAgICAgIGlmIChub2RlLnN0YXRpYyAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCAmJiAhKFxuICAgICAgICBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICBub2RlLmNoaWxkcmVuWzBdLnR5cGUgPT09IDNcbiAgICAgICkpIHtcbiAgICAgICAgbm9kZS5zdGF0aWNSb290ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnN0YXRpY1Jvb3QgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBtYXJrU3RhdGljUm9vdHMobm9kZS5jaGlsZHJlbltpXSwgaXNJbkZvciB8fCAhIW5vZGUuZm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5vZGUuaWZDb25kaXRpb25zKSB7XG4gICAgICAgIGZvciAodmFyIGkkMSA9IDEsIGwkMSA9IG5vZGUuaWZDb25kaXRpb25zLmxlbmd0aDsgaSQxIDwgbCQxOyBpJDErKykge1xuICAgICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmlmQ29uZGl0aW9uc1tpJDFdLmJsb2NrLCBpc0luRm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3RhdGljIChub2RlKSB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMikgeyAvLyBleHByZXNzaW9uXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMykgeyAvLyB0ZXh0XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gISEobm9kZS5wcmUgfHwgKFxuICAgICAgIW5vZGUuaGFzQmluZGluZ3MgJiYgLy8gbm8gZHluYW1pYyBiaW5kaW5nc1xuICAgICAgIW5vZGUuaWYgJiYgIW5vZGUuZm9yICYmIC8vIG5vdCB2LWlmIG9yIHYtZm9yIG9yIHYtZWxzZVxuICAgICAgIWlzQnVpbHRJblRhZyhub2RlLnRhZykgJiYgLy8gbm90IGEgYnVpbHQtaW5cbiAgICAgIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyhub2RlLnRhZykgJiYgLy8gbm90IGEgY29tcG9uZW50XG4gICAgICAhaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3Iobm9kZSkgJiZcbiAgICAgIE9iamVjdC5rZXlzKG5vZGUpLmV2ZXJ5KGlzU3RhdGljS2V5KVxuICAgICkpXG4gIH1cblxuICBmdW5jdGlvbiBpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvciAobm9kZSkge1xuICAgIHdoaWxlIChub2RlLnBhcmVudCkge1xuICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgICAgaWYgKG5vZGUudGFnICE9PSAndGVtcGxhdGUnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgaWYgKG5vZGUuZm9yKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyogICovXG5cbiAgdmFyIGZuRXhwUkUgPSAvXihbXFx3JF9dK3xcXChbXildKj9cXCkpXFxzKj0+fF5mdW5jdGlvblxccyooPzpbXFx3JF0rKT9cXHMqXFwoLztcbiAgdmFyIGZuSW52b2tlUkUgPSAvXFwoW14pXSo/XFwpOyokLztcbiAgdmFyIHNpbXBsZVBhdGhSRSA9IC9eW0EtWmEtel8kXVtcXHckXSooPzpcXC5bQS1aYS16XyRdW1xcdyRdKnxcXFsnW14nXSo/J118XFxbXCJbXlwiXSo/XCJdfFxcW1xcZCtdfFxcW1tBLVphLXpfJF1bXFx3JF0qXSkqJC87XG5cbiAgLy8gS2V5Ym9hcmRFdmVudC5rZXlDb2RlIGFsaWFzZXNcbiAgdmFyIGtleUNvZGVzID0ge1xuICAgIGVzYzogMjcsXG4gICAgdGFiOiA5LFxuICAgIGVudGVyOiAxMyxcbiAgICBzcGFjZTogMzIsXG4gICAgdXA6IDM4LFxuICAgIGxlZnQ6IDM3LFxuICAgIHJpZ2h0OiAzOSxcbiAgICBkb3duOiA0MCxcbiAgICAnZGVsZXRlJzogWzgsIDQ2XVxuICB9O1xuXG4gIC8vIEtleWJvYXJkRXZlbnQua2V5IGFsaWFzZXNcbiAgdmFyIGtleU5hbWVzID0ge1xuICAgIC8vICM3ODgwOiBJRTExIGFuZCBFZGdlIHVzZSBgRXNjYCBmb3IgRXNjYXBlIGtleSBuYW1lLlxuICAgIGVzYzogWydFc2MnLCAnRXNjYXBlJ10sXG4gICAgdGFiOiAnVGFiJyxcbiAgICBlbnRlcjogJ0VudGVyJyxcbiAgICAvLyAjOTExMjogSUUxMSB1c2VzIGBTcGFjZWJhcmAgZm9yIFNwYWNlIGtleSBuYW1lLlxuICAgIHNwYWNlOiBbJyAnLCAnU3BhY2ViYXInXSxcbiAgICAvLyAjNzgwNjogSUUxMSB1c2VzIGtleSBuYW1lcyB3aXRob3V0IGBBcnJvd2AgcHJlZml4IGZvciBhcnJvdyBrZXlzLlxuICAgIHVwOiBbJ1VwJywgJ0Fycm93VXAnXSxcbiAgICBsZWZ0OiBbJ0xlZnQnLCAnQXJyb3dMZWZ0J10sXG4gICAgcmlnaHQ6IFsnUmlnaHQnLCAnQXJyb3dSaWdodCddLFxuICAgIGRvd246IFsnRG93bicsICdBcnJvd0Rvd24nXSxcbiAgICAvLyAjOTExMjogSUUxMSB1c2VzIGBEZWxgIGZvciBEZWxldGUga2V5IG5hbWUuXG4gICAgJ2RlbGV0ZSc6IFsnQmFja3NwYWNlJywgJ0RlbGV0ZScsICdEZWwnXVxuICB9O1xuXG4gIC8vICM0ODY4OiBtb2RpZmllcnMgdGhhdCBwcmV2ZW50IHRoZSBleGVjdXRpb24gb2YgdGhlIGxpc3RlbmVyXG4gIC8vIG5lZWQgdG8gZXhwbGljaXRseSByZXR1cm4gbnVsbCBzbyB0aGF0IHdlIGNhbiBkZXRlcm1pbmUgd2hldGhlciB0byByZW1vdmVcbiAgLy8gdGhlIGxpc3RlbmVyIGZvciAub25jZVxuICB2YXIgZ2VuR3VhcmQgPSBmdW5jdGlvbiAoY29uZGl0aW9uKSB7IHJldHVybiAoXCJpZihcIiArIGNvbmRpdGlvbiArIFwiKXJldHVybiBudWxsO1wiKTsgfTtcblxuICB2YXIgbW9kaWZpZXJDb2RlID0ge1xuICAgIHN0b3A6ICckZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7JyxcbiAgICBwcmV2ZW50OiAnJGV2ZW50LnByZXZlbnREZWZhdWx0KCk7JyxcbiAgICBzZWxmOiBnZW5HdWFyZChcIiRldmVudC50YXJnZXQgIT09ICRldmVudC5jdXJyZW50VGFyZ2V0XCIpLFxuICAgIGN0cmw6IGdlbkd1YXJkKFwiISRldmVudC5jdHJsS2V5XCIpLFxuICAgIHNoaWZ0OiBnZW5HdWFyZChcIiEkZXZlbnQuc2hpZnRLZXlcIiksXG4gICAgYWx0OiBnZW5HdWFyZChcIiEkZXZlbnQuYWx0S2V5XCIpLFxuICAgIG1ldGE6IGdlbkd1YXJkKFwiISRldmVudC5tZXRhS2V5XCIpLFxuICAgIGxlZnQ6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDBcIiksXG4gICAgbWlkZGxlOiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAxXCIpLFxuICAgIHJpZ2h0OiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAyXCIpXG4gIH07XG5cbiAgZnVuY3Rpb24gZ2VuSGFuZGxlcnMgKFxuICAgIGV2ZW50cyxcbiAgICBpc05hdGl2ZVxuICApIHtcbiAgICB2YXIgcHJlZml4ID0gaXNOYXRpdmUgPyAnbmF0aXZlT246JyA6ICdvbjonO1xuICAgIHZhciBzdGF0aWNIYW5kbGVycyA9IFwiXCI7XG4gICAgdmFyIGR5bmFtaWNIYW5kbGVycyA9IFwiXCI7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBldmVudHMpIHtcbiAgICAgIHZhciBoYW5kbGVyQ29kZSA9IGdlbkhhbmRsZXIoZXZlbnRzW25hbWVdKTtcbiAgICAgIGlmIChldmVudHNbbmFtZV0gJiYgZXZlbnRzW25hbWVdLmR5bmFtaWMpIHtcbiAgICAgICAgZHluYW1pY0hhbmRsZXJzICs9IG5hbWUgKyBcIixcIiArIGhhbmRsZXJDb2RlICsgXCIsXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0aWNIYW5kbGVycyArPSBcIlxcXCJcIiArIG5hbWUgKyBcIlxcXCI6XCIgKyBoYW5kbGVyQ29kZSArIFwiLFwiO1xuICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWNIYW5kbGVycyA9IFwie1wiICsgKHN0YXRpY0hhbmRsZXJzLnNsaWNlKDAsIC0xKSkgKyBcIn1cIjtcbiAgICBpZiAoZHluYW1pY0hhbmRsZXJzKSB7XG4gICAgICByZXR1cm4gcHJlZml4ICsgXCJfZChcIiArIHN0YXRpY0hhbmRsZXJzICsgXCIsW1wiICsgKGR5bmFtaWNIYW5kbGVycy5zbGljZSgwLCAtMSkpICsgXCJdKVwiXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwcmVmaXggKyBzdGF0aWNIYW5kbGVyc1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbkhhbmRsZXIgKGhhbmRsZXIpIHtcbiAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgIHJldHVybiAnZnVuY3Rpb24oKXt9J1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgICByZXR1cm4gKFwiW1wiICsgKGhhbmRsZXIubWFwKGZ1bmN0aW9uIChoYW5kbGVyKSB7IHJldHVybiBnZW5IYW5kbGVyKGhhbmRsZXIpOyB9KS5qb2luKCcsJykpICsgXCJdXCIpXG4gICAgfVxuXG4gICAgdmFyIGlzTWV0aG9kUGF0aCA9IHNpbXBsZVBhdGhSRS50ZXN0KGhhbmRsZXIudmFsdWUpO1xuICAgIHZhciBpc0Z1bmN0aW9uRXhwcmVzc2lvbiA9IGZuRXhwUkUudGVzdChoYW5kbGVyLnZhbHVlKTtcbiAgICB2YXIgaXNGdW5jdGlvbkludm9jYXRpb24gPSBzaW1wbGVQYXRoUkUudGVzdChoYW5kbGVyLnZhbHVlLnJlcGxhY2UoZm5JbnZva2VSRSwgJycpKTtcblxuICAgIGlmICghaGFuZGxlci5tb2RpZmllcnMpIHtcbiAgICAgIGlmIChpc01ldGhvZFBhdGggfHwgaXNGdW5jdGlvbkV4cHJlc3Npb24pIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXIudmFsdWVcbiAgICAgIH1cbiAgICAgIHJldHVybiAoXCJmdW5jdGlvbigkZXZlbnQpe1wiICsgKGlzRnVuY3Rpb25JbnZvY2F0aW9uID8gKFwicmV0dXJuIFwiICsgKGhhbmRsZXIudmFsdWUpKSA6IGhhbmRsZXIudmFsdWUpICsgXCJ9XCIpIC8vIGlubGluZSBzdGF0ZW1lbnRcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNvZGUgPSAnJztcbiAgICAgIHZhciBnZW5Nb2RpZmllckNvZGUgPSAnJztcbiAgICAgIHZhciBrZXlzID0gW107XG4gICAgICBmb3IgKHZhciBrZXkgaW4gaGFuZGxlci5tb2RpZmllcnMpIHtcbiAgICAgICAgaWYgKG1vZGlmaWVyQ29kZVtrZXldKSB7XG4gICAgICAgICAgZ2VuTW9kaWZpZXJDb2RlICs9IG1vZGlmaWVyQ29kZVtrZXldO1xuICAgICAgICAgIC8vIGxlZnQvcmlnaHRcbiAgICAgICAgICBpZiAoa2V5Q29kZXNba2V5XSkge1xuICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2V4YWN0Jykge1xuICAgICAgICAgIHZhciBtb2RpZmllcnMgPSAoaGFuZGxlci5tb2RpZmllcnMpO1xuICAgICAgICAgIGdlbk1vZGlmaWVyQ29kZSArPSBnZW5HdWFyZChcbiAgICAgICAgICAgIFsnY3RybCcsICdzaGlmdCcsICdhbHQnLCAnbWV0YSddXG4gICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGtleU1vZGlmaWVyKSB7IHJldHVybiAhbW9kaWZpZXJzW2tleU1vZGlmaWVyXTsgfSlcbiAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoa2V5TW9kaWZpZXIpIHsgcmV0dXJuIChcIiRldmVudC5cIiArIGtleU1vZGlmaWVyICsgXCJLZXlcIik7IH0pXG4gICAgICAgICAgICAgIC5qb2luKCd8fCcpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIGNvZGUgKz0gZ2VuS2V5RmlsdGVyKGtleXMpO1xuICAgICAgfVxuICAgICAgLy8gTWFrZSBzdXJlIG1vZGlmaWVycyBsaWtlIHByZXZlbnQgYW5kIHN0b3AgZ2V0IGV4ZWN1dGVkIGFmdGVyIGtleSBmaWx0ZXJpbmdcbiAgICAgIGlmIChnZW5Nb2RpZmllckNvZGUpIHtcbiAgICAgICAgY29kZSArPSBnZW5Nb2RpZmllckNvZGU7XG4gICAgICB9XG4gICAgICB2YXIgaGFuZGxlckNvZGUgPSBpc01ldGhvZFBhdGhcbiAgICAgICAgPyAoXCJyZXR1cm4gXCIgKyAoaGFuZGxlci52YWx1ZSkgKyBcIigkZXZlbnQpXCIpXG4gICAgICAgIDogaXNGdW5jdGlvbkV4cHJlc3Npb25cbiAgICAgICAgICA/IChcInJldHVybiAoXCIgKyAoaGFuZGxlci52YWx1ZSkgKyBcIikoJGV2ZW50KVwiKVxuICAgICAgICAgIDogaXNGdW5jdGlvbkludm9jYXRpb25cbiAgICAgICAgICAgID8gKFwicmV0dXJuIFwiICsgKGhhbmRsZXIudmFsdWUpKVxuICAgICAgICAgICAgOiBoYW5kbGVyLnZhbHVlO1xuICAgICAgcmV0dXJuIChcImZ1bmN0aW9uKCRldmVudCl7XCIgKyBjb2RlICsgaGFuZGxlckNvZGUgKyBcIn1cIilcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZW5LZXlGaWx0ZXIgKGtleXMpIHtcbiAgICByZXR1cm4gKFxuICAgICAgLy8gbWFrZSBzdXJlIHRoZSBrZXkgZmlsdGVycyBvbmx5IGFwcGx5IHRvIEtleWJvYXJkRXZlbnRzXG4gICAgICAvLyAjOTQ0MTogY2FuJ3QgdXNlICdrZXlDb2RlJyBpbiAkZXZlbnQgYmVjYXVzZSBDaHJvbWUgYXV0b2ZpbGwgZmlyZXMgZmFrZVxuICAgICAgLy8ga2V5IGV2ZW50cyB0aGF0IGRvIG5vdCBoYXZlIGtleUNvZGUgcHJvcGVydHkuLi5cbiAgICAgIFwiaWYoISRldmVudC50eXBlLmluZGV4T2YoJ2tleScpJiZcIiArXG4gICAgICAoa2V5cy5tYXAoZ2VuRmlsdGVyQ29kZSkuam9pbignJiYnKSkgKyBcIilyZXR1cm4gbnVsbDtcIlxuICAgIClcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbkZpbHRlckNvZGUgKGtleSkge1xuICAgIHZhciBrZXlWYWwgPSBwYXJzZUludChrZXksIDEwKTtcbiAgICBpZiAoa2V5VmFsKSB7XG4gICAgICByZXR1cm4gKFwiJGV2ZW50LmtleUNvZGUhPT1cIiArIGtleVZhbClcbiAgICB9XG4gICAgdmFyIGtleUNvZGUgPSBrZXlDb2Rlc1trZXldO1xuICAgIHZhciBrZXlOYW1lID0ga2V5TmFtZXNba2V5XTtcbiAgICByZXR1cm4gKFxuICAgICAgXCJfaygkZXZlbnQua2V5Q29kZSxcIiArXG4gICAgICAoSlNPTi5zdHJpbmdpZnkoa2V5KSkgKyBcIixcIiArXG4gICAgICAoSlNPTi5zdHJpbmdpZnkoa2V5Q29kZSkpICsgXCIsXCIgK1xuICAgICAgXCIkZXZlbnQua2V5LFwiICtcbiAgICAgIFwiXCIgKyAoSlNPTi5zdHJpbmdpZnkoa2V5TmFtZSkpICtcbiAgICAgIFwiKVwiXG4gICAgKVxuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gb24gKGVsLCBkaXIpIHtcbiAgICBpZiAoZGlyLm1vZGlmaWVycykge1xuICAgICAgd2FybihcInYtb24gd2l0aG91dCBhcmd1bWVudCBkb2VzIG5vdCBzdXBwb3J0IG1vZGlmaWVycy5cIik7XG4gICAgfVxuICAgIGVsLndyYXBMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoY29kZSkgeyByZXR1cm4gKFwiX2coXCIgKyBjb2RlICsgXCIsXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKTsgfTtcbiAgfVxuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIGJpbmQkMSAoZWwsIGRpcikge1xuICAgIGVsLndyYXBEYXRhID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgIHJldHVybiAoXCJfYihcIiArIGNvZGUgKyBcIiwnXCIgKyAoZWwudGFnKSArIFwiJyxcIiArIChkaXIudmFsdWUpICsgXCIsXCIgKyAoZGlyLm1vZGlmaWVycyAmJiBkaXIubW9kaWZpZXJzLnByb3AgPyAndHJ1ZScgOiAnZmFsc2UnKSArIChkaXIubW9kaWZpZXJzICYmIGRpci5tb2RpZmllcnMuc3luYyA/ICcsdHJ1ZScgOiAnJykgKyBcIilcIilcbiAgICB9O1xuICB9XG5cbiAgLyogICovXG5cbiAgdmFyIGJhc2VEaXJlY3RpdmVzID0ge1xuICAgIG9uOiBvbixcbiAgICBiaW5kOiBiaW5kJDEsXG4gICAgY2xvYWs6IG5vb3BcbiAgfTtcblxuICAvKiAgKi9cblxuXG5cblxuXG4gIHZhciBDb2RlZ2VuU3RhdGUgPSBmdW5jdGlvbiBDb2RlZ2VuU3RhdGUgKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMud2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgICB0aGlzLnRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybUNvZGUnKTtcbiAgICB0aGlzLmRhdGFHZW5GbnMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ2dlbkRhdGEnKTtcbiAgICB0aGlzLmRpcmVjdGl2ZXMgPSBleHRlbmQoZXh0ZW5kKHt9LCBiYXNlRGlyZWN0aXZlcyksIG9wdGlvbnMuZGlyZWN0aXZlcyk7XG4gICAgdmFyIGlzUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gICAgdGhpcy5tYXliZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gISFlbC5jb21wb25lbnQgfHwgIWlzUmVzZXJ2ZWRUYWcoZWwudGFnKTsgfTtcbiAgICB0aGlzLm9uY2VJZCA9IDA7XG4gICAgdGhpcy5zdGF0aWNSZW5kZXJGbnMgPSBbXTtcbiAgICB0aGlzLnByZSA9IGZhbHNlO1xuICB9O1xuXG5cblxuICBmdW5jdGlvbiBnZW5lcmF0ZSAoXG4gICAgYXN0LFxuICAgIG9wdGlvbnNcbiAgKSB7XG4gICAgdmFyIHN0YXRlID0gbmV3IENvZGVnZW5TdGF0ZShvcHRpb25zKTtcbiAgICB2YXIgY29kZSA9IGFzdCA/IGdlbkVsZW1lbnQoYXN0LCBzdGF0ZSkgOiAnX2MoXCJkaXZcIiknO1xuICAgIHJldHVybiB7XG4gICAgICByZW5kZXI6IChcIndpdGgodGhpcyl7cmV0dXJuIFwiICsgY29kZSArIFwifVwiKSxcbiAgICAgIHN0YXRpY1JlbmRlckZuczogc3RhdGUuc3RhdGljUmVuZGVyRm5zXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuRWxlbWVudCAoZWwsIHN0YXRlKSB7XG4gICAgaWYgKGVsLnBhcmVudCkge1xuICAgICAgZWwucHJlID0gZWwucHJlIHx8IGVsLnBhcmVudC5wcmU7XG4gICAgfVxuXG4gICAgaWYgKGVsLnN0YXRpY1Jvb3QgJiYgIWVsLnN0YXRpY1Byb2Nlc3NlZCkge1xuICAgICAgcmV0dXJuIGdlblN0YXRpYyhlbCwgc3RhdGUpXG4gICAgfSBlbHNlIGlmIChlbC5vbmNlICYmICFlbC5vbmNlUHJvY2Vzc2VkKSB7XG4gICAgICByZXR1cm4gZ2VuT25jZShlbCwgc3RhdGUpXG4gICAgfSBlbHNlIGlmIChlbC5mb3IgJiYgIWVsLmZvclByb2Nlc3NlZCkge1xuICAgICAgcmV0dXJuIGdlbkZvcihlbCwgc3RhdGUpXG4gICAgfSBlbHNlIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcbiAgICAgIHJldHVybiBnZW5JZihlbCwgc3RhdGUpXG4gICAgfSBlbHNlIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScgJiYgIWVsLnNsb3RUYXJnZXQgJiYgIXN0YXRlLnByZSkge1xuICAgICAgcmV0dXJuIGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3ZvaWQgMCdcbiAgICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgICByZXR1cm4gZ2VuU2xvdChlbCwgc3RhdGUpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbXBvbmVudCBvciBlbGVtZW50XG4gICAgICB2YXIgY29kZTtcbiAgICAgIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICAgICAgY29kZSA9IGdlbkNvbXBvbmVudChlbC5jb21wb25lbnQsIGVsLCBzdGF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgaWYgKCFlbC5wbGFpbiB8fCAoZWwucHJlICYmIHN0YXRlLm1heWJlQ29tcG9uZW50KGVsKSkpIHtcbiAgICAgICAgICBkYXRhID0gZ2VuRGF0YSQyKGVsLCBzdGF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2hpbGRyZW4gPSBlbC5pbmxpbmVUZW1wbGF0ZSA/IG51bGwgOiBnZW5DaGlsZHJlbihlbCwgc3RhdGUsIHRydWUpO1xuICAgICAgICBjb2RlID0gXCJfYygnXCIgKyAoZWwudGFnKSArIFwiJ1wiICsgKGRhdGEgPyAoXCIsXCIgKyBkYXRhKSA6ICcnKSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKSArIFwiKVwiO1xuICAgICAgfVxuICAgICAgLy8gbW9kdWxlIHRyYW5zZm9ybXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGUudHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb2RlID0gc3RhdGUudHJhbnNmb3Jtc1tpXShlbCwgY29kZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29kZVxuICAgIH1cbiAgfVxuXG4gIC8vIGhvaXN0IHN0YXRpYyBzdWItdHJlZXMgb3V0XG4gIGZ1bmN0aW9uIGdlblN0YXRpYyAoZWwsIHN0YXRlKSB7XG4gICAgZWwuc3RhdGljUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgICAvLyBTb21lIGVsZW1lbnRzICh0ZW1wbGF0ZXMpIG5lZWQgdG8gYmVoYXZlIGRpZmZlcmVudGx5IGluc2lkZSBvZiBhIHYtcHJlXG4gICAgLy8gbm9kZS4gIEFsbCBwcmUgbm9kZXMgYXJlIHN0YXRpYyByb290cywgc28gd2UgY2FuIHVzZSB0aGlzIGFzIGEgbG9jYXRpb24gdG9cbiAgICAvLyB3cmFwIGEgc3RhdGUgY2hhbmdlIGFuZCByZXNldCBpdCB1cG9uIGV4aXRpbmcgdGhlIHByZSBub2RlLlxuICAgIHZhciBvcmlnaW5hbFByZVN0YXRlID0gc3RhdGUucHJlO1xuICAgIGlmIChlbC5wcmUpIHtcbiAgICAgIHN0YXRlLnByZSA9IGVsLnByZTtcbiAgICB9XG4gICAgc3RhdGUuc3RhdGljUmVuZGVyRm5zLnB1c2goKFwid2l0aCh0aGlzKXtyZXR1cm4gXCIgKyAoZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwifVwiKSk7XG4gICAgc3RhdGUucHJlID0gb3JpZ2luYWxQcmVTdGF0ZTtcbiAgICByZXR1cm4gKFwiX20oXCIgKyAoc3RhdGUuc3RhdGljUmVuZGVyRm5zLmxlbmd0aCAtIDEpICsgKGVsLnN0YXRpY0luRm9yID8gJyx0cnVlJyA6ICcnKSArIFwiKVwiKVxuICB9XG5cbiAgLy8gdi1vbmNlXG4gIGZ1bmN0aW9uIGdlbk9uY2UgKGVsLCBzdGF0ZSkge1xuICAgIGVsLm9uY2VQcm9jZXNzZWQgPSB0cnVlO1xuICAgIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcbiAgICAgIHJldHVybiBnZW5JZihlbCwgc3RhdGUpXG4gICAgfSBlbHNlIGlmIChlbC5zdGF0aWNJbkZvcikge1xuICAgICAgdmFyIGtleSA9ICcnO1xuICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudDtcbiAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgaWYgKHBhcmVudC5mb3IpIHtcbiAgICAgICAgICBrZXkgPSBwYXJlbnQua2V5O1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgIH1cbiAgICAgIGlmICgha2V5KSB7XG4gICAgICAgIHN0YXRlLndhcm4oXG4gICAgICAgICAgXCJ2LW9uY2UgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgdi1mb3IgdGhhdCBpcyBrZXllZC4gXCIsXG4gICAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3Ytb25jZSddXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBnZW5FbGVtZW50KGVsLCBzdGF0ZSlcbiAgICAgIH1cbiAgICAgIHJldHVybiAoXCJfbyhcIiArIChnZW5FbGVtZW50KGVsLCBzdGF0ZSkpICsgXCIsXCIgKyAoc3RhdGUub25jZUlkKyspICsgXCIsXCIgKyBrZXkgKyBcIilcIilcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGdlblN0YXRpYyhlbCwgc3RhdGUpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuSWYgKFxuICAgIGVsLFxuICAgIHN0YXRlLFxuICAgIGFsdEdlbixcbiAgICBhbHRFbXB0eVxuICApIHtcbiAgICBlbC5pZlByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICAgIHJldHVybiBnZW5JZkNvbmRpdGlvbnMoZWwuaWZDb25kaXRpb25zLnNsaWNlKCksIHN0YXRlLCBhbHRHZW4sIGFsdEVtcHR5KVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuSWZDb25kaXRpb25zIChcbiAgICBjb25kaXRpb25zLFxuICAgIHN0YXRlLFxuICAgIGFsdEdlbixcbiAgICBhbHRFbXB0eVxuICApIHtcbiAgICBpZiAoIWNvbmRpdGlvbnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gYWx0RW1wdHkgfHwgJ19lKCknXG4gICAgfVxuXG4gICAgdmFyIGNvbmRpdGlvbiA9IGNvbmRpdGlvbnMuc2hpZnQoKTtcbiAgICBpZiAoY29uZGl0aW9uLmV4cCkge1xuICAgICAgcmV0dXJuIChcIihcIiArIChjb25kaXRpb24uZXhwKSArIFwiKT9cIiArIChnZW5UZXJuYXJ5RXhwKGNvbmRpdGlvbi5ibG9jaykpICsgXCI6XCIgKyAoZ2VuSWZDb25kaXRpb25zKGNvbmRpdGlvbnMsIHN0YXRlLCBhbHRHZW4sIGFsdEVtcHR5KSkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoXCJcIiArIChnZW5UZXJuYXJ5RXhwKGNvbmRpdGlvbi5ibG9jaykpKVxuICAgIH1cblxuICAgIC8vIHYtaWYgd2l0aCB2LW9uY2Ugc2hvdWxkIGdlbmVyYXRlIGNvZGUgbGlrZSAoYSk/X20oMCk6X20oMSlcbiAgICBmdW5jdGlvbiBnZW5UZXJuYXJ5RXhwIChlbCkge1xuICAgICAgcmV0dXJuIGFsdEdlblxuICAgICAgICA/IGFsdEdlbihlbCwgc3RhdGUpXG4gICAgICAgIDogZWwub25jZVxuICAgICAgICAgID8gZ2VuT25jZShlbCwgc3RhdGUpXG4gICAgICAgICAgOiBnZW5FbGVtZW50KGVsLCBzdGF0ZSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZW5Gb3IgKFxuICAgIGVsLFxuICAgIHN0YXRlLFxuICAgIGFsdEdlbixcbiAgICBhbHRIZWxwZXJcbiAgKSB7XG4gICAgdmFyIGV4cCA9IGVsLmZvcjtcbiAgICB2YXIgYWxpYXMgPSBlbC5hbGlhcztcbiAgICB2YXIgaXRlcmF0b3IxID0gZWwuaXRlcmF0b3IxID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMSkpIDogJyc7XG4gICAgdmFyIGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/IChcIixcIiArIChlbC5pdGVyYXRvcjIpKSA6ICcnO1xuXG4gICAgaWYgKHN0YXRlLm1heWJlQ29tcG9uZW50KGVsKSAmJlxuICAgICAgZWwudGFnICE9PSAnc2xvdCcgJiZcbiAgICAgIGVsLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJlxuICAgICAgIWVsLmtleVxuICAgICkge1xuICAgICAgc3RhdGUud2FybihcbiAgICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtZm9yPVxcXCJcIiArIGFsaWFzICsgXCIgaW4gXCIgKyBleHAgKyBcIlxcXCI+OiBjb21wb25lbnQgbGlzdHMgcmVuZGVyZWQgd2l0aCBcIiArXG4gICAgICAgIFwidi1mb3Igc2hvdWxkIGhhdmUgZXhwbGljaXQga2V5cy4gXCIgK1xuICAgICAgICBcIlNlZSBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9saXN0Lmh0bWwja2V5IGZvciBtb3JlIGluZm8uXCIsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LWZvciddLFxuICAgICAgICB0cnVlIC8qIHRpcCAqL1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBlbC5mb3JQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgICByZXR1cm4gKGFsdEhlbHBlciB8fCAnX2wnKSArIFwiKChcIiArIGV4cCArIFwiKSxcIiArXG4gICAgICBcImZ1bmN0aW9uKFwiICsgYWxpYXMgKyBpdGVyYXRvcjEgKyBpdGVyYXRvcjIgKyBcIil7XCIgK1xuICAgICAgICBcInJldHVybiBcIiArICgoYWx0R2VuIHx8IGdlbkVsZW1lbnQpKGVsLCBzdGF0ZSkpICtcbiAgICAgICd9KSdcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbkRhdGEkMiAoZWwsIHN0YXRlKSB7XG4gICAgdmFyIGRhdGEgPSAneyc7XG5cbiAgICAvLyBkaXJlY3RpdmVzIGZpcnN0LlxuICAgIC8vIGRpcmVjdGl2ZXMgbWF5IG11dGF0ZSB0aGUgZWwncyBvdGhlciBwcm9wZXJ0aWVzIGJlZm9yZSB0aGV5IGFyZSBnZW5lcmF0ZWQuXG4gICAgdmFyIGRpcnMgPSBnZW5EaXJlY3RpdmVzKGVsLCBzdGF0ZSk7XG4gICAgaWYgKGRpcnMpIHsgZGF0YSArPSBkaXJzICsgJywnOyB9XG5cbiAgICAvLyBrZXlcbiAgICBpZiAoZWwua2V5KSB7XG4gICAgICBkYXRhICs9IFwia2V5OlwiICsgKGVsLmtleSkgKyBcIixcIjtcbiAgICB9XG4gICAgLy8gcmVmXG4gICAgaWYgKGVsLnJlZikge1xuICAgICAgZGF0YSArPSBcInJlZjpcIiArIChlbC5yZWYpICsgXCIsXCI7XG4gICAgfVxuICAgIGlmIChlbC5yZWZJbkZvcikge1xuICAgICAgZGF0YSArPSBcInJlZkluRm9yOnRydWUsXCI7XG4gICAgfVxuICAgIC8vIHByZVxuICAgIGlmIChlbC5wcmUpIHtcbiAgICAgIGRhdGEgKz0gXCJwcmU6dHJ1ZSxcIjtcbiAgICB9XG4gICAgLy8gcmVjb3JkIG9yaWdpbmFsIHRhZyBuYW1lIGZvciBjb21wb25lbnRzIHVzaW5nIFwiaXNcIiBhdHRyaWJ1dGVcbiAgICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgICBkYXRhICs9IFwidGFnOlxcXCJcIiArIChlbC50YWcpICsgXCJcXFwiLFwiO1xuICAgIH1cbiAgICAvLyBtb2R1bGUgZGF0YSBnZW5lcmF0aW9uIGZ1bmN0aW9uc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGUuZGF0YUdlbkZucy5sZW5ndGg7IGkrKykge1xuICAgICAgZGF0YSArPSBzdGF0ZS5kYXRhR2VuRm5zW2ldKGVsKTtcbiAgICB9XG4gICAgLy8gYXR0cmlidXRlc1xuICAgIGlmIChlbC5hdHRycykge1xuICAgICAgZGF0YSArPSBcImF0dHJzOlwiICsgKGdlblByb3BzKGVsLmF0dHJzKSkgKyBcIixcIjtcbiAgICB9XG4gICAgLy8gRE9NIHByb3BzXG4gICAgaWYgKGVsLnByb3BzKSB7XG4gICAgICBkYXRhICs9IFwiZG9tUHJvcHM6XCIgKyAoZ2VuUHJvcHMoZWwucHJvcHMpKSArIFwiLFwiO1xuICAgIH1cbiAgICAvLyBldmVudCBoYW5kbGVyc1xuICAgIGlmIChlbC5ldmVudHMpIHtcbiAgICAgIGRhdGEgKz0gKGdlbkhhbmRsZXJzKGVsLmV2ZW50cywgZmFsc2UpKSArIFwiLFwiO1xuICAgIH1cbiAgICBpZiAoZWwubmF0aXZlRXZlbnRzKSB7XG4gICAgICBkYXRhICs9IChnZW5IYW5kbGVycyhlbC5uYXRpdmVFdmVudHMsIHRydWUpKSArIFwiLFwiO1xuICAgIH1cbiAgICAvLyBzbG90IHRhcmdldFxuICAgIC8vIG9ubHkgZm9yIG5vbi1zY29wZWQgc2xvdHNcbiAgICBpZiAoZWwuc2xvdFRhcmdldCAmJiAhZWwuc2xvdFNjb3BlKSB7XG4gICAgICBkYXRhICs9IFwic2xvdDpcIiArIChlbC5zbG90VGFyZ2V0KSArIFwiLFwiO1xuICAgIH1cbiAgICAvLyBzY29wZWQgc2xvdHNcbiAgICBpZiAoZWwuc2NvcGVkU2xvdHMpIHtcbiAgICAgIGRhdGEgKz0gKGdlblNjb3BlZFNsb3RzKGVsLCBlbC5zY29wZWRTbG90cywgc3RhdGUpKSArIFwiLFwiO1xuICAgIH1cbiAgICAvLyBjb21wb25lbnQgdi1tb2RlbFxuICAgIGlmIChlbC5tb2RlbCkge1xuICAgICAgZGF0YSArPSBcIm1vZGVsOnt2YWx1ZTpcIiArIChlbC5tb2RlbC52YWx1ZSkgKyBcIixjYWxsYmFjazpcIiArIChlbC5tb2RlbC5jYWxsYmFjaykgKyBcIixleHByZXNzaW9uOlwiICsgKGVsLm1vZGVsLmV4cHJlc3Npb24pICsgXCJ9LFwiO1xuICAgIH1cbiAgICAvLyBpbmxpbmUtdGVtcGxhdGVcbiAgICBpZiAoZWwuaW5saW5lVGVtcGxhdGUpIHtcbiAgICAgIHZhciBpbmxpbmVUZW1wbGF0ZSA9IGdlbklubGluZVRlbXBsYXRlKGVsLCBzdGF0ZSk7XG4gICAgICBpZiAoaW5saW5lVGVtcGxhdGUpIHtcbiAgICAgICAgZGF0YSArPSBpbmxpbmVUZW1wbGF0ZSArIFwiLFwiO1xuICAgICAgfVxuICAgIH1cbiAgICBkYXRhID0gZGF0YS5yZXBsYWNlKC8sJC8sICcnKSArICd9JztcbiAgICAvLyB2LWJpbmQgZHluYW1pYyBhcmd1bWVudCB3cmFwXG4gICAgLy8gdi1iaW5kIHdpdGggZHluYW1pYyBhcmd1bWVudHMgbXVzdCBiZSBhcHBsaWVkIHVzaW5nIHRoZSBzYW1lIHYtYmluZCBvYmplY3RcbiAgICAvLyBtZXJnZSBoZWxwZXIgc28gdGhhdCBjbGFzcy9zdHlsZS9tdXN0VXNlUHJvcCBhdHRycyBhcmUgaGFuZGxlZCBjb3JyZWN0bHkuXG4gICAgaWYgKGVsLmR5bmFtaWNBdHRycykge1xuICAgICAgZGF0YSA9IFwiX2IoXCIgKyBkYXRhICsgXCIsXFxcIlwiICsgKGVsLnRhZykgKyBcIlxcXCIsXCIgKyAoZ2VuUHJvcHMoZWwuZHluYW1pY0F0dHJzKSkgKyBcIilcIjtcbiAgICB9XG4gICAgLy8gdi1iaW5kIGRhdGEgd3JhcFxuICAgIGlmIChlbC53cmFwRGF0YSkge1xuICAgICAgZGF0YSA9IGVsLndyYXBEYXRhKGRhdGEpO1xuICAgIH1cbiAgICAvLyB2LW9uIGRhdGEgd3JhcFxuICAgIGlmIChlbC53cmFwTGlzdGVuZXJzKSB7XG4gICAgICBkYXRhID0gZWwud3JhcExpc3RlbmVycyhkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGFcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbkRpcmVjdGl2ZXMgKGVsLCBzdGF0ZSkge1xuICAgIHZhciBkaXJzID0gZWwuZGlyZWN0aXZlcztcbiAgICBpZiAoIWRpcnMpIHsgcmV0dXJuIH1cbiAgICB2YXIgcmVzID0gJ2RpcmVjdGl2ZXM6Wyc7XG4gICAgdmFyIGhhc1J1bnRpbWUgPSBmYWxzZTtcbiAgICB2YXIgaSwgbCwgZGlyLCBuZWVkUnVudGltZTtcbiAgICBmb3IgKGkgPSAwLCBsID0gZGlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGRpciA9IGRpcnNbaV07XG4gICAgICBuZWVkUnVudGltZSA9IHRydWU7XG4gICAgICB2YXIgZ2VuID0gc3RhdGUuZGlyZWN0aXZlc1tkaXIubmFtZV07XG4gICAgICBpZiAoZ2VuKSB7XG4gICAgICAgIC8vIGNvbXBpbGUtdGltZSBkaXJlY3RpdmUgdGhhdCBtYW5pcHVsYXRlcyBBU1QuXG4gICAgICAgIC8vIHJldHVybnMgdHJ1ZSBpZiBpdCBhbHNvIG5lZWRzIGEgcnVudGltZSBjb3VudGVycGFydC5cbiAgICAgICAgbmVlZFJ1bnRpbWUgPSAhIWdlbihlbCwgZGlyLCBzdGF0ZS53YXJuKTtcbiAgICAgIH1cbiAgICAgIGlmIChuZWVkUnVudGltZSkge1xuICAgICAgICBoYXNSdW50aW1lID0gdHJ1ZTtcbiAgICAgICAgcmVzICs9IFwie25hbWU6XFxcIlwiICsgKGRpci5uYW1lKSArIFwiXFxcIixyYXdOYW1lOlxcXCJcIiArIChkaXIucmF3TmFtZSkgKyBcIlxcXCJcIiArIChkaXIudmFsdWUgPyAoXCIsdmFsdWU6KFwiICsgKGRpci52YWx1ZSkgKyBcIiksZXhwcmVzc2lvbjpcIiArIChKU09OLnN0cmluZ2lmeShkaXIudmFsdWUpKSkgOiAnJykgKyAoZGlyLmFyZyA/IChcIixhcmc6XCIgKyAoZGlyLmlzRHluYW1pY0FyZyA/IGRpci5hcmcgOiAoXCJcXFwiXCIgKyAoZGlyLmFyZykgKyBcIlxcXCJcIikpKSA6ICcnKSArIChkaXIubW9kaWZpZXJzID8gKFwiLG1vZGlmaWVyczpcIiArIChKU09OLnN0cmluZ2lmeShkaXIubW9kaWZpZXJzKSkpIDogJycpICsgXCJ9LFwiO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaGFzUnVudGltZSkge1xuICAgICAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSkgKyAnXSdcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZW5JbmxpbmVUZW1wbGF0ZSAoZWwsIHN0YXRlKSB7XG4gICAgdmFyIGFzdCA9IGVsLmNoaWxkcmVuWzBdO1xuICAgIGlmIChlbC5jaGlsZHJlbi5sZW5ndGggIT09IDEgfHwgYXN0LnR5cGUgIT09IDEpIHtcbiAgICAgIHN0YXRlLndhcm4oXG4gICAgICAgICdJbmxpbmUtdGVtcGxhdGUgY29tcG9uZW50cyBtdXN0IGhhdmUgZXhhY3RseSBvbmUgY2hpbGQgZWxlbWVudC4nLFxuICAgICAgICB7IHN0YXJ0OiBlbC5zdGFydCB9XG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoYXN0ICYmIGFzdC50eXBlID09PSAxKSB7XG4gICAgICB2YXIgaW5saW5lUmVuZGVyRm5zID0gZ2VuZXJhdGUoYXN0LCBzdGF0ZS5vcHRpb25zKTtcbiAgICAgIHJldHVybiAoXCJpbmxpbmVUZW1wbGF0ZTp7cmVuZGVyOmZ1bmN0aW9uKCl7XCIgKyAoaW5saW5lUmVuZGVyRm5zLnJlbmRlcikgKyBcIn0sc3RhdGljUmVuZGVyRm5zOltcIiArIChpbmxpbmVSZW5kZXJGbnMuc3RhdGljUmVuZGVyRm5zLm1hcChmdW5jdGlvbiAoY29kZSkgeyByZXR1cm4gKFwiZnVuY3Rpb24oKXtcIiArIGNvZGUgKyBcIn1cIik7IH0pLmpvaW4oJywnKSkgKyBcIl19XCIpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdHMgKFxuICAgIGVsLFxuICAgIHNsb3RzLFxuICAgIHN0YXRlXG4gICkge1xuICAgIC8vIGJ5IGRlZmF1bHQgc2NvcGVkIHNsb3RzIGFyZSBjb25zaWRlcmVkIFwic3RhYmxlXCIsIHRoaXMgYWxsb3dzIGNoaWxkXG4gICAgLy8gY29tcG9uZW50cyB3aXRoIG9ubHkgc2NvcGVkIHNsb3RzIHRvIHNraXAgZm9yY2VkIHVwZGF0ZXMgZnJvbSBwYXJlbnQuXG4gICAgLy8gYnV0IGluIHNvbWUgY2FzZXMgd2UgaGF2ZSB0byBiYWlsLW91dCBvZiB0aGlzIG9wdGltaXphdGlvblxuICAgIC8vIGZvciBleGFtcGxlIGlmIHRoZSBzbG90IGNvbnRhaW5zIGR5bmFtaWMgbmFtZXMsIGhhcyB2LWlmIG9yIHYtZm9yIG9uIHRoZW0uLi5cbiAgICB2YXIgbmVlZHNGb3JjZVVwZGF0ZSA9IGVsLmZvciB8fCBPYmplY3Qua2V5cyhzbG90cykuc29tZShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgc2xvdCA9IHNsb3RzW2tleV07XG4gICAgICByZXR1cm4gKFxuICAgICAgICBzbG90LnNsb3RUYXJnZXREeW5hbWljIHx8XG4gICAgICAgIHNsb3QuaWYgfHxcbiAgICAgICAgc2xvdC5mb3IgfHxcbiAgICAgICAgY29udGFpbnNTbG90Q2hpbGQoc2xvdCkgLy8gaXMgcGFzc2luZyBkb3duIHNsb3QgZnJvbSBwYXJlbnQgd2hpY2ggbWF5IGJlIGR5bmFtaWNcbiAgICAgIClcbiAgICB9KTtcblxuICAgIC8vICM5NTM0OiBpZiBhIGNvbXBvbmVudCB3aXRoIHNjb3BlZCBzbG90cyBpcyBpbnNpZGUgYSBjb25kaXRpb25hbCBicmFuY2gsXG4gICAgLy8gaXQncyBwb3NzaWJsZSBmb3IgdGhlIHNhbWUgY29tcG9uZW50IHRvIGJlIHJldXNlZCBidXQgd2l0aCBkaWZmZXJlbnRcbiAgICAvLyBjb21waWxlZCBzbG90IGNvbnRlbnQuIFRvIGF2b2lkIHRoYXQsIHdlIGdlbmVyYXRlIGEgdW5pcXVlIGtleSBiYXNlZCBvblxuICAgIC8vIHRoZSBnZW5lcmF0ZWQgY29kZSBvZiBhbGwgdGhlIHNsb3QgY29udGVudHMuXG4gICAgdmFyIG5lZWRzS2V5ID0gISFlbC5pZjtcblxuICAgIC8vIE9SIHdoZW4gaXQgaXMgaW5zaWRlIGFub3RoZXIgc2NvcGVkIHNsb3Qgb3Igdi1mb3IgKHRoZSByZWFjdGl2aXR5IG1heSBiZVxuICAgIC8vIGRpc2Nvbm5lY3RlZCBkdWUgdG8gdGhlIGludGVybWVkaWF0ZSBzY29wZSB2YXJpYWJsZSlcbiAgICAvLyAjOTQzOCwgIzk1MDZcbiAgICAvLyBUT0RPOiB0aGlzIGNhbiBiZSBmdXJ0aGVyIG9wdGltaXplZCBieSBwcm9wZXJseSBhbmFseXppbmcgaW4tc2NvcGUgYmluZGluZ3NcbiAgICAvLyBhbmQgc2tpcCBmb3JjZSB1cGRhdGluZyBvbmVzIHRoYXQgZG8gbm90IGFjdHVhbGx5IHVzZSBzY29wZSB2YXJpYWJsZXMuXG4gICAgaWYgKCFuZWVkc0ZvcmNlVXBkYXRlKSB7XG4gICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50O1xuICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgKHBhcmVudC5zbG90U2NvcGUgJiYgcGFyZW50LnNsb3RTY29wZSAhPT0gZW1wdHlTbG90U2NvcGVUb2tlbikgfHxcbiAgICAgICAgICBwYXJlbnQuZm9yXG4gICAgICAgICkge1xuICAgICAgICAgIG5lZWRzRm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmVudC5pZikge1xuICAgICAgICAgIG5lZWRzS2V5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBnZW5lcmF0ZWRTbG90cyA9IE9iamVjdC5rZXlzKHNsb3RzKVxuICAgICAgLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBnZW5TY29wZWRTbG90KHNsb3RzW2tleV0sIHN0YXRlKTsgfSlcbiAgICAgIC5qb2luKCcsJyk7XG5cbiAgICByZXR1cm4gKFwic2NvcGVkU2xvdHM6X3UoW1wiICsgZ2VuZXJhdGVkU2xvdHMgKyBcIl1cIiArIChuZWVkc0ZvcmNlVXBkYXRlID8gXCIsbnVsbCx0cnVlXCIgOiBcIlwiKSArICghbmVlZHNGb3JjZVVwZGF0ZSAmJiBuZWVkc0tleSA/IChcIixudWxsLGZhbHNlLFwiICsgKGhhc2goZ2VuZXJhdGVkU2xvdHMpKSkgOiBcIlwiKSArIFwiKVwiKVxuICB9XG5cbiAgZnVuY3Rpb24gaGFzaChzdHIpIHtcbiAgICB2YXIgaGFzaCA9IDUzODE7XG4gICAgdmFyIGkgPSBzdHIubGVuZ3RoO1xuICAgIHdoaWxlKGkpIHtcbiAgICAgIGhhc2ggPSAoaGFzaCAqIDMzKSBeIHN0ci5jaGFyQ29kZUF0KC0taSk7XG4gICAgfVxuICAgIHJldHVybiBoYXNoID4+PiAwXG4gIH1cblxuICBmdW5jdGlvbiBjb250YWluc1Nsb3RDaGlsZCAoZWwpIHtcbiAgICBpZiAoZWwudHlwZSA9PT0gMSkge1xuICAgICAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICByZXR1cm4gZWwuY2hpbGRyZW4uc29tZShjb250YWluc1Nsb3RDaGlsZClcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBmdW5jdGlvbiBnZW5TY29wZWRTbG90IChcbiAgICBlbCxcbiAgICBzdGF0ZVxuICApIHtcbiAgICB2YXIgaXNMZWdhY3lTeW50YXggPSBlbC5hdHRyc01hcFsnc2xvdC1zY29wZSddO1xuICAgIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQgJiYgIWlzTGVnYWN5U3ludGF4KSB7XG4gICAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlLCBnZW5TY29wZWRTbG90LCBcIm51bGxcIilcbiAgICB9XG4gICAgaWYgKGVsLmZvciAmJiAhZWwuZm9yUHJvY2Vzc2VkKSB7XG4gICAgICByZXR1cm4gZ2VuRm9yKGVsLCBzdGF0ZSwgZ2VuU2NvcGVkU2xvdClcbiAgICB9XG4gICAgdmFyIHNsb3RTY29wZSA9IGVsLnNsb3RTY29wZSA9PT0gZW1wdHlTbG90U2NvcGVUb2tlblxuICAgICAgPyBcIlwiXG4gICAgICA6IFN0cmluZyhlbC5zbG90U2NvcGUpO1xuICAgIHZhciBmbiA9IFwiZnVuY3Rpb24oXCIgKyBzbG90U2NvcGUgKyBcIil7XCIgK1xuICAgICAgXCJyZXR1cm4gXCIgKyAoZWwudGFnID09PSAndGVtcGxhdGUnXG4gICAgICAgID8gZWwuaWYgJiYgaXNMZWdhY3lTeW50YXhcbiAgICAgICAgICA/IChcIihcIiArIChlbC5pZikgKyBcIik/XCIgKyAoZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndW5kZWZpbmVkJykgKyBcIjp1bmRlZmluZWRcIilcbiAgICAgICAgICA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3VuZGVmaW5lZCdcbiAgICAgICAgOiBnZW5FbGVtZW50KGVsLCBzdGF0ZSkpICsgXCJ9XCI7XG4gICAgLy8gcmV2ZXJzZSBwcm94eSB2LXNsb3Qgd2l0aG91dCBzY29wZSBvbiB0aGlzLiRzbG90c1xuICAgIHZhciByZXZlcnNlUHJveHkgPSBzbG90U2NvcGUgPyBcIlwiIDogXCIscHJveHk6dHJ1ZVwiO1xuICAgIHJldHVybiAoXCJ7a2V5OlwiICsgKGVsLnNsb3RUYXJnZXQgfHwgXCJcXFwiZGVmYXVsdFxcXCJcIikgKyBcIixmbjpcIiArIGZuICsgcmV2ZXJzZVByb3h5ICsgXCJ9XCIpXG4gIH1cblxuICBmdW5jdGlvbiBnZW5DaGlsZHJlbiAoXG4gICAgZWwsXG4gICAgc3RhdGUsXG4gICAgY2hlY2tTa2lwLFxuICAgIGFsdEdlbkVsZW1lbnQsXG4gICAgYWx0R2VuTm9kZVxuICApIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBlbC5jaGlsZHJlbjtcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICB2YXIgZWwkMSA9IGNoaWxkcmVuWzBdO1xuICAgICAgLy8gb3B0aW1pemUgc2luZ2xlIHYtZm9yXG4gICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXG4gICAgICAgIGVsJDEuZm9yICYmXG4gICAgICAgIGVsJDEudGFnICE9PSAndGVtcGxhdGUnICYmXG4gICAgICAgIGVsJDEudGFnICE9PSAnc2xvdCdcbiAgICAgICkge1xuICAgICAgICB2YXIgbm9ybWFsaXphdGlvblR5cGUgPSBjaGVja1NraXBcbiAgICAgICAgICA/IHN0YXRlLm1heWJlQ29tcG9uZW50KGVsJDEpID8gXCIsMVwiIDogXCIsMFwiXG4gICAgICAgICAgOiBcIlwiO1xuICAgICAgICByZXR1cm4gKFwiXCIgKyAoKGFsdEdlbkVsZW1lbnQgfHwgZ2VuRWxlbWVudCkoZWwkMSwgc3RhdGUpKSArIG5vcm1hbGl6YXRpb25UeXBlKVxuICAgICAgfVxuICAgICAgdmFyIG5vcm1hbGl6YXRpb25UeXBlJDEgPSBjaGVja1NraXBcbiAgICAgICAgPyBnZXROb3JtYWxpemF0aW9uVHlwZShjaGlsZHJlbiwgc3RhdGUubWF5YmVDb21wb25lbnQpXG4gICAgICAgIDogMDtcbiAgICAgIHZhciBnZW4gPSBhbHRHZW5Ob2RlIHx8IGdlbk5vZGU7XG4gICAgICByZXR1cm4gKFwiW1wiICsgKGNoaWxkcmVuLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gZ2VuKGMsIHN0YXRlKTsgfSkuam9pbignLCcpKSArIFwiXVwiICsgKG5vcm1hbGl6YXRpb25UeXBlJDEgPyAoXCIsXCIgKyBub3JtYWxpemF0aW9uVHlwZSQxKSA6ICcnKSlcbiAgICB9XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgdGhlIG5vcm1hbGl6YXRpb24gbmVlZGVkIGZvciB0aGUgY2hpbGRyZW4gYXJyYXkuXG4gIC8vIDA6IG5vIG5vcm1hbGl6YXRpb24gbmVlZGVkXG4gIC8vIDE6IHNpbXBsZSBub3JtYWxpemF0aW9uIG5lZWRlZCAocG9zc2libGUgMS1sZXZlbCBkZWVwIG5lc3RlZCBhcnJheSlcbiAgLy8gMjogZnVsbCBub3JtYWxpemF0aW9uIG5lZWRlZFxuICBmdW5jdGlvbiBnZXROb3JtYWxpemF0aW9uVHlwZSAoXG4gICAgY2hpbGRyZW4sXG4gICAgbWF5YmVDb21wb25lbnRcbiAgKSB7XG4gICAgdmFyIHJlcyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoZWwudHlwZSAhPT0gMSkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgaWYgKG5lZWRzTm9ybWFsaXphdGlvbihlbCkgfHxcbiAgICAgICAgICAoZWwuaWZDb25kaXRpb25zICYmIGVsLmlmQ29uZGl0aW9ucy5zb21lKGZ1bmN0aW9uIChjKSB7IHJldHVybiBuZWVkc05vcm1hbGl6YXRpb24oYy5ibG9jayk7IH0pKSkge1xuICAgICAgICByZXMgPSAyO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgaWYgKG1heWJlQ29tcG9uZW50KGVsKSB8fFxuICAgICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG1heWJlQ29tcG9uZW50KGMuYmxvY2spOyB9KSkpIHtcbiAgICAgICAgcmVzID0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgZnVuY3Rpb24gbmVlZHNOb3JtYWxpemF0aW9uIChlbCkge1xuICAgIHJldHVybiBlbC5mb3IgIT09IHVuZGVmaW5lZCB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScgfHwgZWwudGFnID09PSAnc2xvdCdcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbk5vZGUgKG5vZGUsIHN0YXRlKSB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGdlbkVsZW1lbnQobm9kZSwgc3RhdGUpXG4gICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IDMgJiYgbm9kZS5pc0NvbW1lbnQpIHtcbiAgICAgIHJldHVybiBnZW5Db21tZW50KG5vZGUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBnZW5UZXh0KG5vZGUpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuVGV4dCAodGV4dCkge1xuICAgIHJldHVybiAoXCJfdihcIiArICh0ZXh0LnR5cGUgPT09IDJcbiAgICAgID8gdGV4dC5leHByZXNzaW9uIC8vIG5vIG5lZWQgZm9yICgpIGJlY2F1c2UgYWxyZWFkeSB3cmFwcGVkIGluIF9zKClcbiAgICAgIDogdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKEpTT04uc3RyaW5naWZ5KHRleHQudGV4dCkpKSArIFwiKVwiKVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuQ29tbWVudCAoY29tbWVudCkge1xuICAgIHJldHVybiAoXCJfZShcIiArIChKU09OLnN0cmluZ2lmeShjb21tZW50LnRleHQpKSArIFwiKVwiKVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuU2xvdCAoZWwsIHN0YXRlKSB7XG4gICAgdmFyIHNsb3ROYW1lID0gZWwuc2xvdE5hbWUgfHwgJ1wiZGVmYXVsdFwiJztcbiAgICB2YXIgY2hpbGRyZW4gPSBnZW5DaGlsZHJlbihlbCwgc3RhdGUpO1xuICAgIHZhciByZXMgPSBcIl90KFwiICsgc2xvdE5hbWUgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJyk7XG4gICAgdmFyIGF0dHJzID0gZWwuYXR0cnMgfHwgZWwuZHluYW1pY0F0dHJzXG4gICAgICA/IGdlblByb3BzKChlbC5hdHRycyB8fCBbXSkuY29uY2F0KGVsLmR5bmFtaWNBdHRycyB8fCBbXSkubWFwKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiAoe1xuICAgICAgICAgIC8vIHNsb3QgcHJvcHMgYXJlIGNhbWVsaXplZFxuICAgICAgICAgIG5hbWU6IGNhbWVsaXplKGF0dHIubmFtZSksXG4gICAgICAgICAgdmFsdWU6IGF0dHIudmFsdWUsXG4gICAgICAgICAgZHluYW1pYzogYXR0ci5keW5hbWljXG4gICAgICAgIH0pOyB9KSlcbiAgICAgIDogbnVsbDtcbiAgICB2YXIgYmluZCQkMSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQnXTtcbiAgICBpZiAoKGF0dHJzIHx8IGJpbmQkJDEpICYmICFjaGlsZHJlbikge1xuICAgICAgcmVzICs9IFwiLG51bGxcIjtcbiAgICB9XG4gICAgaWYgKGF0dHJzKSB7XG4gICAgICByZXMgKz0gXCIsXCIgKyBhdHRycztcbiAgICB9XG4gICAgaWYgKGJpbmQkJDEpIHtcbiAgICAgIHJlcyArPSAoYXR0cnMgPyAnJyA6ICcsbnVsbCcpICsgXCIsXCIgKyBiaW5kJCQxO1xuICAgIH1cbiAgICByZXR1cm4gcmVzICsgJyknXG4gIH1cblxuICAvLyBjb21wb25lbnROYW1lIGlzIGVsLmNvbXBvbmVudCwgdGFrZSBpdCBhcyBhcmd1bWVudCB0byBzaHVuIGZsb3cncyBwZXNzaW1pc3RpYyByZWZpbmVtZW50XG4gIGZ1bmN0aW9uIGdlbkNvbXBvbmVudCAoXG4gICAgY29tcG9uZW50TmFtZSxcbiAgICBlbCxcbiAgICBzdGF0ZVxuICApIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBlbC5pbmxpbmVUZW1wbGF0ZSA/IG51bGwgOiBnZW5DaGlsZHJlbihlbCwgc3RhdGUsIHRydWUpO1xuICAgIHJldHVybiAoXCJfYyhcIiArIGNvbXBvbmVudE5hbWUgKyBcIixcIiArIChnZW5EYXRhJDIoZWwsIHN0YXRlKSkgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJykgKyBcIilcIilcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlblByb3BzIChwcm9wcykge1xuICAgIHZhciBzdGF0aWNQcm9wcyA9IFwiXCI7XG4gICAgdmFyIGR5bmFtaWNQcm9wcyA9IFwiXCI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcbiAgICAgIHZhciB2YWx1ZSA9IHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhwcm9wLnZhbHVlKTtcbiAgICAgIGlmIChwcm9wLmR5bmFtaWMpIHtcbiAgICAgICAgZHluYW1pY1Byb3BzICs9IChwcm9wLm5hbWUpICsgXCIsXCIgKyB2YWx1ZSArIFwiLFwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGljUHJvcHMgKz0gXCJcXFwiXCIgKyAocHJvcC5uYW1lKSArIFwiXFxcIjpcIiArIHZhbHVlICsgXCIsXCI7XG4gICAgICB9XG4gICAgfVxuICAgIHN0YXRpY1Byb3BzID0gXCJ7XCIgKyAoc3RhdGljUHJvcHMuc2xpY2UoMCwgLTEpKSArIFwifVwiO1xuICAgIGlmIChkeW5hbWljUHJvcHMpIHtcbiAgICAgIHJldHVybiAoXCJfZChcIiArIHN0YXRpY1Byb3BzICsgXCIsW1wiICsgKGR5bmFtaWNQcm9wcy5zbGljZSgwLCAtMSkpICsgXCJdKVwiKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3RhdGljUHJvcHNcbiAgICB9XG4gIH1cblxuICAvLyAjMzg5NSwgIzQyNjhcbiAgZnVuY3Rpb24gdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzICh0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHRcbiAgICAgIC5yZXBsYWNlKC9cXHUyMDI4L2csICdcXFxcdTIwMjgnKVxuICAgICAgLnJlcGxhY2UoL1xcdTIwMjkvZywgJ1xcXFx1MjAyOScpXG4gIH1cblxuICAvKiAgKi9cblxuXG5cbiAgLy8gdGhlc2Uga2V5d29yZHMgc2hvdWxkIG5vdCBhcHBlYXIgaW5zaWRlIGV4cHJlc3Npb25zLCBidXQgb3BlcmF0b3JzIGxpa2VcbiAgLy8gdHlwZW9mLCBpbnN0YW5jZW9mIGFuZCBpbiBhcmUgYWxsb3dlZFxuICB2YXIgcHJvaGliaXRlZEtleXdvcmRSRSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArIChcbiAgICAnZG8saWYsZm9yLGxldCxuZXcsdHJ5LHZhcixjYXNlLGVsc2Usd2l0aCxhd2FpdCxicmVhayxjYXRjaCxjbGFzcyxjb25zdCwnICtcbiAgICAnc3VwZXIsdGhyb3csd2hpbGUseWllbGQsZGVsZXRlLGV4cG9ydCxpbXBvcnQscmV0dXJuLHN3aXRjaCxkZWZhdWx0LCcgK1xuICAgICdleHRlbmRzLGZpbmFsbHksY29udGludWUsZGVidWdnZXIsZnVuY3Rpb24sYXJndW1lbnRzJ1xuICApLnNwbGl0KCcsJykuam9pbignXFxcXGJ8XFxcXGInKSArICdcXFxcYicpO1xuXG4gIC8vIHRoZXNlIHVuYXJ5IG9wZXJhdG9ycyBzaG91bGQgbm90IGJlIHVzZWQgYXMgcHJvcGVydHkvbWV0aG9kIG5hbWVzXG4gIHZhciB1bmFyeU9wZXJhdG9yc1JFID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgKFxuICAgICdkZWxldGUsdHlwZW9mLHZvaWQnXG4gICkuc3BsaXQoJywnKS5qb2luKCdcXFxccypcXFxcKFteXFxcXCldKlxcXFwpfFxcXFxiJykgKyAnXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKScpO1xuXG4gIC8vIHN0cmlwIHN0cmluZ3MgaW4gZXhwcmVzc2lvbnNcbiAgdmFyIHN0cmlwU3RyaW5nUkUgPSAvJyg/OlteJ1xcXFxdfFxcXFwuKSonfFwiKD86W15cIlxcXFxdfFxcXFwuKSpcInxgKD86W15gXFxcXF18XFxcXC4pKlxcJFxce3xcXH0oPzpbXmBcXFxcXXxcXFxcLikqYHxgKD86W15gXFxcXF18XFxcXC4pKmAvZztcblxuICAvLyBkZXRlY3QgcHJvYmxlbWF0aWMgZXhwcmVzc2lvbnMgaW4gYSB0ZW1wbGF0ZVxuICBmdW5jdGlvbiBkZXRlY3RFcnJvcnMgKGFzdCwgd2Fybikge1xuICAgIGlmIChhc3QpIHtcbiAgICAgIGNoZWNrTm9kZShhc3QsIHdhcm4pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrTm9kZSAobm9kZSwgd2Fybikge1xuICAgIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gbm9kZS5hdHRyc01hcCkge1xuICAgICAgICBpZiAoZGlyUkUudGVzdChuYW1lKSkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IG5vZGUuYXR0cnNNYXBbbmFtZV07XG4gICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBub2RlLnJhd0F0dHJzTWFwW25hbWVdO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICd2LWZvcicpIHtcbiAgICAgICAgICAgICAgY2hlY2tGb3Iobm9kZSwgKFwidi1mb3I9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIHdhcm4sIHJhbmdlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob25SRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgICAgIGNoZWNrRXZlbnQodmFsdWUsIChuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIHdhcm4sIHJhbmdlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNoZWNrRXhwcmVzc2lvbih2YWx1ZSwgKG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgd2FybiwgcmFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY2hlY2tOb2RlKG5vZGUuY2hpbGRyZW5baV0sIHdhcm4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IDIpIHtcbiAgICAgIGNoZWNrRXhwcmVzc2lvbihub2RlLmV4cHJlc3Npb24sIG5vZGUudGV4dCwgd2Fybiwgbm9kZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tFdmVudCAoZXhwLCB0ZXh0LCB3YXJuLCByYW5nZSkge1xuICAgIHZhciBzdGlwcGVkID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpO1xuICAgIHZhciBrZXl3b3JkTWF0Y2ggPSBzdGlwcGVkLm1hdGNoKHVuYXJ5T3BlcmF0b3JzUkUpO1xuICAgIGlmIChrZXl3b3JkTWF0Y2ggJiYgc3RpcHBlZC5jaGFyQXQoa2V5d29yZE1hdGNoLmluZGV4IC0gMSkgIT09ICckJykge1xuICAgICAgd2FybihcbiAgICAgICAgXCJhdm9pZCB1c2luZyBKYXZhU2NyaXB0IHVuYXJ5IG9wZXJhdG9yIGFzIHByb3BlcnR5IG5hbWU6IFwiICtcbiAgICAgICAgXCJcXFwiXCIgKyAoa2V5d29yZE1hdGNoWzBdKSArIFwiXFxcIiBpbiBleHByZXNzaW9uIFwiICsgKHRleHQudHJpbSgpKSxcbiAgICAgICAgcmFuZ2VcbiAgICAgICk7XG4gICAgfVxuICAgIGNoZWNrRXhwcmVzc2lvbihleHAsIHRleHQsIHdhcm4sIHJhbmdlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrRm9yIChub2RlLCB0ZXh0LCB3YXJuLCByYW5nZSkge1xuICAgIGNoZWNrRXhwcmVzc2lvbihub2RlLmZvciB8fCAnJywgdGV4dCwgd2FybiwgcmFuZ2UpO1xuICAgIGNoZWNrSWRlbnRpZmllcihub2RlLmFsaWFzLCAndi1mb3IgYWxpYXMnLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG4gICAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IxLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG4gICAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IyLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0lkZW50aWZpZXIgKFxuICAgIGlkZW50LFxuICAgIHR5cGUsXG4gICAgdGV4dCxcbiAgICB3YXJuLFxuICAgIHJhbmdlXG4gICkge1xuICAgIGlmICh0eXBlb2YgaWRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICBuZXcgRnVuY3Rpb24oKFwidmFyIFwiICsgaWRlbnQgKyBcIj1fXCIpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgd2FybigoXCJpbnZhbGlkIFwiICsgdHlwZSArIFwiIFxcXCJcIiArIGlkZW50ICsgXCJcXFwiIGluIGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSksIHJhbmdlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0V4cHJlc3Npb24gKGV4cCwgdGV4dCwgd2FybiwgcmFuZ2UpIHtcbiAgICB0cnkge1xuICAgICAgbmV3IEZ1bmN0aW9uKChcInJldHVybiBcIiArIGV4cCkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHZhciBrZXl3b3JkTWF0Y2ggPSBleHAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCAnJykubWF0Y2gocHJvaGliaXRlZEtleXdvcmRSRSk7XG4gICAgICBpZiAoa2V5d29yZE1hdGNoKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJhdm9pZCB1c2luZyBKYXZhU2NyaXB0IGtleXdvcmQgYXMgcHJvcGVydHkgbmFtZTogXCIgK1xuICAgICAgICAgIFwiXFxcIlwiICsgKGtleXdvcmRNYXRjaFswXSkgKyBcIlxcXCJcXG4gIFJhdyBleHByZXNzaW9uOiBcIiArICh0ZXh0LnRyaW0oKSksXG4gICAgICAgICAgcmFuZ2VcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJpbnZhbGlkIGV4cHJlc3Npb246IFwiICsgKGUubWVzc2FnZSkgKyBcIiBpblxcblxcblwiICtcbiAgICAgICAgICBcIiAgICBcIiArIGV4cCArIFwiXFxuXFxuXCIgK1xuICAgICAgICAgIFwiICBSYXcgZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpICsgXCJcXG5cIixcbiAgICAgICAgICByYW5nZVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIHZhciByYW5nZSA9IDI7XG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGVDb2RlRnJhbWUgKFxuICAgIHNvdXJjZSxcbiAgICBzdGFydCxcbiAgICBlbmRcbiAgKSB7XG4gICAgaWYgKCBzdGFydCA9PT0gdm9pZCAwICkgc3RhcnQgPSAwO1xuICAgIGlmICggZW5kID09PSB2b2lkIDAgKSBlbmQgPSBzb3VyY2UubGVuZ3RoO1xuXG4gICAgdmFyIGxpbmVzID0gc291cmNlLnNwbGl0KC9cXHI/XFxuLyk7XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgY291bnQgKz0gbGluZXNbaV0ubGVuZ3RoICsgMTtcbiAgICAgIGlmIChjb3VudCA+PSBzdGFydCkge1xuICAgICAgICBmb3IgKHZhciBqID0gaSAtIHJhbmdlOyBqIDw9IGkgKyByYW5nZSB8fCBlbmQgPiBjb3VudDsgaisrKSB7XG4gICAgICAgICAgaWYgKGogPCAwIHx8IGogPj0gbGluZXMubGVuZ3RoKSB7IGNvbnRpbnVlIH1cbiAgICAgICAgICByZXMucHVzaCgoXCJcIiArIChqICsgMSkgKyAocmVwZWF0JDEoXCIgXCIsIDMgLSBTdHJpbmcoaiArIDEpLmxlbmd0aCkpICsgXCJ8ICBcIiArIChsaW5lc1tqXSkpKTtcbiAgICAgICAgICB2YXIgbGluZUxlbmd0aCA9IGxpbmVzW2pdLmxlbmd0aDtcbiAgICAgICAgICBpZiAoaiA9PT0gaSkge1xuICAgICAgICAgICAgLy8gcHVzaCB1bmRlcmxpbmVcbiAgICAgICAgICAgIHZhciBwYWQgPSBzdGFydCAtIChjb3VudCAtIGxpbmVMZW5ndGgpICsgMTtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBlbmQgPiBjb3VudCA/IGxpbmVMZW5ndGggLSBwYWQgOiBlbmQgLSBzdGFydDtcbiAgICAgICAgICAgIHJlcy5wdXNoKFwiICAgfCAgXCIgKyByZXBlYXQkMShcIiBcIiwgcGFkKSArIHJlcGVhdCQxKFwiXlwiLCBsZW5ndGgpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGogPiBpKSB7XG4gICAgICAgICAgICBpZiAoZW5kID4gY291bnQpIHtcbiAgICAgICAgICAgICAgdmFyIGxlbmd0aCQxID0gTWF0aC5taW4oZW5kIC0gY291bnQsIGxpbmVMZW5ndGgpO1xuICAgICAgICAgICAgICByZXMucHVzaChcIiAgIHwgIFwiICsgcmVwZWF0JDEoXCJeXCIsIGxlbmd0aCQxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb3VudCArPSBsaW5lTGVuZ3RoICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcy5qb2luKCdcXG4nKVxuICB9XG5cbiAgZnVuY3Rpb24gcmVwZWF0JDEgKHN0ciwgbikge1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICBpZiAobiA+IDApIHtcbiAgICAgIHdoaWxlICh0cnVlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgaWYgKG4gJiAxKSB7IHJlc3VsdCArPSBzdHI7IH1cbiAgICAgICAgbiA+Pj49IDE7XG4gICAgICAgIGlmIChuIDw9IDApIHsgYnJlYWsgfVxuICAgICAgICBzdHIgKz0gc3RyO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICAvKiAgKi9cblxuXG5cbiAgZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb24gKGNvZGUsIGVycm9ycykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKGNvZGUpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBlcnJvcnMucHVzaCh7IGVycjogZXJyLCBjb2RlOiBjb2RlIH0pO1xuICAgICAgcmV0dXJuIG5vb3BcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDb21waWxlVG9GdW5jdGlvbkZuIChjb21waWxlKSB7XG4gICAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiBjb21waWxlVG9GdW5jdGlvbnMgKFxuICAgICAgdGVtcGxhdGUsXG4gICAgICBvcHRpb25zLFxuICAgICAgdm1cbiAgICApIHtcbiAgICAgIG9wdGlvbnMgPSBleHRlbmQoe30sIG9wdGlvbnMpO1xuICAgICAgdmFyIHdhcm4kJDEgPSBvcHRpb25zLndhcm4gfHwgd2FybjtcbiAgICAgIGRlbGV0ZSBvcHRpb25zLndhcm47XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAge1xuICAgICAgICAvLyBkZXRlY3QgcG9zc2libGUgQ1NQIHJlc3RyaWN0aW9uXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gMScpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGUudG9TdHJpbmcoKS5tYXRjaCgvdW5zYWZlLWV2YWx8Q1NQLykpIHtcbiAgICAgICAgICAgIHdhcm4kJDEoXG4gICAgICAgICAgICAgICdJdCBzZWVtcyB5b3UgYXJlIHVzaW5nIHRoZSBzdGFuZGFsb25lIGJ1aWxkIG9mIFZ1ZS5qcyBpbiBhbiAnICtcbiAgICAgICAgICAgICAgJ2Vudmlyb25tZW50IHdpdGggQ29udGVudCBTZWN1cml0eSBQb2xpY3kgdGhhdCBwcm9oaWJpdHMgdW5zYWZlLWV2YWwuICcgK1xuICAgICAgICAgICAgICAnVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGNhbm5vdCB3b3JrIGluIHRoaXMgZW52aXJvbm1lbnQuIENvbnNpZGVyICcgK1xuICAgICAgICAgICAgICAncmVsYXhpbmcgdGhlIHBvbGljeSB0byBhbGxvdyB1bnNhZmUtZXZhbCBvciBwcmUtY29tcGlsaW5nIHlvdXIgJyArXG4gICAgICAgICAgICAgICd0ZW1wbGF0ZXMgaW50byByZW5kZXIgZnVuY3Rpb25zLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIGNhY2hlXG4gICAgICB2YXIga2V5ID0gb3B0aW9ucy5kZWxpbWl0ZXJzXG4gICAgICAgID8gU3RyaW5nKG9wdGlvbnMuZGVsaW1pdGVycykgKyB0ZW1wbGF0ZVxuICAgICAgICA6IHRlbXBsYXRlO1xuICAgICAgaWYgKGNhY2hlW2tleV0pIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlW2tleV1cbiAgICAgIH1cblxuICAgICAgLy8gY29tcGlsZVxuICAgICAgdmFyIGNvbXBpbGVkID0gY29tcGlsZSh0ZW1wbGF0ZSwgb3B0aW9ucyk7XG5cbiAgICAgIC8vIGNoZWNrIGNvbXBpbGF0aW9uIGVycm9ycy90aXBzXG4gICAgICB7XG4gICAgICAgIGlmIChjb21waWxlZC5lcnJvcnMgJiYgY29tcGlsZWQuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgICBjb21waWxlZC5lcnJvcnMuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICB3YXJuJCQxKFxuICAgICAgICAgICAgICAgIFwiRXJyb3IgY29tcGlsaW5nIHRlbXBsYXRlOlxcblxcblwiICsgKGUubXNnKSArIFwiXFxuXFxuXCIgK1xuICAgICAgICAgICAgICAgIGdlbmVyYXRlQ29kZUZyYW1lKHRlbXBsYXRlLCBlLnN0YXJ0LCBlLmVuZCksXG4gICAgICAgICAgICAgICAgdm1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3YXJuJCQxKFxuICAgICAgICAgICAgICBcIkVycm9yIGNvbXBpbGluZyB0ZW1wbGF0ZTpcXG5cXG5cIiArIHRlbXBsYXRlICsgXCJcXG5cXG5cIiArXG4gICAgICAgICAgICAgIGNvbXBpbGVkLmVycm9ycy5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIChcIi0gXCIgKyBlKTsgfSkuam9pbignXFxuJykgKyAnXFxuJyxcbiAgICAgICAgICAgICAgdm1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb21waWxlZC50aXBzICYmIGNvbXBpbGVkLnRpcHMubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICAgIGNvbXBpbGVkLnRpcHMuZm9yRWFjaChmdW5jdGlvbiAoZSkgeyByZXR1cm4gdGlwKGUubXNnLCB2bSk7IH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb21waWxlZC50aXBzLmZvckVhY2goZnVuY3Rpb24gKG1zZykgeyByZXR1cm4gdGlwKG1zZywgdm0pOyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gdHVybiBjb2RlIGludG8gZnVuY3Rpb25zXG4gICAgICB2YXIgcmVzID0ge307XG4gICAgICB2YXIgZm5HZW5FcnJvcnMgPSBbXTtcbiAgICAgIHJlcy5yZW5kZXIgPSBjcmVhdGVGdW5jdGlvbihjb21waWxlZC5yZW5kZXIsIGZuR2VuRXJyb3JzKTtcbiAgICAgIHJlcy5zdGF0aWNSZW5kZXJGbnMgPSBjb21waWxlZC5zdGF0aWNSZW5kZXJGbnMubWFwKGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbihjb2RlLCBmbkdlbkVycm9ycylcbiAgICAgIH0pO1xuXG4gICAgICAvLyBjaGVjayBmdW5jdGlvbiBnZW5lcmF0aW9uIGVycm9ycy5cbiAgICAgIC8vIHRoaXMgc2hvdWxkIG9ubHkgaGFwcGVuIGlmIHRoZXJlIGlzIGEgYnVnIGluIHRoZSBjb21waWxlciBpdHNlbGYuXG4gICAgICAvLyBtb3N0bHkgZm9yIGNvZGVnZW4gZGV2ZWxvcG1lbnQgdXNlXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIHtcbiAgICAgICAgaWYgKCghY29tcGlsZWQuZXJyb3JzIHx8ICFjb21waWxlZC5lcnJvcnMubGVuZ3RoKSAmJiBmbkdlbkVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICB3YXJuJCQxKFxuICAgICAgICAgICAgXCJGYWlsZWQgdG8gZ2VuZXJhdGUgcmVuZGVyIGZ1bmN0aW9uOlxcblxcblwiICtcbiAgICAgICAgICAgIGZuR2VuRXJyb3JzLm1hcChmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgICAgICAgIHZhciBlcnIgPSByZWYuZXJyO1xuICAgICAgICAgICAgICB2YXIgY29kZSA9IHJlZi5jb2RlO1xuXG4gICAgICAgICAgICAgIHJldHVybiAoKGVyci50b1N0cmluZygpKSArIFwiIGluXFxuXFxuXCIgKyBjb2RlICsgXCJcXG5cIik7XG4gICAgICAgICAgfSkuam9pbignXFxuJyksXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIChjYWNoZVtrZXldID0gcmVzKVxuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyQ3JlYXRvciAoYmFzZUNvbXBpbGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXIgKGJhc2VPcHRpb25zKSB7XG4gICAgICBmdW5jdGlvbiBjb21waWxlIChcbiAgICAgICAgdGVtcGxhdGUsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgICkge1xuICAgICAgICB2YXIgZmluYWxPcHRpb25zID0gT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucyk7XG4gICAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgICAgdmFyIHRpcHMgPSBbXTtcblxuICAgICAgICB2YXIgd2FybiA9IGZ1bmN0aW9uIChtc2csIHJhbmdlLCB0aXApIHtcbiAgICAgICAgICAodGlwID8gdGlwcyA6IGVycm9ycykucHVzaChtc2cpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgICAgICAgdmFyIGxlYWRpbmdTcGFjZUxlbmd0aCA9IHRlbXBsYXRlLm1hdGNoKC9eXFxzKi8pWzBdLmxlbmd0aDtcblxuICAgICAgICAgICAgd2FybiA9IGZ1bmN0aW9uIChtc2csIHJhbmdlLCB0aXApIHtcbiAgICAgICAgICAgICAgdmFyIGRhdGEgPSB7IG1zZzogbXNnIH07XG4gICAgICAgICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZS5zdGFydCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBkYXRhLnN0YXJ0ID0gcmFuZ2Uuc3RhcnQgKyBsZWFkaW5nU3BhY2VMZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyYW5nZS5lbmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgZGF0YS5lbmQgPSByYW5nZS5lbmQgKyBsZWFkaW5nU3BhY2VMZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICh0aXAgPyB0aXBzIDogZXJyb3JzKS5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gbWVyZ2UgY3VzdG9tIG1vZHVsZXNcbiAgICAgICAgICBpZiAob3B0aW9ucy5tb2R1bGVzKSB7XG4gICAgICAgICAgICBmaW5hbE9wdGlvbnMubW9kdWxlcyA9XG4gICAgICAgICAgICAgIChiYXNlT3B0aW9ucy5tb2R1bGVzIHx8IFtdKS5jb25jYXQob3B0aW9ucy5tb2R1bGVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gbWVyZ2UgY3VzdG9tIGRpcmVjdGl2ZXNcbiAgICAgICAgICBpZiAob3B0aW9ucy5kaXJlY3RpdmVzKSB7XG4gICAgICAgICAgICBmaW5hbE9wdGlvbnMuZGlyZWN0aXZlcyA9IGV4dGVuZChcbiAgICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucy5kaXJlY3RpdmVzIHx8IG51bGwpLFxuICAgICAgICAgICAgICBvcHRpb25zLmRpcmVjdGl2ZXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGNvcHkgb3RoZXIgb3B0aW9uc1xuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSAnbW9kdWxlcycgJiYga2V5ICE9PSAnZGlyZWN0aXZlcycpIHtcbiAgICAgICAgICAgICAgZmluYWxPcHRpb25zW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZmluYWxPcHRpb25zLndhcm4gPSB3YXJuO1xuXG4gICAgICAgIHZhciBjb21waWxlZCA9IGJhc2VDb21waWxlKHRlbXBsYXRlLnRyaW0oKSwgZmluYWxPcHRpb25zKTtcbiAgICAgICAge1xuICAgICAgICAgIGRldGVjdEVycm9ycyhjb21waWxlZC5hc3QsIHdhcm4pO1xuICAgICAgICB9XG4gICAgICAgIGNvbXBpbGVkLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgY29tcGlsZWQudGlwcyA9IHRpcHM7XG4gICAgICAgIHJldHVybiBjb21waWxlZFxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb21waWxlOiBjb21waWxlLFxuICAgICAgICBjb21waWxlVG9GdW5jdGlvbnM6IGNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4oY29tcGlsZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICAvLyBgY3JlYXRlQ29tcGlsZXJDcmVhdG9yYCBhbGxvd3MgY3JlYXRpbmcgY29tcGlsZXJzIHRoYXQgdXNlIGFsdGVybmF0aXZlXG4gIC8vIHBhcnNlci9vcHRpbWl6ZXIvY29kZWdlbiwgZS5nIHRoZSBTU1Igb3B0aW1pemluZyBjb21waWxlci5cbiAgLy8gSGVyZSB3ZSBqdXN0IGV4cG9ydCBhIGRlZmF1bHQgY29tcGlsZXIgdXNpbmcgdGhlIGRlZmF1bHQgcGFydHMuXG4gIHZhciBjcmVhdGVDb21waWxlciA9IGNyZWF0ZUNvbXBpbGVyQ3JlYXRvcihmdW5jdGlvbiBiYXNlQ29tcGlsZSAoXG4gICAgdGVtcGxhdGUsXG4gICAgb3B0aW9uc1xuICApIHtcbiAgICB2YXIgYXN0ID0gcGFyc2UodGVtcGxhdGUudHJpbSgpLCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5vcHRpbWl6ZSAhPT0gZmFsc2UpIHtcbiAgICAgIG9wdGltaXplKGFzdCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHZhciBjb2RlID0gZ2VuZXJhdGUoYXN0LCBvcHRpb25zKTtcbiAgICByZXR1cm4ge1xuICAgICAgYXN0OiBhc3QsXG4gICAgICByZW5kZXI6IGNvZGUucmVuZGVyLFxuICAgICAgc3RhdGljUmVuZGVyRm5zOiBjb2RlLnN0YXRpY1JlbmRlckZuc1xuICAgIH1cbiAgfSk7XG5cbiAgLyogICovXG5cbiAgdmFyIHJlZiQxID0gY3JlYXRlQ29tcGlsZXIoYmFzZU9wdGlvbnMpO1xuICB2YXIgY29tcGlsZSA9IHJlZiQxLmNvbXBpbGU7XG4gIHZhciBjb21waWxlVG9GdW5jdGlvbnMgPSByZWYkMS5jb21waWxlVG9GdW5jdGlvbnM7XG5cbiAgLyogICovXG5cbiAgLy8gY2hlY2sgd2hldGhlciBjdXJyZW50IGJyb3dzZXIgZW5jb2RlcyBhIGNoYXIgaW5zaWRlIGF0dHJpYnV0ZSB2YWx1ZXNcbiAgdmFyIGRpdjtcbiAgZnVuY3Rpb24gZ2V0U2hvdWxkRGVjb2RlIChocmVmKSB7XG4gICAgZGl2ID0gZGl2IHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRpdi5pbm5lckhUTUwgPSBocmVmID8gXCI8YSBocmVmPVxcXCJcXG5cXFwiLz5cIiA6IFwiPGRpdiBhPVxcXCJcXG5cXFwiLz5cIjtcbiAgICByZXR1cm4gZGl2LmlubmVySFRNTC5pbmRleE9mKCcmIzEwOycpID4gMFxuICB9XG5cbiAgLy8gIzM2NjM6IElFIGVuY29kZXMgbmV3bGluZXMgaW5zaWRlIGF0dHJpYnV0ZSB2YWx1ZXMgd2hpbGUgb3RoZXIgYnJvd3NlcnMgZG9uJ3RcbiAgdmFyIHNob3VsZERlY29kZU5ld2xpbmVzID0gaW5Ccm93c2VyID8gZ2V0U2hvdWxkRGVjb2RlKGZhbHNlKSA6IGZhbHNlO1xuICAvLyAjNjgyODogY2hyb21lIGVuY29kZXMgY29udGVudCBpbiBhW2hyZWZdXG4gIHZhciBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYgPSBpbkJyb3dzZXIgPyBnZXRTaG91bGREZWNvZGUodHJ1ZSkgOiBmYWxzZTtcblxuICAvKiAgKi9cblxuICB2YXIgaWRUb1RlbXBsYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBlbCA9IHF1ZXJ5KGlkKTtcbiAgICByZXR1cm4gZWwgJiYgZWwuaW5uZXJIVE1MXG4gIH0pO1xuXG4gIHZhciBtb3VudCA9IFZ1ZS5wcm90b3R5cGUuJG1vdW50O1xuICBWdWUucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgICBlbCxcbiAgICBoeWRyYXRpbmdcbiAgKSB7XG4gICAgZWwgPSBlbCAmJiBxdWVyeShlbCk7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoZWwgPT09IGRvY3VtZW50LmJvZHkgfHwgZWwgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgd2FybihcbiAgICAgICAgXCJEbyBub3QgbW91bnQgVnVlIHRvIDxodG1sPiBvciA8Ym9keT4gLSBtb3VudCB0byBub3JtYWwgZWxlbWVudHMgaW5zdGVhZC5cIlxuICAgICAgKTtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zO1xuICAgIC8vIHJlc29sdmUgdGVtcGxhdGUvZWwgYW5kIGNvbnZlcnQgdG8gcmVuZGVyIGZ1bmN0aW9uXG4gICAgaWYgKCFvcHRpb25zLnJlbmRlcikge1xuICAgICAgdmFyIHRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZTtcbiAgICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmICh0ZW1wbGF0ZS5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgICAgICAgdGVtcGxhdGUgPSBpZFRvVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAoIXRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgKFwiVGVtcGxhdGUgZWxlbWVudCBub3QgZm91bmQgb3IgaXMgZW1wdHk6IFwiICsgKG9wdGlvbnMudGVtcGxhdGUpKSxcbiAgICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRlbXBsYXRlLm5vZGVUeXBlKSB7XG4gICAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5pbm5lckhUTUw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgd2FybignaW52YWxpZCB0ZW1wbGF0ZSBvcHRpb246JyArIHRlbXBsYXRlLCB0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChlbCkge1xuICAgICAgICB0ZW1wbGF0ZSA9IGdldE91dGVySFRNTChlbCk7XG4gICAgICB9XG4gICAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICAgIG1hcmsoJ2NvbXBpbGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZWYgPSBjb21waWxlVG9GdW5jdGlvbnModGVtcGxhdGUsIHtcbiAgICAgICAgICBvdXRwdXRTb3VyY2VSYW5nZTogXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicsXG4gICAgICAgICAgc2hvdWxkRGVjb2RlTmV3bGluZXM6IHNob3VsZERlY29kZU5ld2xpbmVzLFxuICAgICAgICAgIHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZjogc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmLFxuICAgICAgICAgIGRlbGltaXRlcnM6IG9wdGlvbnMuZGVsaW1pdGVycyxcbiAgICAgICAgICBjb21tZW50czogb3B0aW9ucy5jb21tZW50c1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgdmFyIHJlbmRlciA9IHJlZi5yZW5kZXI7XG4gICAgICAgIHZhciBzdGF0aWNSZW5kZXJGbnMgPSByZWYuc3RhdGljUmVuZGVyRm5zO1xuICAgICAgICBvcHRpb25zLnJlbmRlciA9IHJlbmRlcjtcbiAgICAgICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnM7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICAgIG1hcmsoJ2NvbXBpbGUgZW5kJyk7XG4gICAgICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyAodGhpcy5fbmFtZSkgKyBcIiBjb21waWxlXCIpLCAnY29tcGlsZScsICdjb21waWxlIGVuZCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtb3VudC5jYWxsKHRoaXMsIGVsLCBoeWRyYXRpbmcpXG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBvdXRlckhUTUwgb2YgZWxlbWVudHMsIHRha2luZyBjYXJlXG4gICAqIG9mIFNWRyBlbGVtZW50cyBpbiBJRSBhcyB3ZWxsLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0T3V0ZXJIVE1MIChlbCkge1xuICAgIGlmIChlbC5vdXRlckhUTUwpIHtcbiAgICAgIHJldHVybiBlbC5vdXRlckhUTUxcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGVsLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgICByZXR1cm4gY29udGFpbmVyLmlubmVySFRNTFxuICAgIH1cbiAgfVxuXG4gIFZ1ZS5jb21waWxlID0gY29tcGlsZVRvRnVuY3Rpb25zO1xuXG4gIHJldHVybiBWdWU7XG5cbn0pKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/vue/dist/vue.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar g; // This works in non-strict mode\n\ng = function () {\n  return this;\n}();\n\ntry {\n  // This works if eval is allowed (see CSP)\n  g = g || new Function(\"return this\")();\n} catch (e) {\n  // This works if the window reference is available\n  if ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\") g = window;\n} // g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\n\nmodule.exports = g;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzP2NkMDAiXSwibmFtZXMiOlsiZyIsIkZ1bmN0aW9uIiwiZSIsIndpbmRvdyIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7O0FBQUEsSUFBSUEsQ0FBSixDLENBRUE7O0FBQ0FBLENBQUMsR0FBSSxZQUFXO0FBQ2YsU0FBTyxJQUFQO0FBQ0EsQ0FGRyxFQUFKOztBQUlBLElBQUk7QUFDSDtBQUNBQSxHQUFDLEdBQUdBLENBQUMsSUFBSSxJQUFJQyxRQUFKLENBQWEsYUFBYixHQUFUO0FBQ0EsQ0FIRCxDQUdFLE9BQU9DLENBQVAsRUFBVTtBQUNYO0FBQ0EsTUFBSSxRQUFPQyxNQUFQLHlDQUFPQSxNQUFQLE9BQWtCLFFBQXRCLEVBQWdDSCxDQUFDLEdBQUdHLE1BQUo7QUFDaEMsQyxDQUVEO0FBQ0E7QUFDQTs7O0FBRUFDLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQkwsQ0FBakIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2dsb2JhbC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/global.js\n");

/***/ }),

/***/ "./src/js/app.js":
/*!***********************!*\
  !*** ./src/js/app.js ***!
  \***********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
<<<<<<< HEAD
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.js\");\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_0__);\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n\ndocument.querySelectorAll('[data-plan=\"calculator\"]').forEach(function (el) {\n  var plans = JSON.parse(el.getAttribute('data-payload'));\n  el.removeAttribute('data-plan');\n  el.removeAttribute('data-payload');\n  new vue__WEBPACK_IMPORTED_MODULE_0___default.a({\n    el: el,\n    data: function data() {\n      return {\n        currency: \"$\",\n        plans: plans,\n        planTerm: plans.usd.minDuration,\n        // planTerm: plan.minDuration,\n        deposit: 0,\n        isRulesAccepted: false\n      };\n    },\n    computed: {\n      plan: function plan() {\n        if (this.currency === \"$\") {\n          return this.plans.usd;\n        } else {\n          return this.plans.btc;\n        }\n      },\n      minInvestBitcoin: function minInvestBitcoin() {\n        return this.plan.minInvest.toFixed(8);\n      },\n      maxInvestBitcoin: function maxInvestBitcoin() {\n        return this.plan.maxInvest.toFixed(8);\n      },\n      isDepositCorrect: function isDepositCorrect() {\n        return this.deposit >= this.plan.minInvest && this.deposit <= this.plan.maxInvest;\n      },\n      totalProfit: function totalProfit() {\n        var totalProfitRaw = this.deposit * this.planTerm * this.plan.profit;\n        var totalProfit = this.plan.bodyReturn ? totalProfitRaw + this.deposit : totalProfitRaw;\n\n        if (this.currency === \"$\") {\n          return totalProfit.toFixed(0);\n        } else {\n          return totalProfit.toFixed(10);\n        }\n      },\n      isAllFieldsVerified: function isAllFieldsVerified() {\n        return this.isDepositCorrect && this.isRulesAccepted;\n      },\n      someFieldsIncorrect: function someFieldsIncorrect() {\n        return !this.isAllFieldsVerified;\n      }\n    },\n    methods: {\n      makeDeposit: function makeDeposit() {\n        var popup = document.querySelector('.popup');\n        popup.style.display = \"flex\";\n        document.querySelector('.popup__btn-close').addEventListener(\"click\", function () {\n          popup.style.display = \"none\";\n        }.bind(this));\n        document.querySelector('.overlay').addEventListener(\"click\", function () {\n          popup.style.display = \"none\";\n        }.bind(this));\n      },\n      chooseCurrency: function chooseCurrency(event) {\n        this.deposit = 0;\n        this.planTerm = this.plan.minDuration;\n        var currencyLabels = event.target.closest('.plan__currencies').children;\n\n        for (var i = 0, child; child = currencyLabels[i]; i++) {\n          child.classList.remove('selected');\n        }\n\n        event.target.parentNode.classList.add('selected');\n      },\n      indicateCurrencySymbol: function indicateCurrencySymbol(input, spans) {\n        if (input.checked) {\n          spans.forEach(function (span) {\n            span.innerHTML = \"₿\";\n          });\n        } else {\n          spans.forEach(function (span) {\n            span.innerHTML = \"$\";\n          });\n        }\n      },\n      convertToDecimal: function convertToDecimal(event) {\n        console.log('typeof Value: ', _typeof(event.target.value)); // event.target.value = parseFloat(event.target.value);\n        // event.target.value = (event.target.value).toFixed(8);\n        // event.target.value = \"0.0000000\" + String(event.target.value).charAt(0);\n      }\n    }\n  });\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvYXBwLmpzPzkwZTkiXSwibmFtZXMiOlsiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZm9yRWFjaCIsImVsIiwicGxhbnMiLCJKU09OIiwicGFyc2UiLCJnZXRBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJWdWUiLCJkYXRhIiwiY3VycmVuY3kiLCJwbGFuVGVybSIsInVzZCIsIm1pbkR1cmF0aW9uIiwiZGVwb3NpdCIsImlzUnVsZXNBY2NlcHRlZCIsImNvbXB1dGVkIiwicGxhbiIsImJ0YyIsIm1pbkludmVzdEJpdGNvaW4iLCJtaW5JbnZlc3QiLCJ0b0ZpeGVkIiwibWF4SW52ZXN0Qml0Y29pbiIsIm1heEludmVzdCIsImlzRGVwb3NpdENvcnJlY3QiLCJ0b3RhbFByb2ZpdCIsInRvdGFsUHJvZml0UmF3IiwicHJvZml0IiwiYm9keVJldHVybiIsImlzQWxsRmllbGRzVmVyaWZpZWQiLCJzb21lRmllbGRzSW5jb3JyZWN0IiwibWV0aG9kcyIsIm1ha2VEZXBvc2l0IiwicG9wdXAiLCJxdWVyeVNlbGVjdG9yIiwic3R5bGUiLCJkaXNwbGF5IiwiYWRkRXZlbnRMaXN0ZW5lciIsImJpbmQiLCJjaG9vc2VDdXJyZW5jeSIsImV2ZW50IiwiY3VycmVuY3lMYWJlbHMiLCJ0YXJnZXQiLCJjbG9zZXN0IiwiY2hpbGRyZW4iLCJpIiwiY2hpbGQiLCJjbGFzc0xpc3QiLCJyZW1vdmUiLCJwYXJlbnROb2RlIiwiYWRkIiwiaW5kaWNhdGVDdXJyZW5jeVN5bWJvbCIsImlucHV0Iiwic3BhbnMiLCJjaGVja2VkIiwic3BhbiIsImlubmVySFRNTCIsImNvbnZlcnRUb0RlY2ltYWwiLCJjb25zb2xlIiwibG9nIiwidmFsdWUiXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFFQUEsUUFBUSxDQUFDQyxnQkFBVCxDQUEwQiwwQkFBMUIsRUFBc0RDLE9BQXRELENBQThELFVBQUFDLEVBQUUsRUFBSTtBQUVsRSxNQUFNQyxL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cy9hcHAuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgVnVlIGZyb20gXCJ2dWVcIjtcclxuXHJcbmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXBsYW49XCJjYWxjdWxhdG9yXCJdJykuZm9yRWFjaChlbCA9PiB7XHJcblxyXG4gIGNvbnN0IHBsYW5zID0gSlNPTi5wYXJzZShlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcGF5bG9hZCcpKTtcclxuXHJcbiAgZWwucmVtb3ZlQXR0cmlidXRlKCdkYXRhLXBsYW4nKTtcclxuICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtcGF5bG9hZCcpO1xyXG5cclxuICBuZXcgVnVlKHtcclxuICAgIGVsLFxyXG4gICAgZGF0YTogKCkgPT4gKHtcclxuICAgICAgY3VycmVuY3k6IFwiJFwiLFxyXG4gICAgICBwbGFucyxcclxuICAgICAgcGxhblRlcm06IHBsYW5zLnVzZC5taW5EdXJhdGlvbixcclxuICAgICAgLy8gcGxhblRlcm06IHBsYW4ubWluRHVyYXRpb24sXHJcbiAgICAgIGRlcG9zaXQ6IDAsXHJcbiAgICAgIGlzUnVsZXNBY2NlcHRlZDogZmFsc2VcclxuICAgIH0pLFxyXG5cclxuICAgIGNvbXB1dGVkOiB7XHJcbiAgICAgIHBsYW4oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVuY3kgPT09IFwiJFwiKSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5wbGFucy51c2Q7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLnBsYW5zLmJ0YztcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICBtaW5JbnZlc3RCaXRjb2luKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5wbGFuLm1pbkludmVzdCkudG9GaXhlZCg4KTtcclxuICAgICAgfSxcclxuXHJcbiAgICAgIG1heEludmVzdEJpdGNvaW4oKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnBsYW4ubWF4SW52ZXN0KS50b0ZpeGVkKDgpO1xyXG4gICAgICB9LFxyXG5cclxuICAgICAgaXNEZXBvc2l0Q29ycmVjdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kZXBvc2l0ID49IHRoaXMucGxhbi5taW5JbnZlc3QgJiYgdGhpcy5kZXBvc2l0IDw9IHRoaXMucGxhbi5tYXhJbnZlc3Q7XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICB0b3RhbFByb2ZpdCgpIHtcclxuICAgICAgICBjb25zdCB0b3RhbFByb2ZpdFJhdyA9IHRoaXMuZGVwb3NpdCAqIHRoaXMucGxhblRlcm0gKiB0aGlzLnBsYW4ucHJvZml0O1xyXG4gICAgICAgIGNvbnN0IHRvdGFsUHJvZml0ID0gdGhpcy5wbGFuLmJvZHlSZXR1cm4gPyB0b3RhbFByb2ZpdFJhdyArIHRoaXMuZGVwb3NpdCA6IHRvdGFsUHJvZml0UmF3XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVuY3kgPT09IFwiJFwiKSB7XHJcbiAgICAgICAgICByZXR1cm4gdG90YWxQcm9maXQudG9GaXhlZCgwKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmV0dXJuIHRvdGFsUHJvZml0LnRvRml4ZWQoMTApO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuXHJcbiAgICAgIGlzQWxsRmllbGRzVmVyaWZpZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNEZXBvc2l0Q29ycmVjdCAmJiB0aGlzLmlzUnVsZXNBY2NlcHRlZDtcclxuICAgICAgfSxcclxuXHJcbiAgICAgIHNvbWVGaWVsZHNJbmNvcnJlY3QoKSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLmlzQWxsRmllbGRzVmVyaWZpZWQ7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgbWV0aG9kczoge1xyXG4gICAgICBtYWtlRGVwb3NpdCgpIHtcclxuICAgICAgICBsZXQgcG9wdXAgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucG9wdXAnKTtcclxuICAgICAgICBwb3B1cC5zdHlsZS5kaXNwbGF5ID0gXCJmbGV4XCI7XHJcbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnBvcHVwX19idG4tY2xvc2UnKS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgcG9wdXAuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm92ZXJsYXknKS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgcG9wdXAuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICBjaG9vc2VDdXJyZW5jeShldmVudCkge1xyXG4gICAgICAgIHRoaXMuZGVwb3NpdCA9IDA7XHJcbiAgICAgICAgdGhpcy5wbGFuVGVybSA9IHRoaXMucGxhbi5taW5EdXJhdGlvbjtcclxuXHJcbiAgICAgICAgbGV0IGN1cnJlbmN5TGFiZWxzID0gZXZlbnQudGFyZ2V0LmNsb3Nlc3QoJy5wbGFuX19jdXJyZW5jaWVzJykuY2hpbGRyZW47XHJcblxyXG4gICAgICAgIGZvciAodmFyIGk9MCwgY2hpbGQ7IGNoaWxkPWN1cnJlbmN5TGFiZWxzW2ldOyBpKyspIHtcclxuICAgICAgICAgIGNoaWxkLmNsYXNzTGlzdC5yZW1vdmUoJ3NlbGVjdGVkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV2ZW50LnRhcmdldC5wYXJlbnROb2RlLmNsYXNzTGlzdC5hZGQoJ3NlbGVjdGVkJyk7XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICBpbmRpY2F0ZUN1cnJlbmN5U3ltYm9sKGlucHV0LCBzcGFucykge1xyXG4gICAgICAgIGlmIChpbnB1dC5jaGVja2VkKSB7XHJcbiAgICAgICAgICBzcGFucy5mb3JFYWNoKHNwYW4gPT4ge1xyXG4gICAgICAgICAgICBzcGFuLmlubmVySFRNTCA9IFwi4oK/XCI7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgc3BhbnMuZm9yRWFjaChzcGFuID0+IHtcclxuICAgICAgICAgICAgc3Bhbi5pbm5lckhUTUwgPSBcIiRcIjtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuXHJcbiAgICAgIGNvbnZlcnRUb0RlY2ltYWwoZXZlbnQpIHtcclxuICAgICAgICBjb25zb2xlLmxvZygndHlwZW9mIFZhbHVlOiAnLCB0eXBlb2YgZXZlbnQudGFyZ2V0LnZhbHVlKTtcclxuICAgICAgICAvLyBldmVudC50YXJnZXQudmFsdWUgPSBwYXJzZUZsb2F0KGV2ZW50LnRhcmdldC52YWx1ZSk7XHJcbiAgICAgICAgLy8gZXZlbnQudGFyZ2V0LnZhbHVlID0gKGV2ZW50LnRhcmdldC52YWx1ZSkudG9GaXhlZCg4KTtcclxuICAgICAgICAvLyBldmVudC50YXJnZXQudmFsdWUgPSBcIjAuMDAwMDAwMFwiICsgU3RyaW5nKGV2ZW50LnRhcmdldC52YWx1ZSkuY2hhckF0KDApO1xyXG4gICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICB9KTtcclxufSlcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/js/app.js\n");
=======
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.js\");\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_0__);\n\ndocument.querySelectorAll('[data-plan=\"calculator\"]').forEach(function (el) {\n  var plans = JSON.parse(el.getAttribute('data-payload'));\n  el.removeAttribute('data-plan');\n  el.removeAttribute('data-payload');\n  new vue__WEBPACK_IMPORTED_MODULE_0___default.a({\n    el: el,\n    data: function data() {\n      return {\n        currency: \"$\",\n        plans: plans,\n        planTerm: plans.usd.minDuration,\n        // planTerm: plan.minDuration,\n        deposit: 0,\n        isRulesAccepted: false\n      };\n    },\n    computed: {\n      plan: function plan() {\n        if (this.currency === \"$\") {\n          return this.plans.usd;\n        } else {\n          return this.plans.btc;\n        }\n      },\n      minInvestBitcoin: function minInvestBitcoin() {\n        return this.plan.minInvest.toFixed(8);\n      },\n      maxInvestBitcoin: function maxInvestBitcoin() {\n        return this.plan.maxInvest.toFixed(8);\n      },\n      isDepositCorrect: function isDepositCorrect() {\n        return this.deposit >= this.plan.minInvest && this.deposit <= this.plan.maxInvest;\n      },\n      totalProfit: function totalProfit() {\n        var totalProfitRaw = parseFloat(this.deposit) * this.planTerm * this.plan.profit;\n        var totalProfit = this.plan.bodyReturn ? totalProfitRaw + parseFloat(this.deposit) : totalProfitRaw;\n\n        if (this.currency === \"$\") {\n          return totalProfit.toFixed(0);\n        } else {\n          return totalProfit.toFixed(10);\n        }\n      },\n      isAllFieldsVerified: function isAllFieldsVerified() {\n        return this.isDepositCorrect && this.isRulesAccepted;\n      },\n      someFieldsIncorrect: function someFieldsIncorrect() {\n        return !this.isAllFieldsVerified;\n      }\n    },\n    methods: {\n      makeDeposit: function makeDeposit() {\n        var popup = document.querySelector('.popup');\n        popup.style.display = \"flex\";\n        document.querySelector('.popup__btn-close').addEventListener(\"click\", function () {\n          popup.style.display = \"none\";\n        }.bind(this));\n        document.querySelector('.overlay').addEventListener(\"click\", function () {\n          popup.style.display = \"none\";\n        }.bind(this));\n      },\n      chooseCurrency: function chooseCurrency(event) {\n        this.deposit = 0;\n        this.planTerm = this.plan.minDuration;\n        var currencyLabels = event.target.closest('.plan__currencies').children;\n\n        for (var i = 0, child; child = currencyLabels[i]; i++) {\n          child.classList.remove('selected');\n        }\n\n        event.target.parentNode.classList.add('selected');\n      },\n      indicateCurrencySymbol: function indicateCurrencySymbol(input, spans) {\n        if (input.checked) {\n          spans.forEach(function (span) {\n            span.innerHTML = \"₿\";\n          });\n        } else {\n          spans.forEach(function (span) {\n            span.innerHTML = \"$\";\n          });\n        }\n      }\n    }\n  });\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvYXBwLmpzPzkwZTkiXSwibmFtZXMiOlsiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZm9yRWFjaCIsImVsIiwicGxhbnMiLCJKU09OIiwicGFyc2UiLCJnZXRBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJWdWUiLCJkYXRhIiwiY3VycmVuY3kiLCJwbGFuVGVybSIsInVzZCIsIm1pbkR1cmF0aW9uIiwiZGVwb3NpdCIsImlzUnVsZXNBY2NlcHRlZCIsImNvbXB1dGVkIiwicGxhbiIsImJ0YyIsIm1pbkludmVzdEJpdGNvaW4iLCJtaW5JbnZlc3QiLCJ0b0ZpeGVkIiwibWF4SW52ZXN0Qml0Y29pbiIsIm1heEludmVzdCIsImlzRGVwb3NpdENvcnJlY3QiLCJ0b3RhbFByb2ZpdCIsInRvdGFsUHJvZml0UmF3IiwicGFyc2VGbG9hdCIsInByb2ZpdCIsImJvZHlSZXR1cm4iLCJpc0FsbEZpZWxkc1ZlcmlmaWVkIiwic29tZUZpZWxkc0luY29ycmVjdCIsIm1ldGhvZHMiLCJtYWtlRGVwb3NpdCIsInBvcHVwIiwicXVlcnlTZWxlY3RvciIsInN0eWxlIiwiZGlzcGxheSIsImFkZEV2ZW50TGlzdGVuZXIiLCJiaW5kIiwiY2hvb3NlQ3VycmVuY3kiLCJldmVudCIsImN1cnJlbmN5TGFiZWxzIiwidGFyZ2V0IiwiY2xvc2VzdCIsImNoaWxkcmVuIiwiaSIsImNoaWxkIiwiY2xhc3NMaXN0IiwicmVtb3ZlIiwicGFyZW50Tm9kZSIsImFkZCIsImluZGljYXRlQ3VycmVuY3lTeW1ib2wiLCJpbnB1dCIsInNwYW5zIiwiY2hlY2tlZCIsInNwYW4iLCJpbm5lckhUTUwiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUFBLFFBQVEsQ0FBQ0MsZ0JBQVQsQ0FBMEIsMEJBQTFCLEVBQXNEQyxPQUF0RCxDQUE4RCxVQUFBQyxFQUFFLEVBQUk7QUFFbEUsTUFBTUMsS0FBSyxHQUFHQyxJQUFJLENBQUNDLEtBQUwsQ0FBV0gsRUFBRSxDQUFDSSxZQUFILENBQWdCLGNBQWhCLENBQVgsQ0FBZDtBQUVBSixJQUFFLENBQUNLLGVBQUgsQ0FBbUIsV0FBbkI7QUFDQUwsSUFBRSxDQUFDSyxlQUFILENBQW1CLGNBQW5CO0FBRUEsTUFBSUMsMENBQUosQ0FBUTtBQUNOTixNQUFFLEVBQUZBLEVBRE07QUFFTk8sUUFBSSxFQUFFO0FBQUEsYUFBTztBQUNYQyxnQkFBUSxFQUFFLEdBREM7QUFFWFAsYUFBSyxFQUFMQSxLQUZXO0FBR1hRLGdCQUFRLEVBQUVSLEtBQUssQ0FBQ1MsR0FBTixDQUFVQyxXQUhUO0FBSVg7QUFDQUMsZUFBTyxFQUFFLENBTEU7QUFNWEMsdUJBQWUsRUFBRTtBQU5OLE9BQVA7QUFBQSxLQUZBO0FBV05DLFlBQVEsRUFBRTtBQUNSQyxVQURRLGtCQUNEO0FBQ0wsWUFBSSxLQUFLUCxRQUFMLEtBQWtCLEdBQXRCLEVBQTJCO0FBQ3pCLGlCQUFPLEtBQUtQLEtBQUwsQ0FBV1MsR0FBbEI7QUFDRCxTQUZELE1BRU87QUFDTCxpQkFBTyxLQUFLVCxLQUFMLENBQVdlLEdBQWxCO0FBQ0Q7QUFDRixPQVBPO0FBU1JDLHNCQVRRLDhCQVNXO0FBQ2pCLGVBQVEsS0FBS0YsSUFBTCxDQUFVRyxTQUFYLENBQXNCQyxPQUF0QixDQUE4QixDQUE5QixDQUFQO0FBQ0QsT0FYTztBQWFSQyxzQkFiUSw4QkFhVztBQUNqQixlQUFRLEtBQUtMLElBQUwsQ0FBVU0sU0FBWCxDQUFzQkYsT0FBdEIsQ0FBOEIsQ0FBOUIsQ0FBUDtBQUNELE9BZk87QUFpQlJHLHNCQWpCUSw4QkFpQlc7QUFDakIsZUFBTyxLQUFLVixPQUFMLElBQWdCLEtBQUtHLElBQUwsQ0FBVUcsU0FBMUIsSUFBdUMsS0FBS04sT0FBTCxJQUFnQixLQUFLRyxJQUFMLENBQVVNLFNBQXhFO0FBQ0QsT0FuQk87QUFxQlJFLGlCQXJCUSx5QkFxQk07QUFDWixZQUFNQyxjQUFjLEdBQUdDLFVBQVUsQ0FBQyxLQUFLYixPQUFOLENBQVYsR0FBMkIsS0FBS0gsUUFBaEMsR0FBMkMsS0FBS00sSUFBTCxDQUFVVyxNQUE1RTtBQUNBLFlBQU1ILFdBQVcsR0FBRyxLQUFLUixJQUFMLENBQVVZLFVBQVYsR0FBdUJILGNBQWMsR0FBR0MsVUFBVSxDQUFDLEtBQUtiLE9BQU4sQ0FBbEQsR0FBbUVZLGNBQXZGOztBQUNBLFlBQUksS0FBS2hCLFFBQUwsS0FBa0IsR0FBdEIsRUFBMkI7QUFDekIsaUJBQU9lLFdBQVcsQ0FBQ0osT0FBWixDQUFvQixDQUFwQixDQUFQO0FBQ0QsU0FGRCxNQUVPO0FBQ0wsaUJBQU9JLFdBQVcsQ0FBQ0osT0FBWixDQUFvQixFQUFwQixDQUFQO0FBQ0Q7QUFDRixPQTdCTztBQStCUlMseUJBL0JRLGlDQStCYztBQUNwQixlQUFPLEtBQUtOLGdCQUFMLElBQXlCLEtBQUtULGVBQXJDO0FBQ0QsT0FqQ087QUFtQ1JnQix5QkFuQ1EsaUNBbUNjO0FBQ3BCLGVBQU8sQ0FBQyxLQUFLRCxtQkFBYjtBQUNEO0FBckNPLEtBWEo7QUFtRE5FLFdBQU8sRUFBRTtBQUNQQyxpQkFETyx5QkFDTztBQUNaLFlBQUlDLEtBQUssR0FBR25DLFFBQVEsQ0FBQ29DLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBWjtBQUNBRCxhQUFLLENBQUNFLEtBQU4sQ0FBWUMsT0FBWixHQUFzQixNQUF0QjtBQUNBdEMsZ0JBQVEsQ0FBQ29DLGFBQVQsQ0FBdUIsbUJBQXZCLEVBQTRDRyxnQkFBNUMsQ0FBNkQsT0FBN0QsRUFBc0UsWUFBWTtBQUNoRkosZUFBSyxDQUFDRSxLQUFOLENBQVlDLE9BQVosR0FBc0IsTUFBdEI7QUFDRCxTQUZxRSxDQUVwRUUsSUFGb0UsQ0FFL0QsSUFGK0QsQ0FBdEU7QUFHQXhDLGdCQUFRLENBQUNvQyxhQUFULENBQXVCLFVBQXZCLEVBQW1DRyxnQkFBbkMsQ0FBb0QsT0FBcEQsRUFBNkQsWUFBWTtBQUN2RUosZUFBSyxDQUFDRSxLQUFOLENBQVlDLE9BQVosR0FBc0IsTUFBdEI7QUFDRCxTQUY0RCxDQUUzREUsSUFGMkQsQ0FFdEQsSUFGc0QsQ0FBN0Q7QUFHRCxPQVZNO0FBWVBDLG9CQVpPLDBCQVlRQyxLQVpSLEVBWWU7QUFDcEIsYUFBSzNCLE9BQUwsR0FBZSxDQUFmO0FBQ0EsYUFBS0gsUUFBTCxHQUFnQixLQUFLTSxJQUFMLENBQVVKLFdBQTFCO0FBRUEsWUFBSTZCLGNBQWMsR0FBR0QsS0FBSyxDQUFDRSxNQUFOLENBQWFDLE9BQWIsQ0FBcUIsbUJBQXJCLEVBQTBDQyxRQUEvRDs7QUFFQSxhQUFLLElBQUlDLENBQUMsR0FBQyxDQUFOLEVBQVNDLEtBQWQsRUFBcUJBLEtBQUssR0FBQ0wsY0FBYyxDQUFDSSxDQUFELENBQXpDLEVBQThDQSxDQUFDLEVBQS9DLEVBQW1EO0FBQ2pEQyxlQUFLLENBQUNDLFNBQU4sQ0FBZ0JDLE1BQWhCLENBQXVCLFVBQXZCO0FBQ0Q7O0FBQ0RSLGFBQUssQ0FBQ0UsTUFBTixDQUFhTyxVQUFiLENBQXdCRixTQUF4QixDQUFrQ0csR0FBbEMsQ0FBc0MsVUFBdEM7QUFDRCxPQXRCTTtBQXdCUEMsNEJBeEJPLGtDQXdCZ0JDLEtBeEJoQixFQXdCdUJDLEtBeEJ2QixFQXdCOEI7QUFDbkMsWUFBSUQsS0FBSyxDQUFDRSxPQUFWLEVBQW1CO0FBQ2pCRCxlQUFLLENBQUNyRCxPQUFOLENBQWMsVUFBQXVELElBQUksRUFBSTtBQUNwQkEsZ0JBQUksQ0FBQ0MsU0FBTCxHQUFpQixHQUFqQjtBQUNELFdBRkQ7QUFHRCxTQUpELE1BSU87QUFDTEgsZUFBSyxDQUFDckQsT0FBTixDQUFjLFVBQUF1RCxJQUFJLEVBQUk7QUFDcEJBLGdCQUFJLENBQUNDLFNBQUwsR0FBaUIsR0FBakI7QUFDRCxXQUZEO0FBR0Q7QUFDRjtBQWxDTTtBQW5ESCxHQUFSO0FBMEZELENBakdEIiwiZmlsZSI6Ii4vc3JjL2pzL2FwcC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBWdWUgZnJvbSBcInZ1ZVwiO1xyXG5cclxuZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtcGxhbj1cImNhbGN1bGF0b3JcIl0nKS5mb3JFYWNoKGVsID0+IHtcclxuXHJcbiAgY29uc3QgcGxhbnMgPSBKU09OLnBhcnNlKGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1wYXlsb2FkJykpO1xyXG5cclxuICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtcGxhbicpO1xyXG4gIGVsLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1wYXlsb2FkJyk7XHJcblxyXG4gIG5ldyBWdWUoe1xyXG4gICAgZWwsXHJcbiAgICBkYXRhOiAoKSA9PiAoe1xyXG4gICAgICBjdXJyZW5jeTogXCIkXCIsXHJcbiAgICAgIHBsYW5zLFxyXG4gICAgICBwbGFuVGVybTogcGxhbnMudXNkLm1pbkR1cmF0aW9uLFxyXG4gICAgICAvLyBwbGFuVGVybTogcGxhbi5taW5EdXJhdGlvbixcclxuICAgICAgZGVwb3NpdDogMCxcclxuICAgICAgaXNSdWxlc0FjY2VwdGVkOiBmYWxzZVxyXG4gICAgfSksXHJcblxyXG4gICAgY29tcHV0ZWQ6IHtcclxuICAgICAgcGxhbigpIHtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW5jeSA9PT0gXCIkXCIpIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLnBsYW5zLnVzZDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMucGxhbnMuYnRjO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuXHJcbiAgICAgIG1pbkludmVzdEJpdGNvaW4oKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnBsYW4ubWluSW52ZXN0KS50b0ZpeGVkKDgpO1xyXG4gICAgICB9LFxyXG5cclxuICAgICAgbWF4SW52ZXN0Qml0Y29pbigpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMucGxhbi5tYXhJbnZlc3QpLnRvRml4ZWQoOCk7XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICBpc0RlcG9zaXRDb3JyZWN0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRlcG9zaXQgPj0gdGhpcy5wbGFuLm1pbkludmVzdCAmJiB0aGlzLmRlcG9zaXQgPD0gdGhpcy5wbGFuLm1heEludmVzdDtcclxuICAgICAgfSxcclxuXHJcbiAgICAgIHRvdGFsUHJvZml0KCkge1xyXG4gICAgICAgIGNvbnN0IHRvdGFsUHJvZml0UmF3ID0gcGFyc2VGbG9hdCh0aGlzLmRlcG9zaXQpICogdGhpcy5wbGFuVGVybSAqIHRoaXMucGxhbi5wcm9maXQ7XHJcbiAgICAgICAgY29uc3QgdG90YWxQcm9maXQgPSB0aGlzLnBsYW4uYm9keVJldHVybiA/IHRvdGFsUHJvZml0UmF3ICsgcGFyc2VGbG9hdCh0aGlzLmRlcG9zaXQpIDogdG90YWxQcm9maXRSYXdcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW5jeSA9PT0gXCIkXCIpIHtcclxuICAgICAgICAgIHJldHVybiB0b3RhbFByb2ZpdC50b0ZpeGVkKDApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXR1cm4gdG90YWxQcm9maXQudG9GaXhlZCgxMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG5cclxuICAgICAgaXNBbGxGaWVsZHNWZXJpZmllZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc0RlcG9zaXRDb3JyZWN0ICYmIHRoaXMuaXNSdWxlc0FjY2VwdGVkO1xyXG4gICAgICB9LFxyXG5cclxuICAgICAgc29tZUZpZWxkc0luY29ycmVjdCgpIHtcclxuICAgICAgICByZXR1cm4gIXRoaXMuaXNBbGxGaWVsZHNWZXJpZmllZDtcclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBtZXRob2RzOiB7XHJcbiAgICAgIG1ha2VEZXBvc2l0KCkge1xyXG4gICAgICAgIGxldCBwb3B1cCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5wb3B1cCcpO1xyXG4gICAgICAgIHBvcHVwLnN0eWxlLmRpc3BsYXkgPSBcImZsZXhcIjtcclxuICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucG9wdXBfX2J0bi1jbG9zZScpLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICBwb3B1cC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcub3ZlcmxheScpLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICBwb3B1cC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgICAgfSxcclxuXHJcbiAgICAgIGNob29zZUN1cnJlbmN5KGV2ZW50KSB7XHJcbiAgICAgICAgdGhpcy5kZXBvc2l0ID0gMDtcclxuICAgICAgICB0aGlzLnBsYW5UZXJtID0gdGhpcy5wbGFuLm1pbkR1cmF0aW9uO1xyXG5cclxuICAgICAgICBsZXQgY3VycmVuY3lMYWJlbHMgPSBldmVudC50YXJnZXQuY2xvc2VzdCgnLnBsYW5fX2N1cnJlbmNpZXMnKS5jaGlsZHJlbjtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaT0wLCBjaGlsZDsgY2hpbGQ9Y3VycmVuY3lMYWJlbHNbaV07IGkrKykge1xyXG4gICAgICAgICAgY2hpbGQuY2xhc3NMaXN0LnJlbW92ZSgnc2VsZWN0ZWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZXZlbnQudGFyZ2V0LnBhcmVudE5vZGUuY2xhc3NMaXN0LmFkZCgnc2VsZWN0ZWQnKTtcclxuICAgICAgfSxcclxuXHJcbiAgICAgIGluZGljYXRlQ3VycmVuY3lTeW1ib2woaW5wdXQsIHNwYW5zKSB7XHJcbiAgICAgICAgaWYgKGlucHV0LmNoZWNrZWQpIHtcclxuICAgICAgICAgIHNwYW5zLmZvckVhY2goc3BhbiA9PiB7XHJcbiAgICAgICAgICAgIHNwYW4uaW5uZXJIVE1MID0gXCLigr9cIjtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBzcGFucy5mb3JFYWNoKHNwYW4gPT4ge1xyXG4gICAgICAgICAgICBzcGFuLmlubmVySFRNTCA9IFwiJFwiO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICB9KTtcclxufSlcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/js/app.js\n");
>>>>>>> two-currencies

/***/ })

/******/ });